<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Setting MathJax with Hugo]]></title>
    <url>%2Fhexo-blog%2F2018%2F07%2F10%2Fsetting-mathjax-with-hugo%2F</url>
    <content type="text"><![CDATA[MathJax - Beautiful math in all browsers A JavaScript display engine for mathematics that works in all browsers. No more setup for readers. It just works. The code of MathJax in Hugo themeCreate a file named mathjax_support.html in the /layout/partials/ folder. Insert the below code into it, for example. 12345678910111213141516&lt;script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt;&lt;script type="text/x-mathjax-config"&gt;MathJax.Hub.Config(&#123; tex2jax: &#123; inlineMath: [['$','$'], ['\\(','\\)']], displayMath: [['$$','$$'], ['\[','\]']], processEscapes: true, processEnvironments: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'], TeX: &#123; equationNumbers: &#123; autoNumber: "AMS" &#125;, extensions: ["AMSmath.js", "AMSsymbols.js"] &#125; &#125;&#125;);&lt;/script&gt; Then, include mathjax_support.html in footer.html or header.html. In my case. I chose to put it in header.html as follows: 1&#123;&#123; if .Params.mathjax&#125;&#125;&#123;&#123; partial "mathjax_support.html" . &#125;&#125;&#123;&#123; end &#125;&#125; This code means mathjax_support.html will be include as long as you add mathjax = ture to your front matter. Using MathJax in your postFirst, add mathjax = ture to your front matter. It could be like this. 123456789+++title = "Setting MathJax with Hugo"date = 2018-07-10T14:28:41+08:00draft = falsemathjax = truetoc = truecategories = [ "Technology", "Web" ]tags = [ "MathJax", "Hugo" ]+++ Second, write LaTeX code in your post, put inline math into &#39;$&#39;,&#39;$&#39;, and display math between &#39;$$&#39;,&#39;$$&#39;. Inline mathHere is inline math: $\sqrt{3x-1}+(1+x)^2$ The result is: $\sqrt{3x-1}+(1+x)^2$ Display mathHere is display math: 12345678$$\begin&#123;align&#125; \nabla \times \vec&#123;\mathbf&#123;B&#125;&#125; -\, \frac1c\, \frac&#123;\partial\vec&#123;\mathbf&#123;E&#125;&#125;&#125;&#123;\partial t&#125; &amp; = \frac&#123;4\pi&#125;&#123;c&#125;\vec&#123;\mathbf&#123;j&#125;&#125; \newline \nabla \cdot \vec&#123;\mathbf&#123;E&#125;&#125; &amp; = 4 \pi \rho \newline \nabla \times \vec&#123;\mathbf&#123;E&#125;&#125;\, +\, \frac1c\, \frac&#123;\partial\vec&#123;\mathbf&#123;B&#125;&#125;&#125;&#123;\partial t&#125; &amp; = \vec&#123;\mathbf&#123;0&#125;&#125; \newline \nabla \cdot \vec&#123;\mathbf&#123;B&#125;&#125; &amp; = 0\end&#123;align&#125;$$ The result is:$$\begin{align} \nabla \times \vec{\mathbf{B}} -\, \frac1c\, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \newline \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \newline \nabla \times \vec{\mathbf{E}}\, +\, \frac1c\, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \newline \nabla \cdot \vec{\mathbf{B}} &amp; = 0\end{align}$$ Subscript issue with markdownAfter enabling MathJax, any math entered between proper markers (see the MathJax documentation) will be processed and typeset in the web page. One issue that comes up, however, with Markdown is that the underscore character (_) is interpreted by Markdown as a way to wrap text in emph blocks while LaTeX (MathJax) interprets the underscore as a way to create a subscript. This “double speak” of the underscore can result in some unexpected and unwanted behavior. There are many solutions to the problem, the Hugo official document hints a way to make MathJax work. It revolves a series of complex steps to correctly display LaTeX code. And you have to put inline mathematics between &#39;$ TeX Code $&#39;, and put display style mathematics between &lt;div&gt;$$TeX Code$$&lt;/div&gt;. This method treats ‘inline math’ with ‘code’, which may get some trouble in your website style. I think it’s too complex and tedious, my suggestion is to simply use \_ instead of _ in your LaTeX code. Here is a example: $\sum\_{k=1}^n a\_k$ The result is $\sum_{k=1}^n a_k$.]]></content>
      <categories>
        <category>Technology</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>MathJax</tag>
        <tag>Hugo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义emacs mode-line]]></title>
    <url>%2Fhexo-blog%2F2018%2F07%2F09%2Fcustomize-emacs-mode-line%2F</url>
    <content type="text"><![CDATA[一些常用的mode-line包 powerline smart-mode-line spaceline telephone-line 了解mode-linemode-line初始值：123(&quot;%e&quot; mode-line-front-space mode-line-mule-info mode-line-client mode-line-modified mode-line-remote mode-line-frame-identification mode-line-buffer-identification &quot; &quot; mode-line-position (vc-mode vc-mode) &quot; &quot; mode-line-modes mode-line-misc-info mode-line-end-spaces) mode-line变量 mode-line-mule-info：显示当前语言环境、编码信息和输入法； mode-line-modified：显示当前内容是否被修改，**表示已经被修改，--表示没有被修改，%%表示只读，%*表示只读但是被修改； mode-line-frame-identification：用来标识当前窗口； mode-line-buffer-identification：用来表示当前buffer； mode-line-position：用来表示在buffer中的位置，可显示位置百分比、buffer大小、当前行号和列号； mode-line-percent-position：在mode-line-position中被使用； vc-mode：显示版本管理信息； mode-line-modes：显示当前major和minor modes； mode-line-remote：用来显示当前buffer的default-directory是否是远程文件夹； mode-line-client：用来表示emacsclient窗口； mode-name： 显示当前buffer的major mode； mode-line-front-space：显示在mode-line最前面； mode-line-end-spaces：显示在mode-line最后面； mode-line-misc-info：显示杂项信息； minor-mode-alist：包含当前buffer激活的所有minor modes； global-mode-string：This variable holds a mode line construct that, by default, appears in the mode line just after the which-func-mode minor mode if set, else after mode-line-modes. The command display-time sets global-mode-string to refer to the variable display-time-string, which holds a string containing the time and load information. The ‘%M’ construct substitutes the value of global-mode-string, but that is obsolete, since the variable is included in the mode line from mode-line-format. %-Constructs in the Mode Line %b：当前buffer名称； %c：当前列号，从最左边0开始计算； %C：当前列号，从最左边1开始计算； %e：When Emacs is nearly out of memory for Lisp objects, a brief message saying so. Otherwise, this is empty. %f：文件名； %F：窗口名称； %i：当前buffer大小； %I：Like ‘%i’, but the size is printed in a more readable way by using ‘k’ for 10^3, ‘M’ for 10^6, ‘G’ for 10^9, etc., to abbreviate. %l：当前行号； %n：‘Narrow’ when narrowing is in effect; nothing otherwise. %o：The degree of travel of the window through (the visible portion of) the buffer, i.e. the size of the text above the top of the window expressed as a percentage of all the text outside the window, or ‘Top’, ‘Bottom’ or ‘All’. %p：The percentage of the buffer text above the top of window, or ‘Top’, ‘Bottom’ or ‘All’. Note that the default mode line construct truncates this to three characters. %P：The percentage of the buffer text that is above the bottom of the window (which includes the text visible in the window, as well as the text above the top), plus ‘Top’ if the top of the buffer is visible on screen; or ‘Bottom’ or ‘All’. %q：The percentages of text above both the top and the bottom of the window, separated by ‘-’, or ‘All’. %s：The status of the subprocess belonging to the current buffer, obtained with process-status. %z：The mnemonics of keyboard, terminal, and buffer coding systems. %Z：Like ‘%z’, but including the end-of-line format. %*：‘%’ if the buffer is read only (see buffer-read-only); ‘*’ if the buffer is modified (see buffer-modified-p); ‘-’ otherwise. %+：‘*’ if the buffer is modified (see buffer-modified-p); ‘%’ if the buffer is read only (see buffer-read-only); ‘-’ otherwise. This differs from ‘%*’ only for a modified read-only buffer. %&amp;：‘*’ if the buffer is modified, and ‘-’ otherwise. %[：An indication of the depth of recursive editing levels (not counting minibuffer levels): one ‘[’ for each editing level. %]：One ‘]’ for each recursive editing level (not counting minibuffer levels). %-：Dashes sufficient to fill the remainder of the mode line. %%：The character ‘%’—this is how to include a literal ‘%’ in a string in which %-constructs are allowed. %m：mode-name； %M：global-mode-string； 自定义mode-line修改mode-line-format的值：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980(defun dotemacs-mode-line-fill (face reserve) &quot;Return empty space using FACE and leaving RESERVE space on the right.&quot; (unless reserve (setq reserve 20)) (when (and (display-graphic-p) (eq &apos;right (get-scroll-bar-mode))) (setq reserve (- reserve 3))) (propertize &quot; &quot; &apos;display `((space :align-to (- (+ right right-fringe right-margin) ,reserve))) &apos;face face))(defun dotemacs-buffer-encoding-abbrev () &quot;The line ending convention used in the buffer.&quot; (let ((buf-coding (format &quot;%s&quot; buffer-file-coding-system))) (if (string-match &quot;\\(dos\\|unix\\|mac\\)&quot; buf-coding) (match-string 1 buf-coding) buf-coding)))(setq-default mode-line-format (list &quot;%e&quot; mode-line-front-space ;; mode-line-mule-info ;; mode-line-client ;; mode-line-modified ;; mode-line-remote ;; mode-line-frame-identification &quot; &quot; ;; mode-line-buffer-identification &apos;(:eval (propertize &quot;%b&quot; &apos;face &apos;font-lock-keyword-face &apos;help-echo (buffer-file-name))) &quot; [&quot; ;; insert vs overwrite mode, input-method in a tooltip &apos;(:eval (propertize (if overwrite-mode &quot;Ovr&quot; &quot;Ins&quot;) &apos;face &apos;font-lock-preprocessor-face &apos;help-echo (concat &quot;Buffer is in &quot; (if overwrite-mode &quot;overwrite&quot; &quot;insert&quot;) &quot; mode&quot;))) ;; was this buffer modified since the last save? &apos;(:eval (when (buffer-modified-p) (concat &quot;,&quot; (propertize &quot;Mod&quot; &apos;face &apos;font-lock-warning-face &apos;help-echo &quot;Buffer has been modified&quot;)))) ;; is this buffer read-only? &apos;(:eval (when buffer-read-only (concat &quot;,&quot; (propertize &quot;RO&quot; &apos;face &apos;font-lock-type-face &apos;help-echo &quot;Buffer is read-only&quot;)))) &quot;] &quot; &quot;[&quot; (propertize &quot;%p&quot; &apos;face &apos;font-lock-constant-face) &quot;/&quot; (propertize &quot;%I&quot; &apos;face &apos;font-lock-constant-face) &quot;] &quot; mode-line-modes &quot; &quot; &apos;(:eval `(vc-mode vc-mode)) &quot; &quot; ;; (dotemacs-mode-line-fill &apos;mode-line 35) ;;mode-line-position &quot; (&quot; (propertize &quot;%l&quot; &apos;face &apos;font-lock-type-face) &quot;,&quot; (propertize &quot;%c&quot; &apos;face &apos;font-lock-type-face) &quot;) &quot; &apos;(:eval (dotemacs-buffer-encoding-abbrev)) &quot; &quot; &apos;(:eval mode-line-misc-info) mode-line-end-spaces )) 隐藏mode-line上的minor mode使用diminish：12345(require &apos;diminish);; Hide jiggle-mode lighter from mode line(diminish &apos;jiggle-mode);; Replace abbrev-mode lighter with &quot;Abv&quot;(diminish &apos;abbrev-mode &quot;Abv&quot;)]]></content>
      <categories>
        <category>Software</category>
        <category>emacs</category>
      </categories>
      <tags>
        <tag>emacs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) SNMP：简单网络管理协议]]></title>
    <url>%2Fhexo-blog%2F2018%2F06%2F14%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-snmp%2F</url>
    <content type="text"><![CDATA[随着网络技术的飞速发展，网络的数量也越来越多。而网络中的设备来自各个不同的厂家，如何管理这些设备就变得十分重要。本章的内容就是介绍管理这些设备的标准。 基于TCP/IP的网络管理包含两个部分：网络管理站（也叫管理进程，manager）和被管的网络单元（也叫被管设备）。被管设备种类繁多，例如：路由器、X终端、终端服务器和打印机等。这些被管设备的共同点就是都运行TCP/IP协议。被管设备端和管理相关的软件叫做代理程序(agent)或代理进程。管理站一般都是带有彩色监视器的工作站，可以显示所有被管设备的状态(例如连接是否掉线、各种连接上的流量状况等)。 管理进程和代理进程之间的通信可以有两种方式。一种是管理进程向代理进程发出请求，询问一个具体的参数值（例如：你产生了多少个不可达的ICMP端口？）。另外一种方式是代理进程主动向管理进程报告有某些重要的事件发生（例如：一个连接口掉线了）。当然，管理进程除了可以向代理进程询问某些参数值以外，它还可以按要求改变代理进程的参数值（例如：把默认的IP TTL值改为64）。 基于TCP/IP的网络管理包含3个组成部分： 一个管理信息库MIB（Management Information Base）。管理信息库包含所有代理进程的所有可被查询和修改的参数。RFC 1213 [McCloghrie and Rose 1991]定义了第二版的MIB，叫做MIB-II。 关于MIB的一套公用的结构和表示符号。叫做管理信息结构SMI（Structure of Management Information）。这个在RFC 1155 [Rose and McCloghrie 1990]中定义。例如：SMI定义计数器是一个非负整数，它的计数范围是0~4294 967 295，当达到最大值时，又从0开始计数。 管理进程和代理进程之间的通信协议，叫做简单网络管理协议SNMP（Simple Network Management Protocol）。在RFC 1157 [Case et al.1990]中定义。SNMP包括数据报交换的格式等。尽管可以在运输层采用各种各样的协议，但是在SNMP中，用得最多的协议还是UDP。 协议关于管理进程和代理进程之间的交互信息，SNMP定义了5种报文： get-request操作：从代理进程处提取一个或多个参数值。 get-next-request操作：从代理进程处提取一个或多个参数的下一个参数值。 set-request操作：设置代理进程的一个或多个参数值。 get-response操作：返回的一个或多个参数值。这个操作是由代理进程发出的。它是前面3中操作的响应操作。 trap操作：代理进程主动发出的报文，通知管理进程有某些事情发生。 前面的3个操作是由管理进程向代理进程发出的。后面两个是代理进程发给管理进程的（为简化起见，前面3个操作今后叫做get、get-next和set操作）。 既然这些操作中的前4种操作是简单的请求-应答方式（也就是管理进程发出请求，代理进程应答响应），而且在SNMP中往往使用UDP协议，所以可能发生管理进程和代理进程之间数据报丢失的情况。因此一定要有超时和重传机制。 管理进程发出的前面3种操作采用UDP的161端口。代理进程发出的Trap操作采用UDP的162端口。由于收发采用了不同的端口号，所以一个系统可以同时为管理进程和代理进程。 封装成UDP数据报的5种操作的SNMP报文格式： 版本字段是0。该字段的值是通过SNMP版本号减去1得到的。显然0代表SNMP v1。 下表显示各种PDU对应的值（PDU即协议数据单元，也就是分组）。 PDU类型 名称 0 get-request 1 get-next-request 2 get-response 3 set-request 4 trap 共同体字段是一个字符串。这是管理进程和代理进程之间的口令，是明文格式。默认的值是public。 对于get、get-next和set操作，请求标识由管理进程设置，然后由代理进程在get response中返回。这个字段的作用是使客户进程（在目前情况下是管理进程）能够将服务器进程（即代理进程）发出的响应和客户进程发出的查询进行匹配。这个字段允许管理进程对一个或多个代理进程发出多个请求，并且从返回的众多应答中进行分类。 差错状态字段是一个整数，它是由代理进程标注的，PDU类型名称指明有差错发生。 差错状态 名称 描述 0 noError 没有错误 1 tooBig 代理进程无法把响应放在一个SNMP消息中发出 2 noSuchName 操作一个不存在的变量 3 badValue set操作的值或语义有错误 4 readOnly 管理进程试图修改一个只读变量 5 genErr 其他错误 差错索引字段是一个整数偏移量，指明当有差错发生时，差错发生在哪个参数。它是由代理进程标注的，并且只有在发生noSuchName、readOnly和badValue差错时才进行标注。 在get、get-next和set的请求数据报中，包含变量名称和变量值的一张表。对于get和get-next操作，变量值部分被忽略，也就是不需要填写。 对于trap操作符（PDU类型是4），SNMP报文格式有所变化。 管理信息结构SNMP中，数据类型并不多。 INTEGER，OCTERSTRING，DisplayString，OBJECTIDENTIFIER，NULL，IpAddress，PhysAddress，Counter，Gauge，TimeTicks，SEQUENCE，SEQUENDEOF。 对象标识符对象标识是一种数据类型，它指明一种“授权”命名的对象。“授权”的意思就是这些标识不是随便分配的，它是由一些权威机构进行管理和分配的。 对象标识是一个整数序列，以点（“.”）分隔。这些整数构成一个树型结构。对象标识从树的顶部开始，顶部没有标识，以root表示（这和Unix中文件系统的树遍历方向非常类似）。 树上的每个结点同时还有一个文字名。例如标识1.3.6.1.2.1和iso.org.dod.internet.memt.mib对应。这主要是为了人们阅读方便。在实际应用中，也就是说在管理进程和代理进程进行数据报交互时，MIB变量名是以对象标识来标识的，当然都是以1.3.6.1.2.1开头的。 Trap代理进程可以主动发送trap到管理进程，以告诉管理进程在代理进程侧有某些管理进程所关心的事件发生。 现在已经定义了6种特定的trap类型，第7种trap类型是由供应商自己定义的特定类型。 trap类型 名称 描述 0 coldStart 代理进程对自己初始化 1 warmStart 代理进程对自己重新初始化 2 linkDown 一个接口已经从工作状态改变为故障状态 3 linkUp 一个接口已经从故障状态改变为工作状态 4 authenticationFaulure 从SNMP管理进程收到无效共同体的报文 5 egpNeighborLoss 一个EGP邻站已变为故障状态 6 enterpriseSpecific 在这个特定的代码字段中查找trap信息 ASN.1和BER在正式的SNMP规范中都是采用ASN.1（Abstract Syntax Notation 1）语法，并且在SNMP报文中比特的编码采用BER（Basic Encoding Rule）。 ASN.1是一种描述数据和数据特征的正式语言。它和数据的存储及编码无关。MIB和SNMP报文中的所有的字段都是用ASN.1描述的。 当有了这样的ASN.1定义，可以有多种编码方法把数据编码为传输的比特流。SNMP使用的编码方法是BER。例如，对于一个简单的整数如64，在BER中需要用3个字节来表示。第一个字节说明类型是一个整数，下个字节说明用了多少个字节来存储该整数（在这里是1），最后一个字节才是该整数的值。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>UDP</tag>
        <tag>SNMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卖米]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F31%2Fmaimi-feihua%2F</url>
    <content type="text"><![CDATA[作者：飞花 01天刚蒙蒙亮，母亲就把我叫起来了：“琼宝，今天是这里的场，我们担点米到场上卖了，好弄点钱给你爹买药。” 我迷迷糊糊睁开双眼，看看窗外，日头还没出来呢。我实在太困，又在床上赖了一会儿。 隔壁传来父亲的咳嗽声，母亲在厨房忙活着，饭菜的香气混合着淡淡的油烟味飘过来，慢慢驱散了我的睡意。我坐起来，穿好衣服，开始铺床。 “姐，我也跟你们一起去赶场好不好？你买冰棍给我吃！” 弟弟顶着一头睡得乱蓬蓬的头发跑到我房里来。 “毅宝，你不能去，你留在家里放水。”隔壁传来父亲的声音，夹杂着几声咳嗽。 弟弟有些不情愿地冲隔壁说：“爹，天气这么热，你自己昨天才中了暑，今天又叫我去，就不怕我也中暑！” “人怕热，庄稼不怕？都不去放水，地都干了，禾都死了，一家人喝西北风去？”父亲一动气，咳嗽得越发厉害了。 弟弟冲我吐吐舌头，扮了个鬼脸，就到父亲房里去了。 只听见父亲开始叮嘱他怎么放水，去哪个塘里引水，先放哪丘田，哪几个地方要格外留神别人来截水，等等。 02吃过饭，弟弟就找着父亲常用的那把锄头出去了。我和母亲开始往谷箩里装米，装完后先称了一下，一担八十多斤，一担六十多斤。 我说：“妈，我挑重的那担吧。” “你学生妹子，肩膀嫩，还是我来。” 母亲说着，一弯腰，把那担重的挑起来了。 我挑起那担轻的，跟着母亲出了门。 “路上小心点！咱们家的米好，别便宜卖了！”父亲披着衣服站在门口嘱咐道。 “知道了。你快回床上躺着吧。”母亲艰难地把头从扁担旁边扭过来，吩咐道，“饭菜在锅里，中午你叫毅宝热一下吃！” 赶场的地方离我家大约有四里路，我和母亲挑着米，在窄窄的田间小路上走走停停，足足走了一个钟头才到。场上的人已经不少了，我们赶紧找了一块空地，把担子放下来，把扁担放在地上，两个人坐在扁担上，拿草帽扇着。 一大早就这么热，中午就更不得了，我不由得替弟弟担心起来。 他去放水，是要在外头晒上一整天的。 我往四周看了看，发现场上有许多人卖米，莫非他们都等着用钱？ 场上的人大都眼熟，都是附近十里八里的乡亲，人家也是种田的，谁会来买米呢？ 03我问母亲，母亲说：“有专门的米贩子会来收米的。他们开了车到乡下来赶场，收了米，拉到城里去卖，能挣好些哩。” 我说：“凭什么都给他们挣？我们也拉到城里去卖好了！”其实自己也知道不过是气话。 果然，母亲说：“咱们这么一点米，又没车，真弄到城里去卖，挣的钱还不够路费呢！早先你爹身体好的时候，自己挑着一百来斤米进城 去卖，隔几天去一趟，倒比较划算一点。” 我不由心里一紧，心疼起父亲来。从家里到城里足足有三十多里山路呢，他挑着那么重的担子走着去，该多么辛苦！就为了多挣那几个钱，把人累成这样，多不值啊！但又有什么办法呢？家里除了种地，也没别的收入，不卖米，拿什么钱供我和弟弟上学？ 我想着这些，心里一阵阵难过起来。看看旁边的母亲，头发有些斑白了，黑黝黝的脸上爬上了好多皱纹，脑门上密密麻麻都是汗珠，眼睛有些红肿。 “妈，你喝点水。” 我把水壶递过去，拿草帽替她扇着。 04米贩子们终于开着车来了。他们四处看着卖米的人，走过去仔细看米的成色，还把手插进米里，抓上一把米细看。 “一块零五。” 米贩子开价了。 卖米的似乎嫌太低，想讨价还价。 “不还价，一口价，爱卖不卖！” 米贩子态度很强硬，毕竟，满场都是卖米的人，只有他们是买家，不趁机压价，更待何时？ 母亲注意着那边的情形说：“一块零五？也太便宜了。上场还卖到一块一呢。” 正说着，有个米贩子朝我们这边走过来了。 他把手插进大米里，抓了一把出来，迎着阳光细看着。 “这米好咧！又白又匀净，又筛得干净，一点沙子也没有！”母亲堆着笑，语气里有几分自豪。 的确，我家的米比场上其他人卖的米都好。 05那人点了点头，说：“米是好米，不过这几天城里跌价，再好的米也卖不出好价钱来。一块零五，卖不卖？” 母亲摇摇头：“这也太便宜了吧？上场还卖一块一呢。再说，你是识货的，一分钱一分货，我这米肯定好过别家的！” 那人又看了看米，犹豫了一下，说：“本来都是一口价，不许还的，看你们家米好，我加点，一块零八，怎么样？” 母亲还是摇头：“不行，我们家这米，少说也要卖到一块一。你再加点？” 那人冷笑一声，说：“今天肯定卖不出一块一的行情，我出一块零八你不卖，等会散场的时候你一块零五都卖不出去！” “卖不出去，我们再担回家！”那人的态度激恼了母亲。 “那你就等着担回家吧。”那人冷笑着，丢下这句话走了。 06我在旁边听着，心里算着：一块零八到一块一，每斤才差两分钱。 这里一共150斤米，总共也就三块钱的事情，路这么远，何必再挑回 去呢？ 我的肩膀还在痛呢。 我轻轻对母亲说：“妈，一块零八就一块零八吧，反正也就三块钱的事。再说，还等着钱给爹买药呢。” “那哪行？”母亲似乎有些生气了，“三块钱不是钱？再说了，也不光是几块钱的事，做生意也得讲点良心，咱们辛辛苦苦种出来的米，质量也好，哪能这么贱卖了？” 我不敢再说。 我知道种田有多么累。 光说夏天放水，不就把爹给病倒了？ 弟弟也才十一二岁的毛孩子，还不得找着锄头去放水！ 毕竟，这是一家人的生计啊！ 07又有几个米贩子过来了，他们也都只出一块零五。有一两个出到一块零八，也不肯再加。 母亲仍然不肯卖。 看看人渐渐少了，我有些着急了。 母亲一定也很心急吧，我想。 “妈，你去那边树下凉快一下吧！”我说。 母亲一边擦汗，一边摇头：“不行。我走开了，来人买米怎么办？你又不会还价！” 我有些惭愧。 “百无一用是书生”，虽然在学校里功课好，但这些事情上就比母亲差远了。 又有好些人来买米，因为我家的米实在是好，大家都过来看，但谁也不肯出到一块一。 看看日头到头顶上了，我觉得肚子饿了，便拿出带来的饭菜和母亲一起吃起来。 母亲吃了两口就不吃了，我知道她是担心米卖不出去，心里着急。 母亲叹了口气：“还不知道卖得掉卖不掉呢。” 我趁机说：“不然就便宜点卖好了。” 母亲说：“我心里有数。” 08下午人更少了，日头又毒，谁愿意在场上晒着呢。 看看母亲，衣服都粘在背上了，黝黑的脸上也透出晒红的印迹来。 “妈，我替你看着，你去溪里泡泡去。” 母亲还是摇头：“不行，我有风湿，不能在凉水里泡。你怕热，去那边树底下躲躲好了。” “不用，我不怕晒。” “那你去买根冰棍吃好了。” 母亲说着，从兜里掏出两毛钱零钱来。 我最喜欢吃冰棍了，尤其是那种叫“葡萄冰”的最好吃，也不贵，两毛钱一根。 但我今天突然不想吃了：“妈，我不吃，喝水就行。” 最热的时候也过去了，转眼快散场了。 卖杂货的小贩开始降价甩卖，卖菜，卖西瓜的也都吆喝着：“散场了，便宜卖了！” 我四处看看，场上已经没有几个卖米的了，大部分人已经卖完回去了。 09母亲也着急起来，一着急，汗就出得越多了。 终于有个米贩子过来了：“这米卖不卖？一块零五，不讲价！” 母亲说：“你看我这米，多好！上场还卖一块一呢……” 不等母亲说完，那人就不耐烦地说：“行情不同了！想卖一块一，你 就等着往回担吧！” 奇怪的是，母亲没有生气，反而堆着笑说：“那，一块零八，你要不要？” 那人从鼻子里哼了一声，说：“你这个价钱，不是开场的时候也难得卖出去，现在都散场了，谁买？做梦吧！” 母亲的脸一下子白了，动着嘴唇，但什么也没说。 一旁的我忍不住插嘴了：“不买就不买，谁稀罕？不买你就别站在这里挡道！” “哟，大妹子，你别这么大火气。” 那人冷笑着说，“留着点气力等会把米担回去吧！” 等那人走了，我忍不住埋怨母亲：“开场的时候人家出一块零八你不卖，这会好了，人家还不愿意买了！” 母亲似乎有些惭愧，但并不肯认错：“本来嘛，一分钱一分货，米是好米，哪能贱卖了？出门的时候你爹不还叮嘱叫卖个好价钱？” “你还说爹呢！他病在家里，指着这米换钱买药治病！人要紧还是钱要紧？” 母亲似乎没有话说了，等了一会儿，低声说：“一会儿人家出一块零五也卖了吧。” 可是再没有人来买米了，米贩子把买来的米装上车，开走了。 10散场了，我和母亲晒了一天，一颗米也没卖出去。 “妈，走吧，回去吧，别愣在那儿了。” 我收拾好毛巾、水壶、饭盒，催促道。 母亲迟疑着，终于起了身。 “妈，我来挑重的。” “你学生妹子，肩膀嫩……” 不等母亲说完，我已经把那担重的挑起来了。 母亲也没有再说什么，挑起那担轻的跟在我后面，踏上了回家的路。 肩上的担子好沉，我只觉得压着一座山似的。 突然脚下一滑，我差点摔倒。 我赶紧把剩下的力气都用到腿上，好容易站稳了，但肩上的担子还是倾斜了一下，洒了好多米出来。 “啊，怎么搞的？”母亲也放下担子走过来，嘴里说，“我叫你不要挑这么重的，你偏不听，这不是洒了。多可惜！真是败家精！” 败家精是母亲的口头禅，我和弟弟干了什么坏事她总是这么数落我们。 但今天我觉得格外委屈，也不知道为什么。 “你在这等会儿，我回家去拿个簸箕来把地上的米扫进去。浪费了多可惜！拿回去可以喂鸡呢！”母亲也不问我扭伤没有，只顾心疼洒了的米。 11我知道母亲的脾气，她向来是“刀子嘴，豆腐心”的，虽然也心疼我，嘴里却非要骂我几句。 想到这些，我也不委屈了。 “妈，你回去还要来回走个六七里路呢，时候也不早了。”我说。 “那地上的米怎么办？” 我灵机一动，把头上的草帽摘下来：“装在这里面好了。” 母亲笑了：“还是你脑子活，学生妹子，机灵。” 说着，我们便蹲下身子，用手把洒落在地上的米捧起来，放在草帽里，然后把草帽顶朝下放在谷箩里，便挑着米继续往家赶。 回到家里，弟弟已经回来了，母亲便忙着做晚饭，我跟父亲报告卖米的经过。 父亲听了，也没抱怨母亲，只说：“那些米贩子也太黑了，城里都卖一块五呢，把价压这么低！这么挣庄稼人的血汗钱，太没良心了！” 我说：“爹，也没给你买药，怎么办？” 父亲说：“我本来就说不必买药的嘛，过两天就好了，花那个冤枉钱做什么！” 晚上，父亲咳嗽得更厉害了。 12母亲对我说：“琼宝，明天是转步的场，咱们辛苦一点，把米挑到那边场上去卖了，好给你爹买药。” “转步？那多远，十几里路呢！”我想到那漫长的山路，不由有些发怵。 “明天你们少担点米去。每人担50斤就够了。”父亲说。 “那明天可不要再卖不掉担回来哦！”我说，“十几里山路走个来回，还挑着担子，可不是说着玩的！” “不会了不会了。”母亲说，“明天一块零八也好，一块零五也好，总之都卖了！” 母亲的话里有许多辛酸和无奈的意思，我听得出来，但不知道怎么安慰她。 我自己心里也很难过，有点想哭。 我想，别让母亲看见了，要哭就躲到被子里哭去吧。 可我实在太累啦，头刚刚挨到枕头就睡着了，睡得又香又甜。]]></content>
      <categories>
        <category>Books</category>
        <category>Novel</category>
      </categories>
      <tags>
        <tag>飞花</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) TCP的未来和性能]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F26%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-futures-and-performance%2F</url>
    <content type="text"><![CDATA[TCP已经在从1200 b/s的拨号SLIP链路到以太数据链路上运行了许多年。在80年代和90年代初期，以太网是运行TCP/IP最主要的数据链路方式。虽然TCP在比以太网速率高的环境（如T2电话线、FDDI及千兆比网络）中也能够正确运行，但在这些高速率环境下，TCP的某些限制就会暴露出来。 路径MTU发现路径MTU即当前在两个主机之间的路径上任何网络上的最小MTU。路径MTU发现在IP首部中继承并设置“不要分片（DF）”比特，来发现当前路径上的路由器是否需要对正在发送的IP数据报进行分片。如果一个待转发的IP数据报被设置DF比特，而其长度又超过了MTU，那么路由器将返回ICMP不可达的差错。 TCP的路径MTU发现按如下方式进行：在连接建立时，TCP使用输出接口或对端声明的MSS中的最小MTU作为起始的报文段大小。路径MTU发现不允许TCP超过对端声明的MSS。如果对端没有指定一个MSS，则默认为536。 一旦选定了起始的报文段大小，在该连接上的所有被TCP发送的IP数据报都将被设置DF比特。如果某个中间路由器需要对一个设置了DF标志的数据报进行分片，它就丢弃这个数据报，并产生一个ICMP的“不能分片”差错。 如果收到这个ICMP差错，TCP就减少段大小并进行重传。如果路由器产生的是一个较新的该类ICMP差错，则报文段大小被设置为下一跳的MTU减去IP和TCP的首部长度。如果是一个较旧的该类ICMP差错，则必须尝试下一个可能的最小MTU。当由这个ICMP差错引起的重传发生时，拥塞窗口不需要变化，但要启动慢启动。 由于路由可以动态变化，因此在最后一次减少路径MTU的一段时间以后，可以尝试使用一个较大的值（直到等于对端声明的MSS或输出接口MTU的最小值）。RFC 1191推荐这个时间间隔为10分钟。 在对非本地目的地，默认的MSS通常为536字节，路径MTU发现可以避免在通过MTU小于576（这非常罕见）的中间链路时进行分片。对于本地目的主机，也可以避免在中间链路（如以太网）的MTU小于端点网络（如令牌环网）的情况下进行分片。但为了能使路径MTU更加有用和充分利用MTU大于576的广域网，一个实现必须停止使用为非本地目的制定的536的MTU默认值。MSS的一个较好的选择是输出接口的MTU（当然要减去IP和TCP的首部大小）。 大分组还是小分组常规知识告诉我们较大的分组比较好 [Mogul 1993,15.2.8节]，因为发送较少的大分组比发送较多的小分组“花费”要少（假定分组的大小不足以引起分片，否则会引起其他方面的问题）。这些减少的花费与网络（分组首部负荷）、路由器（选路的决定）和主机（协议处理和设备中断）等有关。 长肥管道我们把一个连接的容量表示为: $$capacity(b) = bandwidth(b/s) \times round - triptimes(s)$$ 并称之为带宽时延乘积。也可称它为两端的管道大小。 当这个乘积变得越来越大时，TCP的某些局限性就会暴露出来。 具有大的带宽时延乘积的网络被称为长肥网络（Long Fat Network，即LFN，发音为“elefan(t)s”），而一个运行在LFN上的TCP连接被称为长肥管道。管道可以被水平拉长（一个长的RTT），或被垂直拉高（较高的带宽），或向两个方向拉伸。使用长肥管道会遇到多种问题。 TCP首部中窗口大小为16 bit，从而将窗口限制在65535个字节内。 在一个长肥网络LFN内的分组丢失会使吞吐量急剧减少。 许多TCP实现对每个窗口的RTT仅进行一次测量。它们并不对每个报文段进行RTT测量。在一个长肥网络LFN上需要更好的RTT测量机制。 TCP对每个字节数据使用一个32 bit无符号的序号来进行标识。如果在网络中有一个被延迟一段时间的报文段，它所在的连接已被释放，而一个新的连接在这两个主机之间又建立了，怎样才能防止这样的报文段再次出现呢？IP首部中的TTL为每个IP段规定了一个生存时间的上限—255跳或255秒，看哪一个上限先达到。我们定义了最大的报文段生存时间（MSL）作为一个实现的参数来阻止这种情况的发生。推荐的MSL的值为2分钟（给出一个240秒的2MSL）。在长肥网络LFN上，TCP的序号会碰到一个不同的问题。由于序号空间是有限的，在已经传输了4294 967 296个字节以后序号会被重用。如果一个包含序号N字节数据的报文段在网络上被迟延并在连接仍然有效时又出现，会发生什么情况呢？这仅仅是一个相同序号N在MSL期间是否被重用的问题，也就是说，网络是否足够快以至于在不到一个MSL的时候序号就发生了回绕。在一个以太网上要发送如此多的数据通常需要60分钟左右，因此不会发生这种情况。但是在带宽增加时，这个时间将会减少：一个T3的电话线（45 Mb/s）在12分钟内会发生回绕，FDDI（100 Mb/s）为5分钟，而一个千兆比网络（1000 Mb/s）则为34秒。这时问题不再是带宽时延乘积，而在于带宽本身。 窗口扩大选项窗口扩大选项使TCP的窗口定义从16 bit增加为32 bit。这并不是通过修改TCP首部来实现的，TCP首部仍然使用16 bit，而是通过定义一个选项实现对16 bit的扩大操作(scaling operation)来完成的。于是TCP在内部将实际的窗口大小维持为32 bit的值。 这个选项只能够出现在一个SYN报文段中，因此当连接建立起来后，在每个方向的扩大因子是固定的。为了使用窗口扩大，两端必须在它们的SYN报文段中发送这个选项。主动建立连接的一方在其SYN中发送这个选项，但是被动建立连接的一方只能够在收到带有这个选项的SYN之后才可以发送这个选项。每个方向上的扩大因子可以不同。 如果主动连接的一方发送一个非零的扩大因子，但是没有从另一端收到一个窗口扩大选项，它就将发送和接收的移位记数器置为0。这就允许较新的系统能够与较旧的、不理解新选项的系统进行互操作。 假定我们正在使用窗口扩大选项，发送移位记数为S，而接收移位记数则为R。于是我们从另一端收到的每一个16 bit的通告窗口将被左移R位以获得实际的通告窗口大小。每次当我们向对方发送一个窗口通告的时候，我们将实际的32 bit窗口大小右移S比特，然后用它来替换TCP首部中的16 bit的值。 TCP根据接收缓存的大小自动选择移位计数。这个大小是由系统设置的，但是通常向应用进程提供了修改途径。 时间戳选项时间戳选项使发送方在每个报文段中放置一个时间戳值。接收方在确认中返回这个数值，从而允许发送方为每一个收到的ACK计算RTT（我们必须说“每一个收到的ACK”而不是“每一个报文段”，是因为TCP通常用一个ACK来确认多个报文段）。我们提到过目前许多实现为每一个窗口只计算一个RTT，对于包含8个报文段的窗口而言这是正确的。然而，较大的窗口大小则需要进行更好的RTT计算。 发送方在时间戳选项的第一个字段中防止一个32bit的值，接收方在应答字段中回显这个数值。包含这个选项的TCP首部长度将从正常的20字节增加为32字节。 时间戳是一个单调递增的值。由于接收方只需要回显收到的内容，因此不需要关注时间戳单元是什么。这个选项不需要在两个主机之间进行任何形式的时钟同步。RFC 1323推荐在1毫秒和1秒之间将时间戳的值加1。 在连接建立阶段，对这个选项的规定与前一节讲的窗口扩大选项类似。主动发起连接的一方在它的SYN中指定选项。只有在它从另一方的SYN中收到了这个选项之后，该选项才会在以后的报文段中进行设置。 TCP不需要对每个包含数据的报文段进行确认，许多实现每两个报文段发送一个ACK。如果接收方发送一个确认了两个报文段的ACK，那么哪一个收到的时间戳应当放入回显应答字段中来发回去呢？ 为了减少任一端所维持的状态数量，对于每个连接只保持一个时间戳的数值。选择何时更新这个数值的算法非常简单： TCP跟踪下一个ACK中将要发送的时间戳的值（一个名为tsrecent的变量）以及最后发送的ACK中的确认序号（一个名为lastack的变量）。这个序号就是接收方期望的序号。 当一个包含有字节号lastack的报文段到达时，则该报文段中的时间戳被保存在tsrecent中。 无论何时发送一个时间戳选项，tsrecent就作为时间戳回显应答字段被发送，而序号字段被保存在lastack中。 这个算法能够处理下面两种情况： 如果ACK被接收方迟延，则作为回显值的时间戳值应该对应于最早被确认的报文段。例如，如果两个包含1~1024和1025~2048字节的报文段到达，每一个都带有一个时间戳选项，接收方产生一个ACK 2049来对它们进行确认。此时，ACK中的时间戳应该是包含字节1~1024的第1个报文段中的时间戳。这种处理是正确的，因为发送方在进行重传超时时间的计算时，必须将迟延的ACK也考虑在内。 如果一个收到的报文段虽然在窗口范围内但同时又是失序，这就表明前面的报文段已经丢失。当那个丢失的报文段到达时，它的时间戳（而不是失序的报文段的时间戳）将被回显。例如，假定有3个各包含1024字节数据的报文段，按如下顺序接收：包含字节1~1024的报文段1，包含字节2049~4072的报文段3和包含字节1025~2048的报文段2。返回的ACK应该是带有报文段1的时间戳的ACK 1025（一个正常的所期望的对数据的ACK）、带有报文段1的时间戳的ACK 1025（一个重复的、响应位于窗口内但却是失序的报文段的ACK），然后是带有报文段2的时间戳的ACK 3073（不是报文段3中的较后的时间戳）。这与当报文段丢失时的对RTT估计过高具有同样的效果，但这比估计过低要好些。而且，如果最后的ACK含有来自报文段3的时间戳，它可以包括重复的ACK返回和报文段2被重传所需要的时间，或者可以包括发送方的报文段2的重传超时定时器到期的时间。无论在哪一种情况下，回显报文段3的时间戳将引起发送方的RTT计算出现偏差。 尽管时间戳选项能够更好地计算RTT，它还为发送方提供了一种方法，以避免接收到旧的报文段，并认为它们是现在的数据的一部分。 PAWS：防止回绕的序号32 bit的序号在高速连接中很容易发生回绕。 可以将时间戳视为序列号的一个32 bit的扩展。 PAWS算法不需要在发送方和接收方之间进行任何形式的时间同步。接收方所需要的就是时间戳的值应该单调递增，并且每个窗口至少增加1。 T/TCP：为事务用的TCP扩展TCP提供的是一种虚电路方式的运输服务。一个连接的生存时间包括三个不同的阶段：建立、数据传输和终止。这种虚电路服务非常适合诸如远程注册和文件传输之类的应用。 但是，还有出现其他的应用进程被设计成使用事务服务。一个事务(transaction)就是符合下面这些特征的一个客户请求及其随后的服务器响应。 应该避免连接建立和连接终止的开销，在可能的时候，发送一个请求分组并接收一个应答分组。 等待时间应当减少到等于RTT与SPT之和。其中RTT(Round-Trip Time)为往返时间，而SPT(Server Processing Time)则是服务器处理请求的时间。 服务器应当能够检测出重复的请求，并且当收到一个重复的请求时不重新处理事务（避免重新处理意味着服务器不必再次处理请求，而是返回保存的、与该请求对应的应答）。 一个使用这种类型服务的应用就是域名服务，尽管DNS与服务器重新处理重复的请求无关。 如今一个应用程序设计人员面对的一种选择是使用TCP还是UDP。TCP提供了过多的事务特征，而UDP提供的则不够。通常应用程序使用UDP来构造（避免TCP连接的开销），而许多需要的特征（如动态超时和重传、拥塞避免等）被放置在应用层，一遍又一遍的重新设计和实现。 一个较好的解决方法是提供一个能够提供足够多的事务处理功能的运输层。 大多数的TCP需要使用7个报文段来打开和关闭一个连接。现在增加三个报文段：一个对应于请求，一个对应于应答和对请求的确认，第三个对应于对应答的确认。如果额外的控制比特被追加到报文段上—也就是，第1个报文段带有SYN、客户请求和一个FIN—客户仍然能够看到一个2倍的RTT与SPT之和的最小开销（与数据一起发送一个SYN和FIN是合法的；当前的TCP是否能够正确处理它们是另外一个问题）。 另一个与TCP有关的问题是TIME_WAIT状态和它需要的2MSL的等待时间。正如在习题18.14中看到的，这使两个主机之间的事务率降低到每秒268个。 TCP为处理事务而需要进行的两个改动是避免三次握手和缩短WAIT_TIME状态。T/TCP通过使用加速打开来避免三次握手： 它为打开的连接指定一个32 bit的连接计数CC(Connection Count)，无论主动打开还是被动打开。一个主机的CC值从一个全局计数器中获得，该计数器每次被使用时加1。 在两个使用T/TCP的主机之间的每一个报文段都包括一个新的TCP选项CC。这个选项的长度为6个字节，包含发送方在该连接上的32 bit的CC值。 一个主机维持一个缓存，该缓存保留每个主机上一次的CC值，这些值从来自这个主机的一个可接受的SYN报文段中获得。 当在一个开始的SYN中收到一个CC选项的时候，接收方比较收到的值与为该发送方缓存的CC值。如果接收到的CC比缓存的大，则该SYN是新的，报文段中的任何数据被传递给接收应用进程（服务器）。这个连接被称为半同步。如果接收的CC比缓存的小，或者接收主机上没有对应这个客户的缓存CC，则执行正常的TCP三次握手过程。 为响应一个开始的SYN，带有SYN和ACK的报文段在另一个被称为CCECHO的选项中回显所接收到的CC值。 在一个非SYN报文段中的CC值检测和拒绝来自同一个连接的前一个替身的任何重复的报文段。 这种“加速打开”避免了使用三次握手的要求，除非客户或者服务器已经崩溃并重新启动。这样做的代价是服务器必须记住从每个客户接收的最近的CC值。 基于在两个主机之间测量RTT来动态计算TIME_WAIT的延时，可以缩短TIME_WAIT状态。TIME_WAIT时延被设置为8倍的重传超时值RTO。 通过使用这些特征，最小的事务序列是交换三个报文段： 由一个主动打开引起的客户到服务器：客户的SYN、客户的数据（请求）、客户的FIN以及客户的CC。当被动的服务器TCP接收到这个报文段的时候，如果客户的CC比为这个客户缓存的CC要大，则客户的数据被传送给服务器应用程序进行处理。 服务器到客户：服务器的SYN、服务器的数据（应答）、服务器的FIN、对客户的FIN的ACK、服务器的CC以及客户的CC的CCECHO。由于TCP的确认是累积的，这个对客户的FIN的ACK也对客户的SYN、数据及FIN进行了确认。当客户TCP接收到这个报文段，就将其传送给客户应用进程。 客户到服务器：对服务器的FIN的ACK，它也确认了服务器的SYN、数据和FIN。客户对它的请求的响应时间为RTT与SPT的和。 在参考资料中有许多关于实现这个TCP选项的很好的地方。我们在这里将它们归纳如下： 服务器的SYN和ACK（第2个报文段）必须被迟延，从而允许应答与它一起捎带发送（通常对SYN的ACK是不迟延的）。但它也不能迟延得太多，否则客户将超时并引起重传。 请求可以需要多个报文段，但是服务器必须对它们可能失序达到的情况进行处理（通常当数据在SYN之前到达时，该数据被丢弃并产生一个复位。通过使用T/TCP，这些失序的数据将放入队列中处理）。 API必须使服务器进程用一个单一的操作来发送数据和关闭连接，从而允许第二个报文段中的FIN与应答一起捎带发送（通常应用进程先写应答，从而引起发送一个数据报文段，然后关闭连接，引起发送FIN）。 在收到来自服务器的MSS通告之前，客户在第1个报文段中正在发送数据。为避免限制客户的MSS为536，一个给定主机的MSS应该与它的CC值一起缓存。 客户在没有接收到来自服务器的窗口通告之前也可以向服务器发送数据。T/TCP建议默认的窗口为4096，并且也为服务器缓存拥塞门限。 使用最小3个报文段交换，在每个方向上只能计算一个RTT。加上包括了服务器处理时间的客户测量RTT。这意味着被平滑的RTT及其方差的值也必须为服务器缓存起来。 T/TCP的特征中吸引人的地方在于它对现有协议进行了最小的修改，同时又兼容了现有的实现。它还利用了TCP中现有的工程特征（动态超时和重传、拥塞避免等），而不是迫使应用进程来处理这些问题。 一个可作为替换的事务协议是通用报文事务协议VMTP（Versatile Message Transaction Protocol），该协议在RFC 1045 [Cheriton 1988]中进行了描述。与T/TCP是现有协议的一个小的扩充不同，VMTP是使用IP的一个完整的运输层。VMTP处理差错检测、重传和重复压缩。它还支持多播通信。 TCP的性能下面这些实际限制适用于任何的实际情况[Borman 1991]。 不能比最慢的链路运行得更快。 不能比最慢的机器的内存运行得更快。这假定实现是只使用一遍数据。如果不是这样（也就是说，实现使用一遍数据是将它从用户空间复制到内核中，而使用另一遍数据是计算TCP的检验和），那么将运行得更慢。[Dalton et al.1993]描述了将数据复制数目减少从而使一个标准伯克利源程序的性能得到改进。[Partridge and Pink 1993]将类似的“复制与检验和”的改变与其他性能改进措施一道应用于UDP，从而将UDP的性能提高了约30％。 不能够比由接收方提供的窗口大小除以往返时间所得结果运行得更快（这就是带宽时延乘积公式，使用窗口大小作为带宽时延乘积，并解出带宽）。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 博客中使用 MathJax 数学公式]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F25%2Fmathjax-in-markdown-blog%2F</url>
    <content type="text"><![CDATA[MathJax - Beautiful math in all browsers A JavaScript display engine for mathematics that works in all browsers. No more setup for readers. It just works. MathJax 使用网页中增加配置： 12345678910&lt;script type="text/x-mathjax-config"&gt; MathJax.Hub.Config(&#123; tex2jax: &#123; inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true &#125; &#125;);&lt;/script&gt;&lt;script src='https://cdn.jsdelivr.net/npm/mathjax@2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async&gt;&lt;/script&gt; 接下来就可以在Markdown中使用LaTeX代码来编写公式了。注意要用 $（行内代码）或 $$(代码块）来把数学代码和正常文字区分开。 如，$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$效果为$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$。 但要注意，Markdown 文件会把两个 _ 符号当作下划线或斜体， 比如 这样 ，因此当公式的代码中需要输入 _ 符号时，应该在前面加 \ 进行转义，如：1$$ evidence\_&#123;i&#125;=\sum\_&#123;j&#125;W\_&#123;ij&#125;x\_&#123;j&#125;+b\_&#123;i&#125; $$ 效果为：$$ evidence_{i}=\sum_{j}W_{ij}x_{j}+b_{i} $$ LaTeX 数学公式 识别并转换数学公式的网站 LaTeX Tutorial LaTeX 支持的数学符号表]]></content>
      <categories>
        <category>Technology</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>MathJax</tag>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) TCP的保活定时器]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F25%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-keepalive-timer%2F</url>
    <content type="text"><![CDATA[可以没有任何数据流通过一个空闲的TCP连接。也就是说，如果TCP连接的双方都没有向对方发送数据，则在两个TCP模块之间不交换任何信息。例如，没有可以在其他网络协议中发现的轮询。这意味着我们可以启动一个客户与服务器建立一个连接，然后离去数小时、数天、数个星期或者数月，而连接依然保持。中间路由器可以崩溃和重启，电话线可以被挂断再连通，但是只要两端的主机没有被重启，则连接依然保持建立。 这意味着两个应用进程—客户进程或服务器进程—都没有使用应用级的定时器来检测非活动状态，而这种非活动状态可以导致应用进程中的任何一个终止其活动。 然而，许多时候一个服务器希望知道客户主机是否崩溃并关机或者崩溃又重新启动。许多实现提供的保活定时器可以提供这种能力。 保活并不是TCP规范中的一部分。Host Requirements RFC提供了3个不使用保活定时器的理由：(1)在出现短暂差错的情况下，这可能会使一个非常好的连接释放掉；（2）它们耗费不必要的带宽；（3）在按分组计费的情况下会在互联网上花掉更多的钱。然而，许多实现提供了保活定时器。 保活定时器是一个有争论的功能。许多人认为如果需要，这个功能不应该在TCP中提供，而应该由应用程序来完成。这是应当认真对待的一些问题之一，因为在这个论题上有些人表达出了很大的热情。 在连接两个端系统的网络出现临时故障的时候，保活选项会引起一个实际上很好的连接终止。例如，如果在一个中间路由器崩溃并重新启动时发送保活探查，那么TCP会认为客户的主机已经崩溃，而实际上所发生的并非如此。 保活功能主要是为服务器应用程序提供的。服务器应用程序希望知道客户主机是否崩溃，从而可以代表客户使用资源。许多版本的Rlogin和Telnet服务器默认使用这个选项。 一个说明现在需要使用保活功能的常见例子是当个人计算机用户使用TCP/IP向一个使用Telnet的主机注册时。如果在一天结束时，他们仅仅关闭了电源而没有注销，那么便会留下一个半开放的连接。在图18-16中，我们看到通过一个半开放连接发送数据会导致返回一个复位，但那是在来自正在发送数据的客户端。如果客户已经消失了，使得在服务器上留下一个半开放连接，而服务器又在等待来自客户的数据，则服务器将永远等待下去。保活功能就是试图在服务器端检测到这种半开放的连接。 描述在这个描述中，我们称使用保活选项的一端为服务器，而另一端则为客户。并没有什么使客户不能使用这个选项，但通常都是服务器设置这个功能。如果双方都特别需要了解对方是否已经消失，则双方都可以使用这个选项。 如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段。客户主机必须处于以下4个状态之一。 客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常工作的。服务器在两小时以后将保活定时器复位。如果在两个小时定时器到时间之前有应用程序的通信量通过此连接，则定时器在交换数据后的未来2小时再复位。 客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务器将不能够收到对探查的响应，并在75秒后超时。服务器总共发送10个这样的探查，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。 客户主机崩溃并已经重新启动。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。 客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与状态2之间的区别，它所能发现的就是没有收到探查的响应。 服务器不用关注客户主机被关闭和重新启动的情况（这指的是一个操作员的关闭，而不是主机崩溃）。当系统被操作员关闭时，所有的应用进程也被终止（也就是客户进程），这会使客户的TCP在连接上发出一个FIN。接收到FIN将使服务器的TCP向服务器进程报告文件结束，使服务器可以检测到这个情况。 在第1种情况下，服务器的应用程序没有感觉到保活探查的发生。TCP层负责一切。这个过程对应用程序都是透明的，直至第2、3或4种情况发生。在这三种情况下，服务器应用程序将收到来自它的TCP的差错报告（通常服务器已经向网络发出了读操作请求，然后等待来自客户的数据。如果保活功能返回一个差错，则该差错将作为读操作的返回值返回给服务器）。在第2种情况下，差错是诸如“连接超时”之类的信息，而在第3种情况则为“连接被对方复位”。第4种情况看起来像是连接超时，也可根据是否收到与连接有关的ICMP差错来返回其他的差错。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) TCP的坚持定时器]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F25%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-persist-timer%2F</url>
    <content type="text"><![CDATA[TCP通过让接收方指明希望从发送方接收的数据字节数（即窗口大小）来进行流量控制。如果窗口大小为0会发生什么情况呢？这将有效地阻止发送方传送数据，直到窗口变为非0为止。 TCP必须能够处理打开此窗口的ACK丢失的情况。ACK的传输并不可靠，也就是说，TCP不对ACK报文段进行确认，TCP只确认那些包含有数据的ACK报文段。 如果一个确认丢失了，则双方就有可能因为等待对方而使连接终止：接收方等待接收数据（因为它已经向发送方通告了一个非0的窗口），而发送方在等待允许它继续发送数据的窗口更新。为防止这种死锁情况的发生，发送方使用一个坚持定时器(persist timer)来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为窗口探查(window probe)。 糊涂窗口综合症基于窗口的流量控制方案，如TCP所使用的，会导致一种被称为“糊涂窗口综合症SWS (Silly Window Syndrome）”的状况。如果发生这种情况，则少量的数据将通过连接进行交换，而不是满长度的报文段[Clark 1982]。 该现象可发生在两端中的任何一端：接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通告），而发送方也可以发送少量的数据（而不是等待其他的数据以便发送一个大的报文段）。可以在任何一端采取措施避免出现糊涂窗口综合症的现象。 接收方不通告小窗口。通常的算法是接收方不通告一个比当前窗口大的窗口（可以为0），除非窗口可以增加一个报文段大小（也就是将要接收的MSS）或者可以增加接收方缓存空间的一半，不论实际有多少。 发送方避免出现糊涂窗口综合症的措施是只有以下条件之一满足时才发送数据：(a)可以发送一个满长度的报文段；(b)可以发送至少是接收方通告窗口大小一半的报文段；(c)可以发送任何数据并且不希望接收ACK（也就是说，我们没有还未被确认的数据）或者该连接上不能使用Nagle算法。 条件(b)主要对付那些总是通告小窗口（也许比1个报文段还小）的主机，条件(c)使我们在有尚未被确认的数据（正在等待被确认）以及在不能使用Nagle算法的情况下，避免发送小的报文段。如果应用进程在进行小数据的写操作（例如比该报文段还小），条件(c)可以避免出现糊涂窗口综合症。 这三个条件也可以让我们回答这样一个问题：在有尚未被确认数据的情况下，如果Nagle算法阻止我们发送小的报文段，那么多小才算是小呢？从条件(a)中可以看出所谓“小”就是指字节数小于报文段的大小。条件(b)仅用来对付较老的、原始的主机。 步骤2中的条件(b)要求发送方始终监视另一方通告的最大窗口大小，这是一种发送方猜测对方接收缓存大小的企图。虽然在连接建立时接收缓存的大小可能会减小，但在实际中这种情况很少见。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) TCP的超时与重传]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F25%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-timeout-and-retransmission%2F</url>
    <content type="text"><![CDATA[TCP提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能会丢失。TCP通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据。对任何实现而言，关键之处就在于超时和重传的策略，即怎样决定超时间隔和如何确定重传的频率。 对每个连接，TCP管理4个不同的定时器。 重传定时器使用于当希望收到另一端的确认。 坚持(persist)定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。 保活(keepalive)定时器可检测到一个空闲连接的另一端何时崩溃或重启。 2MSL定时器测量一个连接处于TIME_WAIT状态的时间。 往返时间测量TCP超时与重传中最重要的部分就是对一个给定连接的往返时间（RTT）的测量。由于路由器和网络流量均会变化，因此我们认为这个时间可能经常会发生变化，TCP应该跟踪这些变化并相应地改变其超时时间。 首先TCP必须测量在发送一个带有特别序号的字节和接收到包含该字节的确认之间的RTT。 最初的TCP规范使TCP使用低通过滤器来更新一个被平滑的RTT估计器（记为R）。 $$R \leftarrow \alpha R+(1-\alpha)M$$ 这里的α是一个推荐值为0.9的平滑因子。每次进行新测量的时候，这个被平滑的RTT将得到更新。每个新估计的90％来自前一个估计，而10%则取自新的测量。 该算法在给定这个随RTT的变化而变化的平滑因子的条件下，RFC 793推荐的重传超时时间RTO（Retransmission TimeOut）的值应该设置为: $$RTO = R\beta$$ 这里的β是一个推荐值为2的时延离散因子。 [Jacobson 1988]详细分析了在RTT变化范围很大时，使用这个方法无法跟上这种变化，从而引起不必要的重传。正如Jacobson记述的那样，当网络已经处于饱和状态时，不必要的重传会增加网络的负载，对网络而言这就像在火上浇油一样。 除了被平滑的RTT估计器，所需要做的还有跟踪RTT的方差。在往返时间变化起伏很大时，基于均值和方差来计算RTO，将比作为均值的常数倍数来计算RTO能提供更好的响应。 正如Jacobson所描述的，均值偏差是对标准偏差的一种好的逼近，但却更容易进行计算（计算标准偏差需要一个平方根）。这就引出了下面用于每个RTT测量M的公式。 $$Err = M - A$$$$A \leftarrow A + gErr$$$$D \leftarrow D + h(\mid Err\mid - D)$$$$RTO = A + 4D$$ 这里的A是被平滑的RTT（均值的估计器）而D则是被平滑的均值偏差。Err是刚得到的测量结果与当前的RTT估计器之差。A和D均被用于计算下一个重传时间（RTO）。增量g起平均作用，取为1/8（0.125）。偏差的增益是h，取值为0.25。当RTT变化时，较大的偏差增益将使RTO快速上升。 [Jacobson 1988]指明在计算RTO时使用2D，但经过后来更深入的研究，[Jacobson1990c]将该值改为4D，也就是在BSD Net/1的实现中使用的那样。 Jacobson指明了一种使用整数运算来计算这些公式的方法，并被许多实现所采用（这也就是g，h和倍数4均是2的乘方的一个原因，这样一来计算均可只通过移位操作而不需要乘、除运算来完成）。 将Jacobson与最初的方法比较，我们发现被平滑的均值计算公式是类似的（α是1减去增益g），而增益可使用不同的值。而且Jacobson计算RTO的公式依赖于被平滑的RTT和被平滑的均值偏差，而最初的方法则使用了被平滑的RTT的一个倍数。 Karn算法 在一个分组重传时会产生这样一个问题：假定一个分组被发送。当超时发生时，分组以更长的RTO进行重传，然后收到一个确认。那么这个ACK是针对第一个分组的还是针对第二个分组呢？这就是所谓的重传多义性问题。 [Karn and Partridge 1987]规定，当一个超时和重传发生时，在重传数据的确认最后到达之前，不能更新RTT估计器，因为我们并不知道ACK对应哪次传输（也许第一次传输被延迟而并没有被丢弃，也有可能第一次传输的ACK被延迟）。 并且，由于数据被重传，RTO已经得到了一个指数退避，我们在下一次传输时使用这个退避后的RTO。对一个没有被重传的报文段而言，除非收到了一个确认，否则不要计算新的RTO。 拥塞避免算法慢启动算法是在一个连接上发起数据流的方法，但有时我们会达到中间路由器的极限，此时分组将被丢弃。拥塞避免算法是一种处理丢失分组的方法。 该算法假定由于分组受到损坏引起的丢失是非常少的（远小于1%），因此分组丢失就意味着在源主机和目的主机之间的某处网络上发生了拥塞。有两种分组丢失的指示：发生超时和接收到重复的确认。 拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来作到这一点。在实际中这两个算法通常在一起实现。 拥塞避免算法和慢启动算法需要对每个连接维持两个变量：一个拥塞窗口cwnd和一个慢启动门限ssthresh。这样得到的算法的工作过程如下： 对一个给定的连接，初始化cwnd为1个报文段，ssthresh为65535个字节。 TCP输出例程的输出不能超过cwnd和接收方通告窗口的大小。拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估计，而后者则与接收方在该连接上的可用缓存大小有关。 当拥塞发生时（超时或收到重复确认），ssthresh被设置为当前窗口大小的一半（cwnd和接收方通告窗口大小的最小值，但最少为2个报文段）。此外，如果是超时引起了拥塞，则cwnd被设置为1个报文段（这就是慢启动）。 当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于我们是否正在进行慢启动或拥塞避免。如果cwnd小于或等于ssthresh，则正在进行慢启动，否则正在进行拥塞避免。慢启动一直持续到我们回到当拥塞发生时所处位置的半时候才停止（因为我们记录了在步骤2中给我们制造麻烦的窗口大小的一半），然后转为执行拥塞避免。 慢启动算法初始设置cwnd为1个报文段，此后每收到一个确认就加1。 拥塞避免算法要求每次收到一个确认时将cwnd增加1/cwnd。与慢启动的指数增加比起来，这是一种加性增长(additive increase)。我们希望在一个往返时间内最多为cwnd增加1个报文段（不管在这个RTT中收到了多少个ACK），然而慢启动将根据这个往返时间中所收到的确认的个数增加cwnd。 快速重传与快速恢复算法拥塞避免算法的修改建议1990年提出[Jacobson 1990b]。 在介绍修改之前，我们认识到在收到一个失序的报文段时，TCP立即需要产生一个ACK（一个重复的ACK）。这个重复的ACK不应该被迟延。该重复的ACK的在于让对方知道收到一个失序的报文段，并告诉对方自己希望收到的序号。 由于我们不知道一个重复的ACK是由一个丢失的报文段引起的，还是由于仅仅出现了几个报文段的重新排序，因此我们等待少量重复的ACK到来。假如这只是一些报文段的重新排序，则在重新排序的报文段被处理并产生一个新的ACK之前，只可能产生1~2个重复的ACK。如果一连串收到3个或3个以上的重复ACK，就非常可能是一个报文段丢失了。于是我们就重传丢失的数据报文段，而无需等待超时定时器溢出。这就是快速重传算法。接下来执行的不是慢启动算法而是拥塞避免算法。这就是快速恢复算法。 这个算法通常按如下过程进行实现： 当收到第3个重复的ACK时，将ssthresh设置为当前拥塞窗口cwnd的一半。重传丢失的报文段。设置cwnd为ssthresh加上3倍的报文段大小。 每次收到另一个重复的ACK时，cwnd增加1个报文段大小并发送1个分组（如果新的cwnd允许发送）。 当下一个确认新数据的ACK到达时，设置cwnd为ssthresh（在第1步中设置的值）。这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认。另外，这个ACK也应该是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半。 ICMP的差错TCP能够遇到的最常见的ICMP差错就是源站抑制、主机不可达和网络不可达。 当前基于伯克利的实现对这些错误的处理是： 一个接收到的源站抑制引起拥塞窗口cwnd被置为1个报文段大小来发起慢启动，但是慢启动门限ssthresh没有变化，所以窗口将打开直至它或者开放了所有的通路（受窗口大小和往返时间的限制）或者发生了拥塞。 一个接收到的主机不可达或网络不可达实际上都被忽略，因为这两个差错都被认为是短暂现象。这有可能是由于中间路由器被关闭而导致选路协议要花费数分钟才能稳定到另一个替换路由。在这个过程中就可能发生这两个ICMP差错中的一个，但是连接并不必被关闭。相反，TCP试图发送引起该差错的数据，尽管最终有可能会超时。当前基于伯克利的实现记录发生的ICMP差错，如果连接超时，ICMP差错被转换为一个更合适的的差错码而不是“连接超时”。 重新分组当TCP超时并重传时，它不一定要重传同样的报文段。相反，TCP允许进行重新分组而发送一个较大的报文段，这将有助于提高性能（当然，这个较大的报文段不能够超过接收方声明的MSS）。在协议中这是允许的，因为TCP是使用字节序号而不是报文段序号来进行识别它所要发送的数据和进行确认。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stylus 自定义网页字体]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F23%2Fstylus-set-web-font%2F</url>
    <content type="text"><![CDATA[使用 Stylus 可以直接使用 userstyles 网站 提供的模板，很多下载后几乎不用设定即可使用，前提是现在电脑上安装相应的字体。 这里推荐一款 ForceMyFont 的模板，可以设定的选项非常丰富，前提也是需要在电脑上安装你选择的字体。 你也可以自定义字体CSS的样式，在 Chrome 浏览器中，这里使用 Stylus 插件，编写新的样式，代码如下：12*&#123;font-weight:500!important;&#125;*&#123;font-family: Arial, "思源宋体"!important;&#125; 第一行设定字重，第二行设定英文字体和中文字体。如果要添加字体阴影，可以添加以下代码：1*&#123;text-shadow:0.01em 0.01em 0.01em #999999 !important;&#125; 其中的数值依次代表阴影的 X 轴偏移、Y 轴偏移、阴影大小，以及字体颜色。]]></content>
      <categories>
        <category>Technology</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Stylish</tag>
        <tag>Stylus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) TCP的成块数据流]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F21%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-bulk-data-flow%2F</url>
    <content type="text"><![CDATA[TFTP使用了停止等待协议，数据发送方在发送下一个数据块之前需要等待接收对已发送数据的确认。TCP使用了被称为滑动窗口协议的另一种形式的流量控制方法。该协议允许发送方在停止并等待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。 滑动窗口接收方通告的窗口称为提出的窗口（offered window），发送方计算它的可用窗口，该窗口表明多少数据可以立即被发送。 当接收方确认数据后，这个滑动窗口不时地向右移动。窗口两个边沿的相对运动增加或减少了窗口的大小。我们使用三个术语来描述窗口左右边沿的运动： 称窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时。 当窗口右边沿向右移动时将允许发送更多的数据，我们称之为窗口张开。这种现象发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时。 当右边沿向左移动时，我们称之为窗口收缩。Host Requirements RFC强烈建议不要使用这种方式。但TCP必须能够在某一端产生这种情况时进行处理。 因为窗口的左边沿受另一端发送的确认序号的控制，因此不可能向左边移动。如果接收到一个指示窗口左边沿向左移动的ACK，则它被认为是一个重复ACK，将被丢弃。 如果左边沿到达右边沿，则称其为一个零窗口，此时发送方不能够发送任何数据。 滑动窗口的特点： 发送方不必发送一个全窗口大小的数据。 来自接收方的一个报文段确认数据并把窗口向右边滑动。这是因为窗口的大小是相对于确认序号的。 窗口的大小可以减小，但是窗口的右边沿却不能够向左移动。 接收方在发送一个ACK前不必等待窗口被填满。 窗口大小由接收方提供的窗口的大小通常可以由接收进程控制，这将影响TCP的性能。 [Mogul 1993]显示了在改变发送和接收缓存大小（在单向数据流的应用中，如文件传输，只需改变发送方的发送缓存和接收方的接收缓存大小）的情况下，位于以太网上的两个工作站之间进行文件传输时的一些结果。它表明对以太网而言，默认的4096字节并不是最理想的大小，将两个缓存增加到16384个字节可以增加约40%左右的吞吐量。在[Papadopoulos和Parulkar 1993]中也有相似的结果。 PUSH标志发送方使用该标志通知接收方将所收到的数据全部提交给接收进程。这里的数据包括与PUSH一起传送的数据以及接收方TCP已经为接收进程收到的其他数据。 在最初的TCP规范中，一般假定编程接口允许发送进程告诉它的TCP何时设置PUSH标志。例如，在一个交互程序中，当客户发送一个命令给服务器时，它设置PUSH标志并停下来等待服务器的响应（在习题19.1中我们假定当发送12字节的请求时客户设置PUSH标志）。通过允许客户应用程序通知其TCP设置PUSH标志，客户进程通知TCP在向服务器发送一个报文段时不要因等待额外数据而使已提交数据在缓存中滞留。类似地，当服务器的TCP接收到一个设置了PUSH标志的报文段时，它需要立即将这些数据递交给服务器进程而不能等待判断是否还会有额外的数据到达。 然而，目前大多数的API没有向应用程序提供通知其TCP设置PUSH标志的方法。的确，许多实现程序认为PUSH标志已经过时，一个好的TCP实现能够自行决定何时设置这个标志。 如果待发送数据将清空发送缓存，则大多数的源于伯克利的实现能够自动设置PUSH标志。这意味着我们能够观察到每个应用程序写的数据均被设置了PUSH标志，因为数据在写的时候就立即被发送。 代码中的注释表明该算法对那些只有在缓存被填满或收到一个PUSH标志时才向应用程序提交数据的TCP实现有效。使用插口API通知TCP设置正在接收数据的PUSH标志或得到该数据是否被设置PUSH标志的信息是不可能的。 由于源于伯克利的实现一般从不将接收到的数据推迟交付给应用程序，因此它们忽略所接收的PUSH标志。 慢启动发送方一开始便向网络发送多个报文段，直至达到接收方通告的窗口大小为止。当发送方和接收方处于同一个局域网时，这种方式是可以的。但是如果在发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题。一些中间路由器必须缓存分组，并有可能耗尽存储器的空间。[Jacobson 1988]证明了这种连接方式是如何严重降低了TCP连接的吞吐量的。 现在，TCP需要支持一种被称为“慢启动(slow start)”的算法。该算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。 慢启动为发送方的TCP增加了另一个窗口：拥塞窗口(congestion window)，记为cwnd。当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小）。每收到一个ACK，拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加）。发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。 发送方开始时发送一个报文段，然后等待ACK。当收到该ACK时，拥塞窗口从1增加为2，即可以发送两个报文段。当收到这两个报文段的ACK时，拥塞窗口就增加为4。这是一种指数增加的关系。 在某些点上可能达到了互联网的容量，于是中间路由器开始丢弃分组。这就通知发送方它的拥塞窗口开得过大。 紧急方式TCP提供了“紧急方式(urgent mode)”，它使一端可以告诉另一端有些具有某种方式的“紧急数据”已经放置在普通的数据流中。另一端被通知这个紧急数据已被放置在普通数据流中，由接收方决定如何处理。 可以通过设置TCP首部中的两个字段来发出这种从一端到另一端的紧急数据已经被放置在数据流中的通知。URG比特被置1，并且一个16bit的紧急指针被置为一个正的偏移量，该偏移量必须与TCP首部中的序号字段相加，以便得出紧急数据的最后一个字节的序号。 仍有许多关于紧急指针是指向紧急数据的最后一个字节还是指向紧急数据最后一个字节的下一个字节的争论。最初的TCP规范给出了两种解释，但Host RequirementsRFC确定指向最后一个字节是正确的。然而，问题在于大多数的实现（包括源自伯克利的实现）继续使用错误的解释。所有符合Host Requirements RFC的实现都是可兼容的，但很有可能无法与其他大多数主机正确通信。 TCP必须通知接收进程，何时已接收到一个紧急数据指针以及何时某个紧急数据指针还不在此连接上，或者紧急指针是否在数据流中向前移动。接着接收进程可以读取数据流，并必须能够被告知何时碰到了紧急数据指针。只要从接收方当前读取位置到紧急数据指针之间有数据存在，就认为应用程序处于“紧急方式”。在紧急指针通过之后，应用程序便转回到正常方式。 TCP本身对紧急数据知之甚少。没有办法指明紧急数据从数据流的何处开始。TCP通过连接传送的唯一信息就是紧急方式已经开始（TCP首部中的URG比特）和指向紧急数据最后一个字节的指针。其他的事情留给应用程序去处理。 不幸的是，许多实现不正确地称TCP的紧急方式为带外数据(out-of-band data)。如果一个应用程序确实需要一个独立的带外信道，第二个TCP连接是达到这个目的的最简单的方法（许多运输层确实提供许多人认为的那种真正的带外数据：使用同一个连接的独立的逻辑数据通道作为正常的数据通道。这是TCP所没有提供的）。 TCP的紧急方式与带外数据之间的混淆，也是因为主要的编程接口（插口API）将TCP的紧急方式映射为称为带外数据的插口。 紧急方式有什么作用呢？两个最常见的例子是Telnet和Rlogin。 Telnet和Rlogin从服务器到客户使用紧急方式是因为在这个方向上的数据流很可能要被客户的TCP停止（也即，它通告了一个大小为0的窗口）。但是如果服务器进程进入了紧急方式，尽管它不能够发送任何数据，服务器TCP也会立即发送紧急指针和URG标志。当客户TCP接收到这个通知时就会通知客户进程，于是客户可以从服务器读取其输入、打开窗口并使数据流动。 如果在接收方处理第一个紧急指针之前，发送方多次进入紧急方式会发生什么情况呢？在数据流中的紧急指针会向前移动，而其在接收方的前一个位置将丢失。接收方只有一个紧急指针，每当对方有新的值到达时它将被覆盖。这意味着如果发送方进入紧急方式时所写的内容对接收方非常重要，那么这些字节数据必须被发送方用某种方式特别标记。我们将看到Telnet通过在数据流中加入一个值为255的字节作为前缀来标记它所有的命令。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) TCP的交互数据流]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F21%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-interactive-data-flow%2F</url>
    <content type="text"><![CDATA[一些有关TCP通信量的研究如[Caceres et al. 1991]发现，如果按照分组数量计算，约有一半的TCP报文段包含成块数据（如FTP、电子邮件和Usenet新闻），另一半则包含交互数据（如Telnet和Rlogin）。如果按字节计算，则成块数据与交互数据的比例约为90%和10%。这是因为成块数据的报文段基本上都是满长度（full-sized）的（通常为512字节的用户数据），而交互数据则小得多（上述研究表明Telnet和Rlogin分组中通常约90%左右的用户数据小于10个字节）。 很明显，TCP需要同时处理这两类数据，但使用的处理算法则有所不同。 交互式输入首先来观察在一个Rlogin连接上键入一个交互命令时所产生的数据流。许多TCP/IP的初学者很吃惊地发现通常每一个交互按键都会产生一个数据分组，也就是说，每次从客户传到服务器的是一个字节的按键（而不是每次一行）。而且，Rlogin需要远程系统（服务器）回显我们（客户）键入的字符。这样就会产生4个报文段：（1）来自客户的交互按键；（2）来自服务器的按键确认；（3）来自服务器的按键回显；（4）来自客户的按键回显确认。 然而，我们一般可以将报文段2和3进行合并—按键确认与按键回显一起发送。 经受时延的确认通常TCP在接收到数据时并不立即发送ACK；相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送（有时称这种现象为数据捎带ACK）。绝大多数实现采用的时延为200 ms，也就是说，TCP将以最大200 ms的时延等待是否有数据一起发送。 Nagle算法该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去。该算法的优越之处在于它是自适应的：确认到达得越快，数据也就发送得越快。而在希望减少微小分组数目的低速广域网上，则会发送更少的分组。 关闭Nagle算法有时我们也需要关闭Nagle算法。一个典型的例子是X窗口系统服务器：小消息（鼠标移动）必须无时延地发送，以便为进行某种操作的交互用户提供实时的反馈。 插口API用户可以使用TCP_NODELAY选项来关闭Nagle算法。Host Requirements RFC声明TCP必须实现Nagle算法，但必须为应用提供一种方法来关闭该算法在某个连接上执行。 小结交互数据总是以小于最大报文段长度的分组发送。在Rlogin中通常只有一个字节从客户发送到服务器。Telnet允许一次发送一行输入数据，但是目前大多数实现仍然发送一个字节。 对于这些小的报文段，接收方使用经受时延的确认方法来判断确认是否可被推迟发送，以便与回送数据一起发送。这样通常会减少报文段的数目，尤其是对于需要回显用户输入字符的Rlogin会话。 在较慢的广域网环境中，通常使用Nagle算法来减少这些小报文段的数目。这个算法限制发送者任何时候只能有一个发送的小报文段未被确认。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[emacs 字体配置]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F18%2Femacs-font-configuration%2F</url>
    <content type="text"><![CDATA[定义设置中文和英文字体的函数，达到等宽效果：12345678910111213141516171819(defun set-font() (interactive) ;; Setting English Font (when (member &quot;DejaVu Sans Mono&quot; (font-family-list)) (set-face-attribute &apos;default nil :font (format &quot;%s:pixelsize=%d&quot; &quot;DejaVu Sans Mono&quot; 14)) ) ;; Setting Chinese font (dolist (charset &apos;(kana han symbol cjk-misc bopomofo)) (set-fontset-font (frame-parameter nil &apos;font) charset (font-spec :family &quot;Microsoft Yahei&quot; :size 16)) ) ;; Fix chinese font width and rescale (setq face-font-rescale-alist &apos;((&quot;STHeiti&quot; . 1.2) (&quot;STFangsong&quot; . 1.2) (&quot;Microsoft Yahei&quot; . 1.2) (&quot;WenQuanYi Micro Hei Mono&quot; . 1.2))) ) 调用 set-font 函数可使设置生效：12345678(add-to-list &apos;after-make-frame-functions (lambda (new-frame) (select-frame new-frame) (if window-system (set-font))))(if window-system (set-font)) 分别为中文和英文字体定义一个列表，系统中存在这个字体就设定：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051(defun dotemacs-font-existsp (font) (if (null (x-list-fonts font)) nil t));; or;; (defun dotemacs-font-existsp (font);; &quot;Detect if a font exists&quot;;; (if (find-font (font-spec :family font));; t;; nil))(defun dotemacs-make-font-string (font-name font-size) (if (and (stringp font-size) (equal &quot;:&quot; (string (elt font-size 0)))) (format &quot;%s%s&quot; font-name font-size) (format &quot;%s %s&quot; font-name font-size)))(defun dotemacs-set-font (english-fonts english-font-size chinese-fonts &amp;optional chinese-font-size) &quot;english-font-size could be set to \&quot;:pixelsize=18\&quot; or a integer. If set/leave chinese-font-size to nil, it will follow english-font-size&quot; (require &apos;cl) ; for find if (let ((en-font (dotemacs-make-font-string (find-if #&apos;dotemacs-font-existsp english-fonts) english-font-size)) (zh-font (font-spec :family (find-if #&apos;dotemacs-font-existsp chinese-fonts) :size chinese-font-size))) ;; Set English font ;; (message &quot;Set English Font to %s&quot; en-font) (set-face-attribute &apos;default nil :font en-font) ;; Set Chinese font ;; (message &quot;Set Chinese Font to %s&quot; zh-font) (dolist (charset &apos;(kana han symbol cjk-misc bopomofo)) (set-fontset-font (frame-parameter nil &apos;font) charset zh-font))) ;; Fix chinese font width and rescale (setq face-font-rescale-alist &apos;((&quot;STHeiti&quot; . 1.2) (&quot;STFangsong&quot; . 1.2) (&quot;Microsoft Yahei&quot; . 1.2) (&quot;WenQuanYi Micro Hei Mono&quot; . 1.2))))(defun set-font() (interactive) (dotemacs-set-font &apos;(&quot;DejaVu Sans Mono&quot; &quot;Monaco&quot; &quot;Source Code Pro&quot; &quot;Consolas&quot;) &quot;:pixelsize=14&quot; &apos;(&quot;Microsoft Yahei&quot; &quot;文泉驿等宽微米黑&quot; &quot;黑体&quot; &quot;新宋体&quot; &quot;宋体&quot;) 16) ) 为不同的操作系统设定不同的字体：1234567891011121314(defun set-font() (interactive) (setq fonts (cond ((eq system-type &apos;darwin) &apos;(&quot;Monaco&quot; &quot;STHeiti&quot;)) ((eq system-type &apos;gnu/linux) &apos;(&quot;Menlo&quot; &quot;WenQuanYi Zen Hei&quot;)) ((eq system-type &apos;windows-nt) &apos;(&quot;DejaVu Sans Mono&quot; &quot;Microsoft Yahei&quot;)))) (set-face-attribute &apos;default nil :font (format &quot;%s:pixelsize=%d&quot; (car fonts) 14)) (dolist (charset &apos;(kana han symbol cjk-misc bopomofo)) (set-fontset-font (frame-parameter nil &apos;font) charset (font-spec :family (car (cdr fonts)) :size 16))) ;; Fix chinese font width and rescale (setq face-font-rescale-alist &apos;((&quot;STHeiti&quot; . 1.2) (&quot;STFangsong&quot; . 1.2) (&quot;Microsoft Yahei&quot; . 1.2) (&quot;WenQuanYi Micro Hei Mono&quot; . 1.2))) )]]></content>
      <categories>
        <category>Software</category>
        <category>emacs</category>
      </categories>
      <tags>
        <tag>emacs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) TCP连接的建立与终止]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F16%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-tcp-establishment-termination%2F</url>
    <content type="text"><![CDATA[TCP是一个面向连接的协议。无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。这种两端间连接的建立与无连接协议如UDP不同。一端使用UDP向另一端发送数据报时，无需任何预先的握手。 两个进程在使用TCP交换数据之前，它们之间必须建立一条连接。完成后，要关闭这个连接。 一个TCP连接由一个4元组唯一确定：本地IP地址、本地端口号、远端IP地址和远端端口号。 TCP 连接的建立 客户端发送请求连接(SYN=1,ACK=0)，TCP规定SYN=1时不能携带数据，但要消耗掉一个序号(seq=x)。 服务端回复确认(SYN=1,ACK=1)，同样要消耗掉一个序号(seq=y)，确认号ack=x+1。 客户端再进行一次确认(ACK=1)，序号seq=x+1，确认号ack=y+1。TCP的标准规定，ACK报文段可以携带数据，但如果不携带数据则不消耗序号，因此，如果不携带数据，则下一个报文段的序号仍为seq=x+1。这时，TCP连接已经建立，客户端进入ESTABLISHED（已建立连接）状态。 这个过程即为TCP三次握手。 TCP 连接的终止 数据传输结束后，通信的双方都可以释放连接，并停止发送数据。 A主动关闭TCP连接，发送连接释放报文段中FIN=1，序号为seq=u，该序号等于前面已经传送数据的最后一个数据的序号加1。此时A进入FIN-WAIT-1(终止等待1状态)状态，等待B的确认，TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 B收到连接释放报文段后立即发出确认(ACK=1)，序号seq=v，确认号ack=u+1。然后B进入CLOSE-WAIT(关闭等待状态)状态，此时TCP服务器进程应该通知上层应用进程，A到B这个方向的连接释放了，这是TCP处于半关闭状态，即A没有数据要发了，但B要发数据，A仍需要接收，也就是说从B到A的连接并没有关闭，这个状态可能持续一段时间。 A收到B的确认后，就进入FIN-WAIT-2(终止等待2状态)，等待B发出连接释放报文段，如果B没有要向A发送的数据，其应用进程就通知TCP释放连接。B发出连接释放段，FIN=1，序号seq=w，确认号ack=u+1。此时B进入LAST-ACK(最后确认)状态，等待A的确认。 A收到B的连接释放请求后，发出确认报文。ACK=1，确认号ack=w+1，序号seq=u+1，然后进入TIME-WAIT(时间等待)状态。这是TCP连接还没有释放掉，必须经过时间等待定时器设置的时间2MSL后，A才进入CLOSED状态，MSL叫做最长报文寿命，而B只要收到A的确认，就进入了CLOSED状态。二者都进入CLOSED状态后，连接就完全释放了。 同时打开 正常情况下，传输连接都是由一方主动发起的，但也有可能双方同时主动发起连接，此时就会发生连接碰撞，最终只有一个连接能够建立起来。 当出现同时发出连接请求时，则两端几乎在同时发送一个SYN字段置1的数据段，并进入SYN_SENT状态。当每一端收到SYN数据段时，状态变为SYN_RCVD，同时它们都再发送SYN字段置1，ACK字段置1的数据段，对收到的SYN数据段进行确认。当双方都收到对方的SYN+ACK数据段后，便都进入ESTABLISHED状态。最终建立的是一个TCP连接，而不是两个，这点要特别注意。 同时关闭 与同时打开一样，TCP传输连接关闭也可以由双方同时主动进行（正常情况下都是由一方发送第一个FIN数据段进行主动连接关闭，另一方被动接受连接关闭）。 当两端对应的网络应用层进程同时调用CLOSE原语，发送FIN数据段执行关闭命令时，两端均从ESTABLISHED状态转变为FIN_WAIT_1状态。任意一方收到对端发来的FIN数据段后，其状态均由FIN_WAIT_1转变到CLOSING，并发送最后的ACK，当收到最后的ACK时，状态变化为TIME_WAIT。在等待2MSL后进入到CLOSED状态，最终释放整个TCP传输连接。 2MSL 等待状态TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime）。它是任何报文段被丢弃前在网络内的最长时间。我们知道这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。 RFC 793 [Postel 1981c]指出MSL为2分钟。然而，实现中的常用值是30秒，1分钟，或2分钟。 为什么A需要在TIME_WAIT状态等待2MSL时间？ 为了保证A发送的最后一个ACK报文段能够到达B。该ACK报文段很有可能丢失，因而使处于在LIST—ACK状态的B收不到对已发送的FIN+ACK报文段的确认，B可能会重传这个FIN+ACK报文段，而A就在这2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入CLOSED状态。如果A在TIME—WAIT状态不等待一段时间就直接释放连接，到CLOSED状态，那么久无法收到B重传的FIN+ACK报文段，也就不会再发送一次确认ACK报文段，B就无法正常进入CLOSED状态。 防止已失效的请求连接出现在本连接中。在连接处于2MSL等待时，任何迟到的报文段将被丢弃，因为处于2MSL等待的、由该插口（插口是IP和端口对的意思，socket）定义的连接在这段时间内将不能被再用，这样就可以使下一个新的连接中不会出现这种旧的连接之前延迟的报文段。 客户执行主动关闭并进入TIME_WAIT是正常的。服务器通常执行被动关闭，不会进入TIME_WAIT状态。这暗示如果我们终止一个客户程序，并立即重新启动这个客户程序，则这个新客户程序将不能重用相同的本地端口。这不会带来什么问题，因为客户使用本地端口，而并不关心这个端口号是什么。 然而，对于服务器，情况就有所不同，因为服务器使用熟知端口。如果我们终止一个已经建立连接的服务器程序，并试图立即重新启动这个服务器程序，服务器程序将不能把它的这个熟知端口赋值给它的端点，因为那个端口是处于2MSL连接的一部分。在重新启动服务器程序前，它需要在1~4分钟。 TCP 的状态变迁图]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) TCP：传输控制协议]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F15%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-tcp-transmission-control-protocol%2F</url>
    <content type="text"><![CDATA[尽管TCP和UDP都使用相同的网络层（IP），TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务。 面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。 在一个TCP连接中，仅有两方进行彼此通信。 TCP通过下列方式来提供可靠性： 应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变。由TCP传递给IP的信息单位称为报文段或段（segment）。 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。 TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。 既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。 既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。 TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。 两个应用程序通过TCP连接交换8bit字节构成的字节流。TCP不在字节流中插入记录标识符。我们将这称为字节流服务（byte stream service）。如果一方的应用程序先传10字节，又传20字节，再传50字节，连接的另一方将无法了解发方每次发送了多少字节。收方可以分4次接收这80个字节，每次接收20字节。一端将字节流放到TCP连接上，同样的字节流将出现在TCP连接的另一端。 另外，TCP对字节流的内容不作任何解释。TCP不知道传输的数据字节流是二进制数据，还是ASCII字符、EBCDIC字符或者其他类型数据。对字节流的解释由TCP连接双方的应用层解释。 这种对字节流的处理方式与Unix操作系统对文件的处理方式很相似。Unix的内核对一个应用读或写的内容不作任何解释，而是交给应用程序处理。对Unix的内核来说，它无法区分一个二进制文件与一个文本文件。 TCP 的首部TCP数据被封装在一个IP数据报中，IP首部(20字节) + TCP首部(20字节) + TCP数据。 TCP首部的数据格式。如果不计任选字段，它通常是20个字节。 每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端应用进程。这两个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接。 有时，一个IP地址和一个端口号也称为一个插口（socket）。这个术语出现在最早的TCP规范（RFC793）中，后来它也作为表示伯克利版的编程接口。插口对（socketpair）(包含客户IP地址、客户端口号、服务器IP地址和服务器端口号的四元组)可唯一确定互联网络中每个TCP连接的双方。 序号用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则TCP用序号对每个字节进行计数。序号是32 bit的无符号数，序号到达$2^{32}－1$后又从0开始。 当建立一个新的连接时，SYN标志变1。序号字段包含由这个主机选择的该连接的初始序号ISN（Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个ISN加1，因为SYN标志消耗了一个序号。 既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加1。只有ACK标志为1时确认序号字段才有效。 发送ACK无需任何代价，因为32 bit的确认序号字段和ACK标志一样，总是TCP首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置，ACK标志也总是被设置为1。 TCP为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。 TCP可以表述为一个没有选择确认或否认的滑动窗口协议。我们说TCP缺少选择确认是因为TCP首部中的确认序号表示发方已成功收到字节，但还不包含确认序号所指的字节。当前还无法对数据流中选定的部分进行确认。例如，如果1～1024字节已经成功收到，下一报文段中包含序号从2049～3072的字节，收端并不能确认这个新的报文段。它所能做的就是发回一个确认序号为1025的ACK。它也无法对一个报文段进行否认。例如，如果收到包含1025～2048字节的报文段，但它的检验和错，TCP接收端所能做的就是发回一个确认序号为1025的ACK。 首部长度给出首部中32 bit字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占4bit，因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节。在TCP首部中有6个标志比特。它们中的多个可同时被设置为1。 标志 说明 URG 紧急指针(urgent pointer)有效 ACK 确认序号有效 PSH 接收方应尽快将这个报文段交给应用层 RST 重建连接 SYN 同步序号用来发起一个连接 FIN 发端完成发送任务 TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16 bit字段，因而窗口大小最大为65535字节。 检验和覆盖了整个的TCP报文段：TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。TCP检验和的计算和UDP检验和的计算相似。 只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。 最常见的可选字段是最长报文大小，又称为MSS(Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。 小结TCP提供了一种可靠的面向连接的字节流运输层服务。 TCP将用户数据打包构成报文段；它发送数据后启动一个定时器；另一端对收到的数据进行确认，对失序的数据重新排序，丢弃重复数据；TCP提供端到端的流量控制，并计算和验证一个强制性的端到端检验和。 许多流行的应用程序如Telnet、Rlogin、FTP和SMTP都使用TCP。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 复杂表格]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F14%2Fmarkdown-complex-table%2F</url>
    <content type="text"><![CDATA[由于Markdown语法本身不包含复杂表格的插入，但是可以使用html语法来实现，一般的Markdown编辑器都是支持html语法的。 复杂表格与简单表格最大的差异有两点：水平单元格的合并和纵向单元格的合并，通过html语法实现这两个操作本质就是：删除多余的空白单元格，然后使用某些单元格的colspan和rowspan属性进行扩展填充。 水平单元格的合并：基于colspan属性，即使一个单元格占多列的空间。 纵向单元格的合并：基于rowspan属性，即使一个单元格占多行的空间。 可以从Word或者Excel中复制表格，通过网站 No-Cruft Excel to HTML Table Converter 转换获得html代码。 合并行123456789101112&lt;table&gt; &lt;tr&gt; &lt;td&gt;列一&lt;/td&gt; &lt;td&gt;列一&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt;合并行&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt;合并行&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 显示效果： 列一 列一 合并行 合并行 合并列12345678910111213&lt;table&gt; &lt;tr&gt; &lt;td&gt;列一&lt;/td&gt; &lt;td&gt;列二&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan="2"&gt;合并列&lt;/td&gt; &lt;td &gt;行二列二&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td &gt;行三列二&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 显示效果： 列一 列二 合并列 行二列二 行三列二 合并行列1234567891011121314151617181920&lt;table&gt; &lt;tr&gt; &lt;td&gt;列一&lt;/td&gt; &lt;td&gt;列二&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt;合并行&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;列一&lt;/td&gt; &lt;td&gt;列二&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan="2"&gt;合并列&lt;/td&gt; &lt;td &gt;行二列二&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td &gt;行三列二&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 显示效果： 列一 列二 合并行 列一 列二 合并列 行二列二 行三列二]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) BOOTP：引导程序协议]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F14%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-bootp%2F</url>
    <content type="text"><![CDATA[一个无盘系统，它在不知道自身IP地址的情况下，在进行系统引导时能够通过RARP来获取它的IP地址。然而使用RARP有两个问题：（1）IP地址是返回的唯一结果；（2）既然RARP使用链路层广播，RARP请求就不会被路由器转发（迫使每个实际网络设置一个RARP服务器）。下面将介绍一种用于无盘系统进行系统引导的替代方法，又称为引导程序协议，或BOOTP。 BOOTP使用UDP，且通常需与TFTP协同工作。 BOOTP 的分组格式BOOTP 请求和应答均被封装在UDP数据报中，IP首部(20字节) - UDP首部(8字节) - BOOTP请求/应答(300字节)。 “操作码”字段为1表示请求，为2表示应答。硬件类型字段为1表示10 Mb/s的以太网，这和ARP请求或应答中同名字段表示的含义相同。类似地，对于以太网，硬件地址长度字段为6字节。 “跳数”字段由客户设置为0，但也能被一个代理服务器设置。 “事务标识”字段是一个由客户设置并由服务器返回的32 bit整数。客户用它对请求和应答进行匹配。对每个请求，客户应该将该字段设置为一个随机数。 客户开始进行引导时，将“秒数”字段设置为一个时间值。服务器能够看到这个时间值，备用服务器在等待时间超过这个时间值后才会响应客户的请求，这意味着主服务器没有启动。 如果该客户已经知道自身的IP地址，它将写入“客户IP地址”字段。否则，它将该字段设置为0。对于后面这种情况，服务器用该客户的IP地址写入“你的IP地址”字段。“服务器IP地址”字段则由服务器填写。如果使用了某个代理服务器，则该代理服务器就填写“网关IP地址”字段。 客户必须设置它的“客户硬件地址”字段。尽管这个值与以太网数据帧头中的值相同，UDP数据报中也设置这个字段，但任何接收这个数据报的用户进程能很容易地获得它（例如一个BOOTP服务器）。一个进程通过查看UDP数据报来确定以太网帧首部中的该字段通常是很困难的（或者说是不可能的）。 “服务器主机名”字段是一个空值终止串，由服务器填写。服务器还将在“引导文件名字段”填入包括用于系统引导的文件名及其所在位置的路径全名。 “特定厂商区域”字段用于对BOOTP进行不同的扩展。 当一个客户使用BOOTP（操作码为1）进行系统引导时，引导请求通常是采用链路层广播，IP首部中的目的IP地址为255.255.255.255（受限的广播）。源IP地址通常是0.0.0.0，因为此时客户还不知道它本身的IP地址。在系统进行自引导时，0.0.0.0是一个有效的IP地址。 端口号 BOOTP有两个熟知端口：BOOTP服务器为67，BOOTP客户为68。这意味着BOOTP客户不会选择未用的临时端口，而只用端口68。选择两个端口而不是仅选择一个端口为BOOTP服务器用的原因是：服务器的应答可以进行广播（但通常是不用广播的）。 如果服务器的应答是通过广播传送的，同时客户又选择未用的临时端口，那么这些广播也能被其他的主机中碰巧使用相同临时端口的应用进程接收到。因此，采用随机端口（即临时端口）对广播来说是一个不好的选择。 如果客户也使用服务器的知名端口（67）作为它的端口，那么网络内的所有服务器会被唤醒来查看每个广播应答（如果所有的服务器都被唤醒，它们将检查操作码，如果是一个应答而不是请求，就不作处理）。因此可以让所有的客户使用与服务器知名端口不同的同一知名端口。 如果多个客户同时进行系统引导，并且服务器广播所有应答，这样每个客户都会收到其他客户的应答。客户可以通过BOOTP首部中的事务标识字段来确认应答是否与请求匹配，或者可以通过检查返回的客户硬件地址加以区分。 BOOTP 服务器的设计BOOTP客户通常固化在无盘系统只读存储器中，因此了解BOOTP服务器的实现将更有意义。 首先，BOOTP服务器将从它的熟知端口（67）读取UDP数据报。这没有特别的地方。它不同于RARP服务器，它必须读取类型字段为“RARP请求”的以太网帧。BOOTP协议通过将客户的硬件地址放入BOOTP分组中，使得服务器很容易获取客户的硬件地址。 这里出现了一个有趣的问题：TFTP服务器如何能将一个响应直接送回BOOTP客户？这个响应是一个UDP数据报，而服务器知道该客户的IP地址（可能通过读取服务器上的配置文件）。但如果这个客户向那个IP地址发送一个UDP数据报（正常情况下会处理UDP的输出），BOOTP服务器的主机就可能向那个IP地址发送一个ARP请求。但这个客户不能响应这个ARP请求，因为它还不知道它自己的IP地址！（这就是在RFC951中被称作“鸡和蛋”的问题。） 有两种解决办法：第一种，通常被Unix服务器采用，是服务器发一个ioctl请求给内核，为该客户在ARP高速缓存中设置一个条目（这就是命令arp-s所做的作工）。服务器能一直这么做直到它知道客户的硬件地址和IP地址。这意味着当服务器发送UDP数据报（即BOOTP应答）时，服务器的ARP将在ARP高速缓存中找到该客户的IP地址。 另一种可选的解决办法是服务器广播这个BOOTP应答而不直接将应答发回该客户。既然通常期望网络广播越少越好，因此这种解决方案应该只在服务器无法在它的ARP高速缓存设置一个条目的情况下使用。通常只有拥有超级用户权限才能在ARP高速缓存设置一个条目，如果没有这种权限就只能广播BOOTP应答。 BOOTP 穿越路由器RARP的一个缺点就是它使用链路层广播，这种广播通常不会由路由器转发。这就需要在每个物理网络内设置一个RARP服务器。如果路由器支持BOOTP协议，那么BOOTP能够由路由器转发（绝大多数路由器厂商的产品都支持这个功能）。 这个功能主要用于无盘路由器，因为如果在磁盘的多用户系统被用作路由器，它就能够自己运行BOOTP服务器。此外，常用的Unix BOOTP服务器支持这种中继模式（relay mode）。但如果在这个物理网络内运行一个BOOTP服务器，通常没有必要将BOOTP请求转发到在另外网络中的另一个服务器。 研究一下当路由器（也称作“BOOTP中继代理”）在服务器的熟知端口（67）接收到BOOTP请求时将会发生什么。当收到一个BOOTP请求时，中继代理将它的IP地址填入收到BOOTP请求中的“网关IP地址字段”，然后将该请求发送到真正的BOOTP服务器（由中继代理填入网关字段的地址是收到的BOOTP请求接口的IP地址）。该代理中继还将跳数字段值加1（这是为防止请求被无限地在网络内转发。RFC 951认为如果跳数值到达3就可以丢弃该请求）。既然发出的请求是一个单播的数据报（与发起的客户的请求是广播的相反），它能按照一定的路由通过其他的路由器到达真正的BOOTP服务器。真正的BOOTP服务器收到这个请求后，产生BOOTP应答，并将它发回中继代理，而不是请求的客户。既然请求网关字段不为零，真正的BOOTP服务器知道这个请求是经过转发的。中继代理收到应答后将它发给请求的客户。 特定厂商信息64字节的“特定厂商区域”含有服务器返回客户的可选信息。 如果有信息要提供，这个区域的前4个字节被设置为IP地址99.130.83.99。这可称作魔术甜饼(magic cookie)，表示该区域内包含信息。 这个区域的其余部分是一个条目表。每个条目的开始是1字节标志字段。其中的两个条目仅有标志字段：标志为0的条目作为填充字节（为使后面的条目有更好的字节边界），标志为255的条目表示结尾条目。第一个结尾条目后剩余的字节都应设置为这个数值（255）。 除了这两个1字节的条目，其他的条目还包含一个单字节的长度字段，后面是相应的信息。 子网掩码条目和时间值条目都是定长条目，因为它们的值总是占4个字节。时间偏移值是从1900年1月1日0时以来的秒数（UTC）。 网关条目是变长条目。长度通常是4的倍数，这个值是一个或多个供客户使用的网关（路由器）的IP地址。返回的第一个必须是首选的网关。 RFC 1533还定义了其他14个条目。其中最重要的可能是DNS名字服务器的IP地址条目，条目的志为6。其他的条目包括打印服务器、时间服务器等的IP地址。详细情况可参考RFC文档。 Host Requirements RFC文档推荐一个系统使用BOOTP来获悉它的子网掩码，而不是采用ICMP。 厂商说明区域的大小被限制为64字节。这对某些应用是个约束。一个新的称为动态主机配置协议DHCP（Dynamic Host Configuration Protocol）已经出现，但它不是替代BOOTP的。DHCP将这个区域的长度扩展到312字节，它在RFC 1541 [Droms 1993] 中定义。 小结BOOTP使用UDP，它为引导无盘系统获得它的IP地址提供了除RARP外的另外一种选择。BOOTP还能返回其他的信息，如路由器的IP地址、客户的子网掩码和名字服务器的IP地址。 既然BOOTP用于系统引导过程，一个无盘系统需要下列协议才能在只读存储器中完成：BOOTP、TFTP、UDP、IP和一个局域网的驱动程序。 BOOTP服务器比RARP服务器更易于实现，因为BOOTP请求和应答是在UDP数据报中，而不是特殊的数据链路层帧。一个路由器还能作为真正BOOTP服务器的代理，向位于不同网络的真正BOOTP服务器转发客户的BOOTP请求。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>ARP</tag>
        <tag>RARP</tag>
        <tag>BOOTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) TFTP：简单文件传送协议]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F14%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-tftp%2F</url>
    <content type="text"><![CDATA[TFTP(Trivial File Transfer Protocol)即简单文件传送协议，最初打算用于引导无盘系统（通常是工作站或X终端）。为了保持简单和短小，TFTP将使用UDP。TFTP的代码（和它所需要的UDP、IP和设备驱动程序）都能适合只读存储器。 协议在开始工作时，TFTP的客户与服务器交换信息，客户发送一个读请求或写请求给服务器。在一个无盘系统进行系统引导的正常情况下，第一个请求是读请求（RRQ）。下图显示了5种TFTP报文格式（操作码为1和2的报文使用相同的格式）。 TFTP报文的头两个字节表示操作码。对于读请求和写请求（WRQ），文件名字段说明客户要读或写的位于服务器上的文件。这个文件字段以0字节作为结束。模式字段是一个ASCII码串netascii或octet（可大小写任意组合），同样以0字节结束。netascii表示数据是以成行的ASCII码字符组成，以两个字节—回车字符后跟换行字符（称为CR/LF）作为行结束符。这两个行结束字符在这种格式和本地主机使用的行定界符之间进行转化。octet则将数据看作8bit一组的字节流而不作任何解释。 每个数据分组包含一个块编号字段，它以后要在确认分组中使用。以读一个文件作为例子，TFTP客户需要发送一个读请求说明要读的文件名和文件模式(mode)。如果这个文件能被这个客户读取，TFTP服务器就返回一个块编号为1的数据分组。TFTP客户又发送一个块编号为1的ACK。TFTP服务器随后发送块编号为2的数据。TFTP客户发回块编号为2的ACK。重复这个过程直到这个文件传送完。除了最后一个数据分组可含有不足512字节的数据，其他每个数据分组均含有512字节的数据。当TFTP客户收到一个不足512字节的数据分组，就知道它收到最后一个数据分组。 在写请求的情况下，TFTP客户发送WRQ指明文件名和模式。如果该文件能被该客户写，TFTP服务器就返回块编号为0的ACK包。该客户就将文件的头512字节以块编号为1发出。服务器则返回块编号为1的ACK。 这种类型的数据传输称为停止等待协议。它只用在一些简单的协议如TFTP中。TFTP的优点在于实现的简单而不是高的系统吞吐量。 最后一种TFTP报文类型是差错报文，它的操作码为5。它用于服务器不能处理读请求或写请求的情况。在文件传输过程中的读和写差错也会导致传送这种报文，接着停止传输。差错编号字段给出一个数字的差错码，跟着是一个ASCII表示的差错报文字段，可能包含额外的操作系统说明的信息。 既然TFTP使用不可靠的UDP，TFTP就必须处理分组丢失和分组重复。分组丢失可通过发送方的超时与重传机制解决（注意存在一种称为“魔术新手综合症(sorcerer’s apprentice syndrome)”的潜在问题，如果双方都超时与重传，就可能出现这个问题。)。和许多UDP应用程序一样，TFTP报文中没有检验和，它假定任何数据差错都将被UDP的检验和检测到。 安全性注意在TFTP分组中并不提供用户名和口令。这是TFTP的一个特征（即“安全漏洞”）。由于TFTP是设计用于系统引导进程，它不可能提供用户名和口令。 TFTP的这一特性被许多解密高手用于获取Unix口令文件的复制，然后来猜测用户口令。为防止这种类型的访问，目前大多数TFTP服务器提供了一个选项来限制只能访问特定目录下的文件（Unix系统中通常是/tftpboot）。这个目录中只包含无盘系统进行系统引导时所需的文件。 对其他的安全性，Unix系统下的TFTP服务器通常将它的用户ID和组ID设置为不会赋给任何真正用户的值。这只允许访问具有读或写属性的文件。 小结TFTP是一个简单的协议，适合于只读存储器，仅用于无盘系统进行系统引导。它只使用几种报文格式，是一种停止等待协议。 为了允许多个客户端同时进行系统引导，TFTP服务器必须提供一定形式的并发。因为UDP在一个客户与一个服务器之间并不提供唯一连接（TCP也一样），TFTP服务器通过为每个客户提供一个新的UDP端口来提供并发。这允许不同的客户输入数据报，然后由服务器中的UDP模块根据目的端口号进行区分，而不是由服务器本身来进行区分。 TFTP协议没有提供安全特性。大多数执行指望TFTP服务器的系统管理员来限制客户的访问，只允许它们访问引导所必须的文件。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>UDP</tag>
        <tag>TFTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件收藏站点]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F14%2Fsoftware-collection-site%2F</url>
    <content type="text"><![CDATA[zd423: http://www.zdfans.com/ 烈火: http://hrtsea.com/ NoCmd: https://www.nocmd.com/ 果核剥壳: https://www.ghboke.com/ 殁漂遥: https://www.laomo.me/]]></content>
      <categories>
        <category>Software</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) DNS：域名系统]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F14%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-dns%2F</url>
    <content type="text"><![CDATA[域名系统（DNS）是一种用于TCP/IP应用程序的分布式数据库，它提供主机名字和IP地址之间的转换及有关电子邮件的选路信息。这里提到的分布式是指在Internet上的单个站点不能拥有所有的信息。每个站点（如大学中的系、校园、公司或公司中的部门）保留它自己的信息数据库，并运行一个服务器程序供Internet上的其他系统（客户程序）查询。DNS提供了允许服务器和客户程序相互通信的协议。 从应用的角度上看，对DNS的访问是通过一个地址解析器（resolver）来完成的。在Unix主机中，该解析器主要是通过两个库函数gethostbyname和gethostbyaddr来访问的，它们在编译应用程序时与应用程序连接在一起。前者接收主机名字返回IP地址，而后者接收IP地址来寻找主机名字。解析器通过一个或多个名字服务器来完成这种相互转换。 解析器并不像TCP/IP协议那样是操作系统的内核。在一个应用程序请求TCP打开一个连接或使用UDP发送一个数据报之前。心须将一个主机名转换为一个IP地址。操作系统内核中的TCP/IP协议族对于DNS一点都不知道。 DNS 基础DNS的名字空间和Unix的文件系统相似，也具有层次结构，是一个树形结构。 每个结点有一个至多63个字符长的标识。这颗树的树根是没有任何标识的特殊结点。命名标识中一律不区分大写和小写。命名树上任何一个结点的域名就是将从该结点到最高层的域名串连起来，中间使用一个点“.”分隔这些域名（注意这和Unix文件系统路径的形成不同，文件路径是由树根依次向下的形成的）。域名树中的每个结点必须有一个唯一的域名，但域名树中的不同结点可使用相同的标识。 以点“.”结尾的域名称为绝对域名或完全合格的域名FQDN（Full Qualified DomainName），例如sun.tuc.noao.edu.。如果一个域名不以点结尾，则认为该域名是不完全的。如何使域名完整依赖于使用的DNS软件。如果不完整的域名由两个或两个以上的标号组成，则认为它是完整的；或者在该域名的右边加入一个局部后缀。例如域名sun通过加上局部后缀.tuc.noao.edu.成为完整的。 顶级域名被分为三个部分： arpa是一个用作地址到名字转换的特殊域。 7个3字符长的普通域。有些书也将这些域称为组织域。 所有2字符长的域均是基于ISO3166中定义的国家代码，这些域被称为国家域，或地理域。 7个普通域的正式划分： 域 描述 com 商业机构 edu 教育机构 gov 其他美国政府部门 int 国际组织 mil 美国军事网点 net 网络 org 其他组织 在DNS中，通常认为3字符长的普通域仅用于美国的组织机构，2字符长的国家域则用国际组织美国军事网点于每个国家，但情况并不总是这样。许多非美国的组织机构仍然使用普通域，而一些美国的其他组织组织机构也使用.us的国家域。普通域中只有.gov和.mil域局限于美国。 许多国家将它们的二级域组织成类似于普通域的结构：例如，.ac.uk是英国研究机构的二级域名，.co.uk则是英国商业机构的二级域名。 没有哪个机构来管理域名树中的每个标识，相反，只有一个机构，即网络信息中心NIC负责分配顶级域和委派其他指定地区域的授权机构。 一个独立管理的DNS子树称为一个区域(zone)。一个常见的区域是一个二级域，如noao.edu。许多二级域将它们的区域划分成更小的区域。例如，大学可能根据不同的系来划分区域，公司可能根据不同的部门来划分区域。 一旦一个区域的授权机构被委派后，由它负责向该区域提供多个名字服务器。当一个新系统加入到一个区域中时，该区域的DNS管理者为该新系统申请一个域名和一个IP地址，并将它们加到名字服务器的数据库中。这就是授权机构存在的必要性。例如，在一个小规模的大学，一个人就能完成每次新系统的加入。但对一个规模较大的大学来说，这一工作必须被专门委派的机构（可能是系）来完成，因为一个人已无法维持这一工作。 一个名字服务器负责一个或多个区域。一个区域的管理者必须为该区域提供一个主名字服务器和至少一个辅助名字服务器。主、辅名字服务器必须是独立和冗余的，以便当某个名字服务器发生故障时不会影响该区域的名字服务。 主、辅名字服务器的主要区别在于主名字服务器从磁盘文件中调入该区域的所有信息，而辅名字服务器则从主服务器调入所有信息。我们将辅名字服务器从主服务器调入信息称为区域传送。 当一个新主机加入一个区域时，区域管理者将适当的信息（最少包括名字和IP地址）加入到运行在主名字服务器上的一个磁盘文件中，然后通知主名字服务器重新调入它的配置文件。辅名字服务器定时（通常是每隔3小时）向主名字服务器询问是否有新数据。如果有新数据，则通过区域传送方式获得新数据。 当一个名字服务器没有请求的信息时，它将如何处理？它必须与其他的名字服务器联系。（这正是DNS的分布特性）。然而，并不是每个名字服务器都知道如何同其他名字服务器联系。相反，每个名字服务器必须知道如何同根的名字服务器联系。1993年4月时有8个根名字服务器，所有的主名字服务器都必须知道根服务器的IP地址（这些IP地址在主名字服务器的配置文件中，主服务器必须知道根服务器的IP地址，而不是它们的域名）。根服务器则知道所有二级域中的每个授权名字服务器的名字和位置（即IP地址）。这意味着这样一个反复的过程：正在处理请求的名字服务器与根服务器联系，根服务器告诉它与另一个名字服务器联系。 DNS的一个基本特性是使用超高速缓存。即当一个名字服务器收到有关映射的信息（主机名字到IP地址）时，它会将该信息存放在高速缓存中。这样若以后遇到相同的映射请求，就能直接使用缓存中的结果而无需通过其他服务器查询。 DNS 的报文格式 这个报文由12字节长的首部和4个长度可变的字段组成。 标识字段由客户程序设置并由服务器返回结果。客户程序通过它来确定响应与查询是否匹配。 16 bit的标志字段被划分为若干子字段，从最左位开始依次介绍各子字段： QR是1bit字段：0表示查询报文，1表示响应报文。 opcode是一个4bit字段：通常值为0（标准查询），其他值为1（反向查询）和2（服务器状态请求）。 AA是1bit标志，表示“授权回答(authoritative answer)”。该名字服务器是授权于该域的。 TC是1bit字段，表示“可截断的(truncated)”。使用UDP时，它表示当应答的总长度超过512字节时，只返回前512个字节。 RD是1bit字段表示“期望递归（recursion desired）”。该比特能在一个查询中设置，并在响应中返回。这个标志告诉名字服务器必须处理这个查询，也称为一个递归查询。如果该位为0，且被请求的名字服务器没有一个授权回答，它就返回一个能解答该查询的其他名字服务器列表，这称为迭代查询。 RA是1bit字段，表示“可用递归”。如果名字服务器支持递归查询，则在响应中将该比特设置为1。大多数名字服务器都提供递归查询，除了某些根服务器。 随后的3bit字段必须为0。 rcode是一个4bit的返回码字段。通常的值为0（没有差错）和3（名字差错）。名字差错只有从一个授权名字服务器上返回，它表示在查询中制定的域名不存在。 随后的4个16 bit字段说明最后4个变长字段中包含的条目数。对于查询报文，问题(question)数通常是1，而其他3项则均为0。类似地，对于应答报文，回答数至少是1，剩下的两项可以是0或非0。 DNS 查询报文中的问题部分问题部分的每个问题的格式如下，通常只有一个问题。 查询名是要查找的名字，它是一个或多个标识符的序列。每个标识符以首字节的计数值来说明随后标识符的字节长度，每个名字以最后字节为0结束，长度为0的标识符是根标识符。计数字节的值必须是0~63的数，因为标识符的最大长度仅为63(计数字节的最高两比特为1，即值192~255，将用于压缩格式)。不像我们已经看到的许多其他报文格式，该字段无需以整32 bit边界结束，即无需填充字节。 每个问题有一个查询类型，而每个响应（也称为一个资源记录）也有一个类型。大约有20个不同的类型值，其中的一些目前已经过时。查询类型是类型的一个超集(superset)：表中显示的类型值中只有两个能用于查询类型。 名字 数值 描述 类型？ 查询类型？ A 1 IP地址 * * NS 2 名字服务器 * * CNAME 5 规范名字 * * PTR 12 指针记录 * * HINFO 13 主机信息 * * MX 15 邮件交换信息 * * AXFR 252 对区域转换的请求 * *或ANY 255 对所有记录的请求 * 最常用的查询类型是A类型，表示期望获得查询名的IP地址。一个PTR查询则请求获得一个IP地址对应的域名。这是一个指针查询。 查询类通常是1，指互联网地址（某些站点也支持其他非IP地址）。 DNS 响应报文中的资源记录部分DNS报文中最后的三个字段，回答字段、授权字段和附加信息字段，均采用一种称为资源记录RR（Resource Record）的相同格式。资源记录的格式如下： 域名是记录中资源数据对应的名字。它的格式和前面介绍的查询名字段格式相同。 类型说明RR的类型码。它的值和前面介绍的查询类型值是一样的。类通常为1，指Internet数据。 生存时间字段是客户程序保留该资源记录的秒数。资源记录通常的生存时间值为2天。 资源数据长度说明资源数据的数量。该数据的格式依赖于类型字段的值。对于类型1（A记录）资源数据是4字节的IP地址。 指针查询DNS中一直难于理解的部分就是指针查询方式，即给定一个IP地址，返回与该地址对应的域名。 查看一下顶级域arpa，及它下面的in-addr域。当一个组织加入Internet，并获得DNS域名空间的授权，如noao.edu，则它们也获得了对应IP地址的in-addr.arpa域名空间的授权。在noao.edu这个例子中，它是网络号为140.252的B类网络。在DNS树中结点in-addr.arpa的下一级必须是该IP地址的第一字节（140），再下一级为该IP地址的下一个字节（252），依此类推。但应牢记的是DNS名字是由DNS树的底部逐步向上书写的。这意味着对于IP地址为140.252.13.33的sun主机，它的DNS名字为33.13.252.140.in-addr.arpa。 必须写出4字节的IP地址，因为授权的代表是基于网络号：A类地址是第一字节，B类地址是第一、二字节，C类地址则是第一、二、三字节。IP地址的第一字节一定位于in-addr的下一级，但FQDN却是自树底往上书写的。如果FQDN由顶往下书写，则这个IP地址的DNS名字将是arpa.in-addr.140.252.13.33，而它所对应的域名将是edu.noao.tuc.sun。 如果DNS树中没有独立的分支来处理这种地址—名字的转换，将无法进行这种反向转换，除非从树根开始依次尝试每个顶级域。毫不夸张地说，这将需要数天或数周的时间。虽然反写IP地址和特殊的域名会造成某些混乱，但in-addr解决方案仍是一种最有效的方式。 只有在使用host程序或tcpdump程序直接同DNS打交道时，才会担心in-addr域和反写IP地址影响我们。从应用的角度上看，正常的名字解析器函数（gethostbyaddr）将接收一个IP地址并返回对应主机的有关信息。反转这些字节和添加in-addr.arpa域均由该函数自动完成。 主机名检查当一个IP数据报到达一个作为服务器的主机时，无论是UDP数据报还是TCP连接请求，服务器进程所能获得的是客户的IP地址和端口号（UDP或TCP）。某些服务器需要客户的IP地址来获得在DNS中的指针记录。 其他的一些服务器如Rlogin服务器不但需要客户的IP地址来获得指针记录，还要向DNS询问该IP地址所对应的域名，并检查返回的地址中是否有地址与收到的数据报中的源IP地址匹配。该检查是因为.rhosts文件中的条目仅包含主机名，而没有IP地址，因此主机需要证实该主机名是否对应源IP地址。 某些厂商将该项检查自动并入其名字解析器的例程中，特别是函数gethostbyaddr。这使得任何使用名字解析器的程序均可获得这种检查，而无需在应用中人为地进行这项检查。 资源记录至今我们已经见到了一些不同类型的资源记录（RR）：IP地址查询为A类型，指针查询为类型PTR。也已看到了由名字服务器返回的资源记录：回答RR、授权RR和附加信息RR。 类型 介绍 A 一个A记录定义了一个IP地址，它存储32 bit的二进制数。 PTR 指针记录用于指针查询。 IP地址被看作是in-addr.arpa域下的一个域名（标识符串）。 CNAME 这表示“规范名字 (canonical name)”。它用来表示一个域名（标识符串），而有规范名字的域名通常被称为别名 (alias)。某些FTP服务器使用它向其他的系统提供一个易于记忆的别名。 HINFO 表示主机信息：包括说明主机CPU和操作系统的两个字符串。并非所有的站点均提供它们系统的HINFO记录，并且提供的信息也可能不是最新的。 MX 邮件交换记录 NS 名字服务器记录。它说明一个域的授权名字服务器。它由域名表示（符号串）。 邮件交换记录，用于以下一些场合：（1）一个没有连到Internet的站点能将一个连到Internet的站点作为它的邮件交换器。这两个站点能够用一种交替的方式交换到达的邮件，而通常使用的协议是UUCP协议。（2）MX记录提供了一种将无法到达其目的主机的邮件传送到一个替代主机的方式。（3）MX记录允许机构提供供他人发送邮件的虚拟主机，如cs.university.edu，即使这样的主机名根本不存在。（4）防火墙网关能使用MX记录来限制外界与内部系统的连接。许多不能与Internet连接的站点通过UUCP链路与一个连接在Internet上的站点如UUNET相连接。通过MX记录能使用user@host这种邮件地址向那个站点发送电子邮件。 高速缓存为了减少Internet上DNS的通信量，所有的名字服务器均使用高速缓存。在标准的Unix实现中，高速缓存是由名字服务器而不是由名字解析器维护的。既然名字解析器作为每个应用的一部分，而应用又不可能总处于工作状态，因此将高速缓存放在只要系统（名字服务器）处于工作状态就能起作用的程序中显得很重要。这样任何一个使用名字服务器的应用均可获得高速缓存。在该站点使用这个名字服务器的任何其他主机也能共享服务器的高速缓存。 用UDP还是TCP注意到DNS名字服务器使用的熟知端口号无论对UDP还是TCP都是53。这意味着DNS均支持UDP和TCP访问。那么这两种协议都在什么情况下采用以及采用的理由都是什么呢？ 当名字解析器发出一个查询请求，并且返回响应中的TC（删减标志）比特被设置为1时，它就意味着响应的长度超过了512个字节，而仅返回前512个字节。在遇到这种情况时，名字解析器通常使用TCP重发原来的查询请求，它将允许返回的响应超过512个字节。既然TCP能将用户的数据流分为一些报文段，它就能用多个报文段来传送任意长度的用户数据。 此外，当一个域的辅助名字服务器在启动时，将从该域的主名字服务器执行区域传送。我们也说过辅助服务器将定时（通常是3小时）向主服务器进行查询以便了解主服务器数据是否发生变动。如果有变动，将执行一次区域传送。区域传送将使用TCP，因为这里传送的数据远比一个查询或响应多得多。 既然DNS主要使用UDP，无论是名字解析器还是名字服务器都必须自己处理超时和重传。此外，不像其他的使用UDP的Internet应用（TFTP、BOOTP和SNMP），大部分操作集中在局域网上，DNS查询和响应通常经过广域网。分组丢失率和往返时间的不确定性在广域网上比局域网上更大。这样对于DNS客户程序，一个好的重传和超时程序就显得更重要了。 小结DNS是任何与Internet相连主机必不可少的一部分，同时它也广泛用于专用的互联网。层次树是组成DNS域名空间的基本组织形式。 应用程序通过名字解析器将一个主机名转换为一个IP地址，也可将一个IP地址转换为与之对应的主机名。名字解析器将向一个本地名字服务器发出查询请求，这个名字服务器可能通过某个根名字服务器或其他名字服务器来完成这个查询。 所有的DNS查询和响应都有相同的报文格式。这个报文格式中包含查询请求和可能的回答资源记录、授权资源记录和附加资源记录。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emacs load packages]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F11%2Femacs-load-packages%2F</url>
    <content type="text"><![CDATA[loadload → is the general function for loading a file. 1(load FILE &amp;optional NOERROR NOMESSAGE NOSUFFIX MUST-SUFFIX) 举个例子，如果你的代码是 (load &quot;x&quot;)，emacs 将从 load-path 中尝试加载 x.elc、x.el、x 文件。 load-fileload-file → load one specific file. The file name argument should contain file name extension, such as .el .elc (load-file file_name) just calls (load (expand-file-name file_name) nil nil t) Use load-file when you have a specific full path of a file in mind. 举个例子：1load-file &quot;~/.emacs.d/lisp/init-example.el&quot; 这是最为原始的方式，填写的路径必须是绝对路径，这个路径也不会加入到emacs中load-path里。它也不会优先寻找编译过.elc文件（显然编译过文件的会更快些）。这种方式已经被抛弃，仅作为历史提一下。 requirerequire → Load a package if it has not already been loaded. 1(require FEATURE &amp;optional FILENAME NOERROR) require checks if the symbol FEATURE is in variable features. If not, then it calls load to load it. File name is guessed from the feature name FEATURE, or specified in the optional argument. require is best used in elisp libraries or scripts, similar to other language’s “require” or “import”. 举个例子：init-example.el123... your code here ...(provide &apos;init-example) init.el12... your code here ...(require &apos;init-example) autoloadautoload → Load a file only when a function is called. 1(autoload FUNCTION FILE &amp;optional DOCSTRING INTERACTIVE TYPE) autoload associates a function name with a file path. When the function is called, load the file, and execute the function. If you are writing a major mode, have your package installation go by autoload if possible. It saves startup time. 举个例子：1(autoload &apos;python-mode &quot;python-mode&quot; &quot;Python Mode.&quot; t) with-eval-after-loadIf you want code to be executed when a particular library is loaded, use the macro with-eval-after-load. with-eval-after-load is like the old eval-after-load, but better behaved. eval-after-load is considered ill-behaved because it is a function, not a macro, and thus requires the code inside it to be quoted, which means that it cannot be byte-compiled. It also accepts only one form, so if you have more than one, you need to use progn. For example:1234(eval-after-load &quot;foo&quot; &apos;(progn (setq foo 42) (setq bar 17))) The equivalent version with with-eval-after-load would be:123(with-eval-after-load &quot;foo&quot; (setq foo 42) (setq bar 17)) Define a macro after-load which is compatible with both with-eval-after-load and eval-after-load.1234567(if (fboundp &apos;with-eval-after-load) (defalias &apos;after-load &apos;with-eval-after-load) (defmacro after-load (feature &amp;rest body) &quot;After FEATURE is loaded, evaluate BODY.&quot; (declare (indent defun)) `(eval-after-load ,feature &apos;(progn ,@body)))) use-packageThe use-package macro allows you to isolate package configuration in your .emacs file in a way that is both performance-oriented and, well, tidy. For more information, visit https://jwiegley.github.io/use-package .]]></content>
      <categories>
        <category>Software</category>
        <category>emacs</category>
      </categories>
      <tags>
        <tag>use-package</tag>
        <tag>require</tag>
        <tag>autoload</tag>
        <tag>with-eval-after-load</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) IGMP：Internet组管理协议]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F10%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-igmp%2F</url>
    <content type="text"><![CDATA[用于支持主机和路由器进行多播的Internet组管理协议（IGMP）。它让一个物理网络上的所有系统知道主机当前所在的多播组。多播路由器需要这些信息以便知道多播数据报应该向哪些接口转发。 正如ICMP一样，IGMP也被当作IP层的一部分。IGMP报文通过IP数据报进行传输。不像我们已经见到的其他协议，IGMP有固定的报文长度，没有可选数据。IP首部(20字节) + IGMP报文(8字节)。 IGMP报文通过IP首部中协议字段值为2来指明。 IGMP报文 这是版本为1的IGMP。IGMP类型为1说明是由多播路由器发出的查询报文，为2说明是主机发出的报告报文。检验和的计算和ICMP协议相同。 组地址为D类IP地址。在查询报文中组地址设置为0，在报告报文中组地址为要参加的组地址。 IGMP协议加入一个多播组多播的基础就是一个进程的概念（使用的术语进程是指操作系统执行的一个程序），该进程在一个主机的给定接口上加入了一个多播组。在一个给定接口上的多播组中的成员是动态的—它随时因进程加入和离开多播组而变化。 这里所指的进程必须以某种方式在给定的接口上加入某个多播组。进程也能离开先前加入的多播组。这些是一个支持多播主机中任何API所必需的部分。使用限定词“接口”是因为多播组中的成员是与接口相关联的。一个进程可以在多个接口上加入同一多播组。 这里暗示一个主机通过组地址和接口来识别一个多播组。主机必须保留一个表，此表中包含所有至少含有一个进程的多播组以及多播组中的进程数量。 IGMP报告和查询多播路由器使用IGMP报文来记录与该路由器相连网络中组成员的变化情况。使用规则如下： 当第一个进程加入一个组时，主机就发送一个IGMP报告。如果一个主机的多个进程加入同一组，只发送一个IGMP报告。这个报告被发送到进程加入组所在的同一接口上。 进程离开一个组时，主机不发送IGMP报告，即便是组中的最后一个进程离开。主机知道在确定的组中已不再有组成员后，在随后收到的IGMP查询中就不再发送报告报文。 多播路由器定时发送IGMP查询来了解是否还有任何主机包含有属于多播组的进程。多播路由器必须向每个接口发送一个IGMP查询。因为路由器希望主机对它加入的每个多播组均发回一个报告，因此IGMP查询报文中的组地址被设置为0。 主机通过发送IGMP报告来响应一个IGMP查询，对每个至少还包含一个进程的组均要发回IGMP报告。 使用这些查询和报告报文，多播路由器对每个接口保持一个表，表中记录接口上至少还包含一个主机的多播组。当路由器收到要转发的多播数据报时，它只将该数据报转发到（使用相应的多播链路层地址）还拥有属于那个组主机的接口上。 下图显示了两个IGMP报文，一个是主机发送的报告，另一个是路由器发送的查询。该路由器正在要求那个接口上的每个主机说明它加入的每个多播组。 实现细节为改善该协议的效率，有许多实现的细节要考虑。首先，当一个主机首次发送IGMP报告（当第一个进程加入一个多播组）时，并不保证该报告被可靠接收（因为使用的是IP交付服务）。下一个报告将在间隔一段时间后发送。这个时间间隔由主机在0~10秒的范围内随机选择。 其次，当一个主机收到一个从路由器发出的查询后，并不立即响应，而是经过一定的时间间隔后才发出一些响应（采用“响应”的复数形式是因为该主机必须对它参加的每个组均发送一个响应）。既然参加同一多播组的多个主机均能发送一个报告，可将它们的发送间隔设置为随机时延。在一个物理网络中的所有主机将收到同组其他主机发送的所有报告，因为报告报文中的目的地址是那个组地址。这意味着如果一个主机在等待发送报告的过程中，却收到了发自其他主机的相同报告，则该主机的响应就可以不必发送了。因为多播路由器并不关心有多少主机属于该组，而只关心该组是否还至少拥有一个主机。的确，一个多播路由器甚至不关心哪个主机属于一个多播组。它仅仅想知道在给定的接口上的多播组中是否还至少有一个主机。 在没有任何多播路由器的单个物理网络中，仅有的IGMP通信量就是在主机加入一个新的多播组时，支持IP多播的主机所发出的报告。 生存时间字段IGMP报告和查询的生存时间(TTL)均设置为1，这涉及到IP首部中的TTL字段。一个初始TTL为0的多播数据报将被限制在同一主机。在默认情况下，待传多播数据报的TTL被设置为1，这将使多播数据报仅局限在同一子网内传送。更大的TTL值能被多播路由器转发。 对发往一个多播地址的数据报从不会产生ICMP差错。当TTL值为0时，多播路由器也不产生ICMP“超时”差错。 在正常情况下，用户进程不关心传出数据报的TTL。然而，一个例外是Traceroute程序，它主要依据设置TTL值来完成。既然多播应用必须能够设置要传送数据报的TTL值，这意味着程序设计接口必须为用户进程提供这种能力。 通过增加TTL值的方法，一个应用程序可实现对一个特定服务器的扩展环搜索(expanding ring search)。第一个多播数据报以TTL等于1发送。如果没有响应，就尝试将TTL设置为2，然后3，等等。在这种方式下，该应用能找到以跳数来度量的最近的服务器。 从224.0.0.0到224.0.0.255的特殊地址空间是打算用于多播范围不超过1跳的应用。不管TTL值是多少，多播路由器均不转发目的地址为这些地址中的任何一个地址的数据报。 所有主机组在上面的图中，我们看到了路由器的IGMP查询被送到目的IP地址224.0.0.1。该地址被称为所有主机组地址。它涉及在一个物理网络中的所有具备多播能力的主机和路由器。当接口初始化后，所有具备多播能力接口上的主机均自动加入这个多播组。这个组的成员无需发送IGMP报告。 小结多播是一种将报文发往多个接收者的通信方式。在许多应用中，它比广播更好，因为多播降低了不参与通信的主机的负担。简单的主机成员报告协议(IGMP)是多播的基本模块。 在一个局域网中或跨越邻近局域网的多播需要使用上面介绍的技术。广播通常局限在单个局域网中，对目前许多使用广播的应用来说，可采用多播来替代广播。 然而，多播还未解决的一个问题是在广域网内的多播。[Deering and Cheriton 1990]提出扩展目前的路由协议来支持多播。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>IGMP</tag>
        <tag>multicast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) 广播和多播]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F10%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-broadcasting-and-multicasting%2F</url>
    <content type="text"><![CDATA[广播和多播仅应用于UDP，它们对需将报文同时传往多个接收者的应用来说十分重要。TCP是一个面向连接的协议，它意味着分别运行于两主机（由IP地址确定）内的两进程（由端口号确定）间存在一条连接。 考虑包含多个主机的共享信道网络如以太网。每个以太网帧包含源主机和目的主机的以太网地址（48bit）。通常每个以太网帧仅发往单个目的主机，目的地址指明单个接收接口，因而称为单播(unicast)。在这种方式下，任意两个主机的通信不会干扰网内其他主机（可能引起争夺共享信道的情况除外）。 然而，有时一个主机要向网上的所有其他主机发送帧，这就是广播(broadcast)。通过ARP和RARP可以看到这一过程。多播(multicast)处于单播和广播之间：帧仅传送给属于多播组的多个主机。 为了弄清广播和多播，需要了解主机对由信道传送过来帧的过滤过程。 首先，网卡查看由信道传送过来的帧，确定是否接收该帧，若接收后就将它传往设备驱动程序。通常网卡仅接收那些目的地址为网卡物理地址或广播地址的帧。另外，多数接口均被设置为混合模式，这种模式能接收每个帧的一个复制。作为一个例子，tcpdump使用这种模式。 目前，大多数的网卡经过配置都能接收目的地址为多播地址或某些子网多播地址的帧。对于以太网，当地址中最高字节的最低位设置为1时表示该地址是一个多播地址，用十六进制可表示为01:00:00:00:00:00（以太网广播地址ff:ff:ff:ff:ff:ff可看作是以太网多播地址的特例）。 如果网卡收到一个帧，这个帧将被传送给设备驱动程序（如果帧检验和错，网卡将丢弃该帧）。设备驱动程序将进行另外的帧过滤。首先，帧类型中必须指定要使用的协议（IP、ARP等等）。其次，进行多播过滤来检测该主机是否属于多播地址说明的多播组。 设备驱动程序随后将数据帧传送给下一层，比如，当帧类型指定为IP数据报时，就传往IP层。IP根据IP地址中的源地址和目的地址进行更多的过滤检测。如果正常，就将数据报传送给下一层（如TCP或UDP）。 每次UDP收到由IP传送来的数据报，就根据目的端口号，有时还有源端口号进行数据报过滤。如果当前没有进程使用该目的端口号，就丢弃该数据报并产生一个ICMP不可达报文（TCP根据它的端口号作相似的过滤）。如果UDP数据报存在检验和错，将被丢弃。 使用广播的问题在于它增加了对广播数据不感兴趣主机的处理负荷。拿一个使用UDP广播应用作为例子。如果网内有50个主机，但仅有20个参与该应用，每次这20个主机中的一个发送UDP广播数据时，其余30个主机不得不处理这些广播数据报。一直到UDP层，收到的UDP广播数据报才会被丢弃。这30个主机丢弃UDP广播数据报是因为这些主机没有使用这个目的端口。 多播的出现减少了对应用不感兴趣主机的处理负荷。使用多播，主机可加入一个或多个多播组。这样，网卡将获悉该主机属于哪个多播组，然后仅接收主机所在多播组的那些多播帧。 广播受限的广播受限的广播地址是255.255.255.255。该地址用于主机配置过程中IP数据报的目的地址，此时，主机可能还不知道它所在网络的网络掩码，甚至连它的IP地址也不知道。 在任何情况下，路由器都不转发目的地址为受限的广播地址的数据报，这样的数据报仅出现在本地网络中。 一个未解的问题是：如果一个主机是多接口的，当一个进程向本网广播地址发送数据报时，为实现广播，是否应该将数据报发送到每个相连的接口上？如果不是这样，想对主机所有接口广播的应用必须确定主机中支持广播的所有接口，然后向每个接口发送一个数据报复制。 大多数BSD系统将255.255.255.255看作是配置后第一个接口的广播地址，并且不提供向所属具备广播能力的接口传送数据报的功能。不过，routed和rwhod（BSD rwho客户的服务器）是向每个接口发送UDP数据报的两个应用程序。这两个应用程序均用相似的启动过程来确定主机中的所有接口，并了解哪些接口具备广播能力。同时，将对应于那种接口的指向网络的广播地址作为发往该接口的数据报的目的地址。 Host Requirements RFC没有进一步涉及多接口主机是否应当向其所有的接口发送受限的广播。 指向网络的广播指向网络的广播地址是主机号为全1的地址。A类网络广播地址为netid.255.255.255，其中netid为A类网络的网络号。 一个路由器必须转发指向网络的广播，但它也必须有一个不进行转发的选择。 指向子网的广播指向子网的广播地址为主机号为全1且有特定子网号的地址。作为子网直接广播地址的IP地址需要了解子网的掩码。例如，如果路由器收到发往128.1.2.255的数据报，当B类网络128.1的子网掩码为255.255.255.0时，该地址就是指向子网的广播地址；但如果该子网的掩码为255.255.254.0，该地址就不是指向子网的广播地址。 指向所有子网的广播指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开。指向所有子网的广播地址的子网号及主机号为全1。例如，如果目的子网掩码为255.255.255.0，那么IP地址128.1.255.255是一个指向所有子网的广播地址。然而，如果网络没有划分子网，这就是一个指向网络的广播。 当前的看法[Almquist 1993]是这种广播是陈旧过时的，更好的方式是使用多播而不是对所有子网的广播。 多播IP多播提供两类服务： 向多个目的地址传送数据。有许多向多个接收者传送信息的应用：例如交互式会议系统和向多个接收者分发邮件或新闻。如果不采用多播，目前这些应用大多采用TCP来完成（向每个目的地址传送一个单独的数据复制）。然而，即使使用多播，某些应用可能继续采用TCP来保证它的可靠性。 客户对服务器的请求。例如，无盘工作站需要确定启动引导服务器。目前，这项服务是通过广播来提供的(如BOOTP)，但是使用多播可降低不提供这项服务主机的负担。 多播组地址D类IP地址的格式： 不像其他三类IP地址（A、B和C），分配的28 bit均用作多播组号而不再表示其他。 多播组地址包括为1110的最高4bit和多播组号。它们通常可表示为点分十进制数，范围从224.0.0.0到239.255.255.255。 能够接收发往一个特定多播组地址数据的主机集合称为主机组(host group)。一个主机组可跨越多个网络。主机组中成员可随时加入或离开主机组。主机组中对主机的数量没有限制，同时不属于某一主机组的主机可以向该组发送信息。 一些多播组地址被IANA确定为知名地址。它们也被当作永久主机组，这和TCP及UDP中的熟知端口相似。同样，这些知名多播地址在RFC最新分配数字中列出。注意这些多播地址所代表的组是永久组，而它们的组成员却不是永久的。 例如，224.0.0.1代表“该子网内的所有系统组”，224.0.0.2代表“该子网内的所有路由器组”。多播地址224.0.1.1用作网络时间协议NTP，224.0.0.9用作RIP-2，224.0.1.2用作SGI公司的dogfight应用。 多播组地址到以太网地址的转换IANA拥有一个以太网地址块，即高位24 bit为00:00:5e（十六进制表示），这意味着该地址块所拥有的地址范围从00:00:5e:00:00:00到00:00:5e:ff:ff:ff。IANA将其中的一半分配为多播地址。为了指明一个多播地址，任何一个以太网地址的首字节必须是01，这意味着与IP多播相对应的以太网地址范围从01:00:5e:00:00:00到01:00:5e:7f:ff:ff。 这种地址分配将使以太网多播地址中的23bit与IP多播组号对应起来，通过将多播组号中的低位23bit映射到以太网地址中的低位23bit实现，这个过程如下所示： 由于多播组号中的最高5bit在映射过程中被忽略，因此每个以太网多播地址对应的多播组是不唯一的。32个不同的多播组号被映射为一个以太网地址。例如，多播地址224.128.64.32（十六进制e0.80.40.20）和224.0.64.32（十六进制e0.00.40.20）都映射为同一以太网地址01:00:5e:00:40:20。 既然地址映射是不唯一的，那么设备驱动程序或IP层就必须对数据报进行过滤。因为网卡可能接收到主机不想接收的多播数据帧。另外，如果网卡不提供足够的多播数据帧过滤功能，设备驱动程序就必须接收所有多播数据帧，然后对它们进行过滤。 单个物理网络的多播是简单的。多播进程将目的IP地址指明为多播地址，设备驱动程序将它转换为相应的以太网地址，然后把数据发送出去。这些接收进程必须通知它们的IP层，它们想接收的发往给定多播地址的数据报，并且设备驱动程序必须能够接收这些多播帧。这个过程就是“加入一个多播组”（使用“接收进程”复数形式的原因在于对一确定的多播信息，在同一主机或多个主机上存在多个接收者，这也是为什么要首先使用多播的原因）。当一个主机收到多播数据报时，它必须向属于那个多播组的每个进程均传送一个复制。这和单个进程收到单播UDP数据报的UDP不同。使用多播，一个主机上可能存在多个属于同一多播组的进程。 当把多播扩展到单个物理网络以外需要通过路由器转发多播数据时，复杂性就增加了。需要有一个协议让多播路由器了解确定网络中属于确定多播组的任何一个主机。这个协议就是Internet组管理协议（IGMP）。 FDDI和令牌环网络中的多播FDDI网络使用相同的D类IP地址到48 bit FDDI地址的映射过程[Katz 1990]。令牌环网络通常使用不同的地址映射方法，这是因为大多数令牌控制中的限制。 小结广播是将数据报发送到网络中的所有主机（通常是本地相连的网络），而多播是将数据报发送到网络的一个主机组。这两个概念的基本点在于当收到送往上一个协议栈的数据帧时采用不同类型的过滤。每个协议层均可以因为不同的理由丢弃数据报。 目前有四种类型的广播地址：受限的广播、指向网络的广播、指向子网的广播和指向所有子网的广播。最常用的是指向子网的广播。受限的广播通常只在系统初始启动时才会用到。 试图通过路由器进行广播而发生的问题，常常是因为路由器不了解目的网络的子网掩码。结果与多种因素有关：广播地址类型、配置参数等等。 D类IP地址被称为多播组地址。通过将其低位23 bit映射到相应以太网地址中便可实现多播组地址到以太网地址的转换。由于地址映射是不唯一的，因此需要其他的协议实现额外的数据报过滤。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>IGMP</tag>
        <tag>multicast</tag>
        <tag>broadcast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Add shell-pop with eshell]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F09%2Fshell-pop-with-eshell%2F</url>
    <content type="text"><![CDATA[1234567891011(use-package shell-pop :ensure t :defer t :bind (&quot;C-c t&quot; . shell-pop) :config (custom-set-variables &apos;(shell-pop-shell-type (quote (&quot;eshell&quot; &quot;*eshell*&quot; (lambda nil (eshell))))) &apos;(shell-pop-window-size 30) &apos;(shell-pop-full-span t) &apos;(shell-pop-window-position &quot;bottom&quot;)) )]]></content>
      <categories>
        <category>Software</category>
        <category>emacs</category>
      </categories>
      <tags>
        <tag>eshell</tag>
        <tag>shell-pop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) UDP：用户数据报协议]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F09%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-udp-user-datagram-protocol%2F</url>
    <content type="text"><![CDATA[UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。这与面向流字符的协议不同，如TCP，应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系。 UDP数据报封装成一份IP数据报的格式：IP首部(20字节) - UDP首部(8字节) - UDP数据。 UDP不提供可靠性：它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的地。由于缺乏可靠性，我们似乎觉得要避免使用UDP而使用一种可靠协议如TCP。 应用程序必须关心IP数据报的长度。如果它超过网络的MTU，那么就要对IP数据报进行分片。如果需要，源端到目的端之间的每个网络都要进行分片，并不只是发送端主机连接第一个网络才这样做。 UDP 首部 端口号表示发送进程和接收进程。由于IP层已经把IP数据报分配给TCP或UDP（根据IP首部中协议字段值），因此TCP端口号由TCP来查看，而UDP端口号由UDP来查看。TCP端口号与UDP端口号是相互独立的。 尽管相互独立，如果TCP和UDP同时提供某种知名服务，两个协议通常选择相同的端口号。这纯粹是为了使用方便，而不是协议本身的要求。 UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为8字节（发送一份0字节的UDP数据报是OK）。这个UDP长度是有冗余的。IP数据报长度指的是数据报全长，因此UDP数据报长度是全长减去IP首部的长度。 UDP 检验和UDP检验和覆盖UDP首部和UDP数据。回想IP首部的检验和，它只覆盖IP的首部—并不覆盖IP数据报中的任何数据。 UDP和TCP在首部中都有覆盖它们首部和数据的检验和。UDP的检验和是可选的，而TCP的检验和是必需的。 尽管UDP检验和的基本计算方法与IP首部检验和计算方法相类似（16 bit字的二进制反码和），但是它们之间存在不同的地方。首先，UDP数据报的长度可以为奇数字节，但是检验和算法是把若干个16 bit字相加。解决方法是必要时在最后增加填充字节0，这只是为了检验和的计算（也就是说，可能增加的填充字节不被传送）。 其次，UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。伪首部包含IP首部一些字段。其目的是让UDP两次检查数据是否已经正确到达目的地（例如，IP没有接受地址不是本主机的数据报，以及IP没有把应传给另一高层的数据报传给UDP）。 在该图中，我们特地举了一个奇数长度的数据报例子，因而在计算检验和时需要加上填充字节。注意，UDP数据报的长度在检验和计算过程中出现两次。 如果检验和的计算结果为0，则存入的值为全1（65535），这在二进制反码计算中是等效的。如果传送的检验和为0，说明发送端没有计算检验和。 如果发送端没有计算检验和而接收端检测到检验和有差错，那么UDP数据报就要被悄悄地丢弃。不产生任何差错报文（当IP层检测到IP首部检验和有差错时也这样做）。 UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动。 尽管UDP检验和是可选的，但是它们应该总是在用。在80年代，一些计算机产商在默认条件下关闭UDP检验和的功能，以提高使用UDP协议的NFS（Network File System）的速度。在单个局域网中这可能是可以接受的，但是在数据报通过路由器时，通过对链路层数据帧进行循环冗余检验（如以太网或令牌环数据帧）可以检测到大多数的差错，导致传输失败。不管相信与否，路由器中也存在软件和硬件差错，以致于修改数据报中的数据。如果关闭端到端的UDP检验和功能，那么这些差错在UDP数据报中就不能被检测出来。另外，一些数据链路层协议（如SLIP）没有任何形式的数据链路检验和。 Host Requirements RFC 声明，UDP检验和选项在默认条件下是打开的。它还声明，如果发送端已经计算了检验和，那么接收端必须检验接收到的检验和（如接收到检验和不为0）。但是，许多系统没有遵守这一点，只是在出口检验和选项被打开时才验证接收到的检验和。 IP 分片物理网络层一般要限制每次发送数据帧的最大长度。任何时候IP层接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据（选路），并查询该接口获得其MTU。IP把MTU与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。 把一份IP数据报分片以后，只有到达目的地才进行重新组装（这里的重新组装与其他网络协议不同，它们要求在下一站就进行进行重新组装，而不是在最终的目的地）。重新组装由目的端的IP层来完成，其目的是使分片和重新组装过程对运输层（TCP和UDP）是透明的，除了某些可能的越级操作外。已经分片过的数据报有可能会再次进行分片（可能不止一次）。IP首部中包含的数据为分片和重新组装提供了足够的信息。 回忆IP首部，下面这些字段用于分片过程。对于发送端发送的每份IP数据报来说，其标识字段都包含一个唯一值。该值在数据报分片时被复制到每个片中（我们现在已经看到这个字段的用途）。标志字段用其中一个比特来表示“更多的片”。除了最后一片外，其他每个组成数据报的片都要把该比特置1。片偏移字段指的是该片偏移原始数据报开始处的位置。另外，当数据报被分片后，每个片的总长度值要改为该片的长度值。 最后，标志字段中有一个比特称作“不分片”位。如果将这一比特置1，IP将不对数据报进行分片。相反把数据报丢弃并发送一个ICMP差错报文(“需要进行分片但设置了不分片比特”)给起始端。 当IP数据报被分片后，每一片都成为一个分组，具有自己的IP首部，并在选择路由时与其他分组独立。这样，当数据报的这些片到达目的端时有可能会失序，但是在IP首部中有足够的信息让接收端能正确组装这些数据报片。 尽管IP分片过程看起来是透明的，但有一点让人不想使用它：即使只丢失一片数据也要重传整个数据报。为什么会发生这种情况呢？因为IP层本身没有超时重传的机制——由更高层来负责超时和重传（TCP有超时和重传机制，但UDP没有。一些UDP应用程序本身也执行超时和重传）。当来自TCP报文段的某一片丢失后，TCP在超时后会重发整个TCP报文段，该报文段对应于一份IP数据报。没有办法只重传数据报中的一个数据报片。事实上，如果对数据报分片的是中间路由器，而不是起始端系统，那么起始端系统就无法知道数据报是如何被分片的。就这个原因，经常要避免分片。文献[Kent and Mogul 1987]对避免分片进行了论述。 使用UDP很容易导致IP分片（在后面我们将看到，TCP试图避免分片，但对于应用程序来说几乎不可能强迫TCP发送一个需要进行分片的长报文段）。我们可以用sock程序来增加数据报的长度，直到分片发生。在一个以太网上，数据帧的最大长度是1500字节，其中1472字节留给数据，假定IP首部为20字节，UDP首部为8字节。我们分别以数据长度为1471,1472,1473和1474字节运行sock程序。最后两次应该发生分片：1234bsdi % sock -u -i -nl -wl471 svr4 discardbsdi % sock -u -i -nl -wl472 svr4 discardbsdi % sock -u -i -nl -wl473 svr4 discardbsdi % sock -u -i -nl -wl474 svr4 discard 相应的tcpdump输出如下所示：1234561 0.0 bsdi-1112 &gt; svr4.discard: udp 14712 21.008303 (21.0083) bsdi.lll4 &gt; svr4.discard: udp 14723 50.449704 (29.4414) bsdi.lll6 &gt; svr4.discard: udp 1473 (frag 26304:1480@0+)4 50.450040 ( 0.0003) bsdi &gt; svr4: (frag 26304:l@1480)5 75.328650 (24.8786) bsdi.1118 &gt; svr4.discard: udp 1474 (frag 26313:1480@0+)6 75.328982 ( 0.0003) bsdi &gt; svr4: (frag 26313:2@1480) 前两份UDP数据报（第1行和第2行）能装入以太网数据帧，没有被分片。但是对应于写1473字节的IP数据报长度为1501，就必须进行分片（第3行和第4行）。同理，写1474字节产生的数据报长度为1502，它也需要进行分片（第5行和第6行）。 当IP数据报被分片后，tcpdump打印出其他的信息。首先，frag 26304（第3行和第4行）和frag 26313（第5行和第6行）指的是IP首部中标识字段的值。 分片信息中的下一个数字，即第3行中位于冒号和@号之间的1480，是除IP首部外的片长。两份数据报第一片的长度均为1480：UDP首部占8字节，用户数据占1472字节（加上IP首部的20字节分组长度正好为1500字节）。第1份数据报的第2片（第4行）只包含1字节数据—剩下的用户数据。第2份数据报的第2片（第6行）包含剩下的2字节用户数据。 在分片时，除最后一片外，其他每一片中的数据部分（除IP首部外的其余部分）必须是8字节的整数倍。在本例中，1480是8的整数倍。 位于@符号后的数字是从数据报开始处计算的片偏移值。两份数据报第1片的偏移值均为0(第3行和第5行)，第2片的偏移值为1480（第4行和第6行）。跟在偏移值后面的加号对应于IP首部中3bit标志字段中的“更多片”比特。设置这一比特的目的是让接收端知道在什么时候完成所有的分片组装。 最后，注意第4行和第6行（不是第1片）省略了协议名（UDP）、源端口号和目的端口号。协议名是可以打印出来的，因为它在IP首部并被复制到各个片中。但是，端口号在UDP首部，只能在第1片中被发现。 发送的第3份数据报（用户数据为1473字节）分片情况如下所示。需要重申的是，任何运输层首部只出现在第1片数据中。 另外需要解释几个术语：IP数据报是指IP层端到端的传输单元（在分片之前和重新组装之后），分组是指在IP层和链路层之间传送的数据单元。一个分组可以是一个完整的IP数据报，也可以是IP数据报的一个分片。 ICMP 不可达差错（需要分片）发生ICMP不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在IP首部又设置了不分片（DF）的标志比特。如果某个程序需要判断到达目的端的路途中最小MTU是多少—称作路径MTU发现机制，那么这个差错就可以被该程序使用。 ICMP不可达差错报文格式如下所示，这里的格式与普通的ICMP不可达报文格式有所不同。因为在第2个32 bit字中，16~31 bit可以提供下一站的MTU，而不再是0。 如果路由器没有提供这种新的ICMP差错报文格式，那么下一站的MTU就设为0。 新版的路由器需求RFC[Almquist 1993]声明，在发生这种ICMP不可达差错时，路由器必须生成这种新格式的报文。 UDP 和 ARP 之间的交互作用使用UDP，可以看到UDP与ARP典型实现之间的有趣的（而常常未被人提及）交互作用。 我们用sock程序来产生一个包含8192字节数据的UDP数据报。预测这将会在以太网上产生6个数据报片。同时也确保在运行该程序前，ARP缓存是清空的，这样，在发送第一个数据报片前必须交换ARP请求和应答。 12bsdi % arp -a #验证ARP高速缓存是空的bsdi % sock -u -i -nl -w8192 svr4 discard 预计在发送第一个数据报片前会先发送一个ARP请求。IP还会产生5个数据报片，这样就提出了我们必须用tcpdump来回答的两个问题：在接收到ARP回答前，其余数据报片是否已经做好了发送准备？如果是这样，那么在ARP等待应答时，它会如何处理发往给定目的的多个报文？ 12345678910111213141 0.0 arp who-has svr4 tell bsdi2 0.001234 (0.0012) arp who-has svr4 tell bsdi3 0.001941 (0.0007) arp who-has svr4 tell bsdi4 0.002775 (0.0008) arp who-has svr4 tell bsdi5 0.003495 (0.0007) arp who-has svr4 tell bsdi6 0.004319 (0.0008) arp who-has svr4 tell bsdi7 0.008772 (0.0045) arp reply svr4 is-at 0:0:c0:c2:9b:268 0.009911 (0.0011) arp reply svr4 is-at 0:0:c0:c2:9b:269 0.011127 (0.0012) bsdi &gt; svr4: (frag 10863:800@7400)10 0.011255 (0.0001) arp reply svr4 is-at 0:0:c0:c2:9b:2611 0.012562 (0.0013) arp reply svr4 is-at 0:0:c0:c2:9b:2612 0.013458 (0.0009) arp reply svr4 is-at 0:0:c0:c2:9b:2613 0.014526 (0.0011) arp reply svr4 is-at 0:0:c0:c2:9b:2614 0.015583 (0.0011) arp reply svr4 is-at 0:0:c0:c2:9b:26 在这个输出结果中有一些令人吃惊的结果。首先，在第一个ARP应答返回以前，总共产生了6个ARP请求。我们认为其原因是IP很快地产生了6个数据报片，而每个数据报片都引发了一个ARP请求。 第二，在接收到第一个ARP应答时（第7行），只发送最后一个数据报片（第9行）！看来似乎将前5个数据报片全都丢弃了。实际上，这是ARP的正常操作。在大多数的实现中，在等待一个ARP应答时，只将最后一个报文发送给特定目的主机。 Host Requirements RFC要求实现中必须防止这种类型的ARP洪泛（ARP flooding，即以高速率重复发送到同一个IP地址的ARP请求）。建议最高速率是每秒一次。而这里却在4.3ms内发出了6个ARP请求。 Host Requirements RFC规定，ARP应该保留至少一个报文，而这个报文必须是最后一个报文。这正是我们在这里所看到的结果。 另一个无法解释的不正常的现象是，svr4发回7个，而不是6个ARP应答。 最后要指出的是，在最后一个ARP应答返回后，继续运行tcpdump程序5分钟，以看看svr4是否会返回ICMP“组装超时”差错。并没有发送ICMP差错。 在第一个数据报片出现时，IP层必须启动一个定时器。这里“第一个”表示给定数据报的第一个到达数据报片，而不是第一个数据报片（数据报片偏移为0）。正常的定时器值为30或60秒。如果定时器超时而该数据报的所有数据报片未能全部到达，那么将这些数据报片丢弃。如果不这么做，那些永远不会到达的数据报片（正如我们在本例中所看到的那样）迟早会引起接收端缓存满。 这里我们没看到ICMP消息的原因有两个。首先，大多数从Berkeley派生的实现从不产生该差错！这些实现会设置定时器，也会在定时器溢出时将数据报片丢弃，但是不生成ICMP差错。第二，并未接收到包含UDP首部的偏移量为0的第一个数据报片（这是被ARP所丢弃的5个报文的第1个）。除非接收到第一个数据报片，否则并不要求任何实现产生ICMP差错。其原因是因为没有运输层首部，ICMP差错的接收者无法区分出是哪个进程所发送的数据报被丢弃。这里假设上层（TCP或使用UDP的应用程序）最终会超时并重传。 在本节中，我们使用IP数据报片来查看UDP与ARP之间的交互作用。如果发送端迅速发送多个UDP数据报，也可以看到这个交互过程。我们选择采用分片的方法，是因为IP可以生成报文的速度，比一个用户进程生成多个数据报的速度更快。 尽管本例看来不太可能，但它确实经常发生。NFS发送的UDP数据报长度超过8192字节。在以太网上，这些数据报以我们所指出的方式进行分片，如果适当的ARP缓存入口发生超时，那么就可以看到这里所显示的现象。NFS将超时并重传，但是由于ARP的有限队列，第一个IP数据报仍可能被丢弃。 最大 UDP 数据报长度理论上，IP数据报的最大长度是65535字节，这是由IP首部16比特总长度字段所限制的。去除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最长长度为65507字节。但是，大多数实现所提供的长度比这个最大值小。 我们将遇到两个限制因素。第一，应用程序可能会受到其程序接口的限制。socket API提供了一个可供应用程序调用的函数，以设置接收和发送缓存的长度。对于UDP socket，这个长度与应用程序可以读写的最大UDP数据报的长度直接相关。现在的大部分系统都默认提供了可读写大于8192字节的UDP数据报（使用这个默认值是因为8192是NFS读写用户数据数的默认值）。 第二个限制来自于TCP/IP的内核实现。可能存在一些实现特性（或差错），使IP数据报长度小于65535字节。 主机必须能够接收最短为576字节的IP数据报。在许多UDP应用程序的设计中，其应用程序数据被限制成512字节或更小，因此比这个限制值小。例如，路径信息协议总是发送每份数据报小于512字节的数据。我们还会在其他UDP应用程序如DNS、TFTP、BOOTP以及SNMP中遇到这个限制。 数据报截断 由于IP能够发送或接收特定长度的数据报并不意味着接收应用程序可以读取该长度的数据。因此，UDP编程接口允许应用程序指定每次返回的最大字节数。如果接收到的数据报长度大于应用程序所能处理的长度，那么会发生什么情况呢？ 不幸的是，该问题的答案取决于编程接口和实现。 典型的Berkeley版socket API对数据报进行截断，并丢弃任何多余的数据。应用程序何时能够知道，则与版本有关（4.3BSD Reno及其后的版本可以通知应用程序数据报被截断）。SVR4下的socket API(包括Solaris 2.x)并不截断数据报。超出部分数据在后面的读取中返回。它也不通知应用程序从单个UDP数据报中多次进行读取操作。TLI API不丢弃数据。相反，它返回一个标志表明可以获得更多的数据，而应用程序后面的读操作将返回数据报的其余部分。 TCP为应用程序提供连续的字节流，而没有任何信息边界。TCP以应用程序读操作时所要求的长度来传送数据，因此，在这个接口下，不会发生数据丢失。 ICMP 源站抑制差错我们同样也可以使用UDP产生ICMP“源站抑制(source quench)”差错。当一个系统（路由器或主机）接收数据报的速度比其处理速度快时，可能产生这个差错。注意限定词“可能”。即使一个系统已经没有缓存并丢弃数据报，也不要求它一定要发送源站抑制报文。 尽管RFC 1009 [Braden and Postel 1987]要求路由器在没有缓存时产生源站抑制差错报文，但是新的Router Requirements RFC [Almquist 1993]对此作了修改，提出路由器不应该产生源站抑制差错报文。由于源站抑制要消耗网络带宽，且对于拥塞来说是一种无效而不公平的调整，因此现在人们对于源站抑制差错的态度是不支持的。 UDP 服务器的设计使用UDP的一些蕴含对于设计和实现服务器会产生影响。通常，客户端的设计和实现比服务器端的要容易一些，这就是我们为什么要讨论服务器的设计，而不是讨论客户端的设计的原因。典型的服务器与操作系统进行交互作用，而且大多数需要同时处理多个客户。 通常一个客户启动后直接与单个服务器通信，然后就结束了。而对于服务器来说，它启动后处于休眠状态，等待客户请求的到来。对于UDP来说，当客户数据报到达时，服务器苏醒过来，数据报中可能包含来自客户的某种形式的请求消息。 在这里我们所感兴趣的并不是客户和服务器的编程方面（[Stevens 1990]对这些方面的细节进行了讨论），而是UDP那些影响使用该协议的服务器的设计和实现方面的协议特性。尽管我们所描述的一些特性取决于所使用UDP的实现，但对于大多数实现来说，这些特性是公共的。 客户IP地址及端口号来自客户的是UDP数据报。IP首部包含源端和目的端IP地址，UDP首部包含了源端和目的端的UDP端口号。当一个应用程序接收到UDP数据报时，操作系统必须告诉它是谁发送了这份消息，即源IP地址和端口号。 这个特性允许一个交互UDP服务器对多个客户进行处理。给每个发送请求的客户发回应答。 目的IP地址一些应用程序需要知道数据报是发送给谁的，即目的IP地址。例如，Host Requirements RFC规定，TFTP服务器必须忽略接收到的发往广播地址的数据报。 这要求操作系统从接收到的UDP数据报中将目的IP地址交给应用程序。不幸的是，并非所有的实现都提供这个功能。 UDP输入队列大多数UDP服务器是交互服务器。这意味着，单个服务器进程对单个UDP端口上（服务器上的名知端口）的所有客户请求进行处理。 通常程序所使用的每个UDP端口都与一个有限大小的输入队列相联系。这意味着，来自不同客户的差不多同时到达的请求将由UDP自动排队。接收到的UDP数据报以其接收顺序交给应用程序（在应用程序要求交送下一个数据报时）。 然而，排队溢出造成内核中的UDP模块丢弃数据报的可能性是存在的。 UDP输出队列是FIFO（先进先出）的，而ARP输入却是LIFO（后进先出）的。 限制本地IP地址大多数UDP服务器在创建UDP端点时都使其本地IP地址具有通配符(wildcard)的特点。这就表明进入的UDP数据报如果其目的地为服务器端口，那么在任何本地接口均可接收到它。 有可能在相同的端口上启动不同的服务器，每个服务器具有不同的本地IP地址。但是，一般必须告诉系统应用程序重用相同的端口号没有问题。 使用sockets API时，必须指定SO_REUSEADDR socket选项。 限制远端IP地址大多数系统允许UDP端点对远端地址进行限制。 每个端口有多个接收者尽管在RFC中没有指明，但大多数的系统在某一时刻只允许一个程序端点与某个本地IP地址及UDP端口号相关联。当目的地为该IP地址及端口号的UDP数据报到达主机时，就复制一份传给该端点。 在一个支持多播的系统上，这种情况将发生变化。多个端点可以使用同一个IP地址和UDP端口号，尽管应用程序通常必须告诉API是可行的。 4.4BSD支持多播传送，需要应用程序设置一个不同的socket选项（SO_REUSEPORT）以允许多个端点共享同一个端口。另外，每个端点必须指定这个选项，包括使用该端口的第一个端点。 当UDP数据报到达的目的IP地址为广播地址或多播地址，而且在目的IP地址和端口号处有多个端点时，就向每个端点传送一份数据报的复制。但是，如果UDP数据报到达的是一个单播地址，那么只向其中一个端点传送一份数据报的复制。选择哪个端点传送数据取决于各个不同的系统实现。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>ARP</tag>
        <tag>UDP</tag>
        <tag>ICMP</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) 动态选路协议]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F08%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-dynamic-routing-protocols%2F</url>
    <content type="text"><![CDATA[静态选路：在配置接口时，以默认方式生成路由表项（对于直接连接的接口），并通过route命令增加表项（通常从系统自引导程序文件），或是通过ICMP重定向生成表项（通常是在默认方式出错的情况下）。 在网络很小，且与其他网络只有单个连接点且没有多余路由时（若主路由失败，可以使用备用路由），采用这种方法是可行的。如果上述三种情况不能全部满足，通常使用动态选路。 动态选路当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时就出现了动态选路。路由器之间必须采用选路协议进行通信，这样的选路协议有很多种。路由器上有一个进程称为路由守护程序（routing daemon），它运行选路协议，并与其相邻的一些路由器进行通信。路由守护程序根据它从相邻路由器接收到的信息，更新内核中的路由表。 动态选路并不改变内核在IP层的选路方式。这种选路方式称为选路机制（routing mechanism）。内核搜索路由表，查找主机路由、网络路由以及默认路由的方式并没有改变。仅仅是放置到路由表中的信息改变了—当路由随时间变化时，路由是由路由守护程序动态地增加或删除，而不是来自于自引导程序文件中的route命令。 路由守护程序将选路策略（routing policy）加入到系统中，选择路由并加入到内核的路由表中。如果守护程序发现前往同一信宿存在多条路由，那么它（以某种方法）将选择最佳路由并加入内核路由表中。如果路由守护程序发现一条链路已经断开（可能是路由器崩溃或电话线路不好），它可以删除受影响的路由或增加另一条路由以绕过该问题。 在像Internet这样的系统中，目前采用了许多不同的选路协议。Internet是以一组自治系统(AS，Autonomous System)的方式组织的，每个自治系统通常由单个实体管理。常常将一个公司或大学校园定义为一个自治系统。NSFNET的Internet骨干网形成一个自治系统，这是因为骨干网中的所有路由器都在单个的管理控制之下。 每个自治系统可以选择该自治系统中各个路由器之间的选路协议。这种协议我们称之为内部网关协议IGP（Interior Gateway Protocol）或域内选路协议（intradomain routing protocol）。最常用的IGP是选路信息协议RIP。一种新的IGP是开放最短路径优先OSPF（Open Shortest Path First）协议。它意在取代RIP。另一种1986年在原来NSFNET骨干网上使用的较早的IGP协议——HELLO，现在已经不用了。 外部网关协议EGP（Exterier Gateway Protocol）或域内选路协议的分隔选路协议用于不同自治系统之间的路由器。在历史上，（令人容易混淆）改进的EGP有着一个与它名称相同的协议：EGP。新EGP是当前在NSFNET骨干网和一些连接到骨干网的区域性网络上使用的是边界网关协议BGP（Border Gateway Protocol）。BGP意在取代EGP。 Unix 选路守护程序Unix系统上常常运行名为routed路由守护程序。几乎在所有的TCP/IP实现中都提供该程序。该程序只使用RIP进行通信。这是一种用于小型到中型网络中的协议。 另一个程序是gated。IGP和EGP都支持它。[Fedor 1998]描述了早期开发的gated。大多数运行路由守护程序的系统都可以运行routed，除非它们需要支持gated所支持的其他协议。 守护程序 HELLO(IGP) RIP(IGP) OSPF(IGP) EGP(EGP) BGP(EGP) routed V1 gated, 版本2 * V1 * V1 gated, 版本3 * V1,V2 V2 * V2,V3 RIP: 选路信息协议报文格式RIP 报文包含在 UDP 数据报中：| IP首部(20字节) | UDP首部(8字节) | RIP报文 | 命令字段为1表示请求，2表示应答。还有两个舍弃不用的命令（3和4），两个非正式的命令：轮询（5）和轮询表项（6）。请求表示要求其他系统发送其全部或部分路由表。应答则包含发送者全部或部分路由表。 版本字段通常为1，而第2版RIP将此字段设置为2。 紧跟在后面的20字节指定地址系列（address family）（对于IP地址来说，其值是2）、IP地址以及相应的度量。RIP的度量是以跳计数的。 采用这种20字节格式的RIP报文可以通告多达25条路由。上限25是用来保证RIP报文的总长度为20×25+4=504，小于512字节。由于每个报文最多携带25个路由，因此为了发送整个路由表，经常需要多个报文。 正常运行RIP常用的UDP端口号是520。 初始化：在启动一个路由守护程序时，它先判断启动了哪些接口，并在每个接口上发送一个请求报文，要求其他路由器发送完整路由表。在点对点链路中，该请求是发送给其他终点的。如果网络支持广播的话，这种请求是以广播形式发送的。目的UDP端口号是520（这是其他路由器的路由守护程序端口号）。 这种请求报文的命令字段为1，但地址系列字段设置为0，而度量字段设置为16。这是一种要求另一端完整路由表的特殊请求报文。 接收到请求。如果这个请求是刚才提到的特殊请求，那么路由器就将完整的路由表发送给请求者。否则，就处理请求中的每一个表项：如果有连接到指明地址的路由，则将度量设置成我们的值，否则将度量置为16（度量为16是一种称为“无穷大”的特殊值，它意味着没有到达目的的路由）。然后发回响应。 接收到响应。使响应生效，可能会更新路由表。可能会增加新表项，对已有的表项进行修改，或是将已有表项删除。 定期选路更新。每过30秒，所有或部分路由器会将其完整路由表发送给相邻路由器。发送路由表可以是广播形式的（如在以太网上），或是发送给点对点链路的其他终点的。 触发更新。每当一条路由的度量发生变化时，就对它进行更新。不需要发送完整路由表，而只需要发送那些发生变化的表项。 每条路由都有与之相关的定时器。如果运行RIP的系统发现一条路由在3分钟内未更新，就将该路由的度量设置成无穷大（16），并标注为删除。这意味着已经在6个30秒更新时间里没收到通告该路由的路由器的更新了。再过60秒，将从本地路由表中删除该路由，以保证该路由的失效已被传播开。 度量RIP所使用的度量是以跳(hop)计算的。所有直接连接接口的跳数为1。 路由器R1通过发送广播到N1通告它与N2之间的跳数是1(发送给N1的广播中通告它与N1之间的路由是无用的)。同时也通过发送广播给N2通告它与N1之间的跳数为1。同样，R2通告它与N2的度量为1，与N3的度量为1。 如果相邻路由器通告它与其他网络由的跳数为1，那么我们与那个网络的度量就是2，这是因为为了发送报文到该网络，我们必须经过那个路由器。在我们的例子中，R2到N1的度量是2，与R1到N3的度量一样。 由于每个路由器都发送其路由表给邻站，因此，可以判断在同一个自治系统AS内到每个网络的路由。如果在该AS内从一个路由器到一个网络有多条路由，那么路由器将选择跳数最小的路由，而忽略其他路由。 跳数的最大值是15，这意味着RIP只能用在主机间最大跳数值为15的AS内。度量为16表示到无路由到达该IP地址。 问题这种方法看起来很简单，但它有一些缺陷。首先，RIP没有子网地址的概念。例如，如果标准的B类地址中16 bit的主机号不为0，那么RIP无法区分非零部分是一个子网号，或者是一个主机地址。有一些实现中通过接收到的RIP信息，来使用接口的网络掩码，而这有可能出错。 其次，在路由器或链路发生故障后，需要很长的一段时间才能稳定下来。这段时间通常需要几分钟。在这段建立时间里，可能会发生路由环路。在实现RIP时，必须采用很多微妙的措施来防止路由环路的出现，并使其尽快建立。RFC 1058 [Hedrick 1988a]中指出了很多实现RIP的细节。 采用跳数作为路由度量忽略了其他一些应该考虑的因素。同时，度量最大值为15则限制了可以使用RIP的网络的大小。 RIP 版本2RFC 1388 [Malkin 1993a]中对RIP定义进行了扩充，通常称其结果为RIP-2。这些扩充并不改变协议本身，而是利用版本1中的一些标注为“必须为0”的字段来传递一些额外的信息。如果RIP忽略这些必须为0的字段，那么，RIP和RIP-2可以互操作。 对于RIP-2来说，其版本字段为2。 选路域(routing domain)是一个选路守护程序的标识符，它指出了这个数据报的所有者。在一个Unix实现中，它可以是选路守护程序的进程号。该域允许管理者在单个路由器上运行多个RIP实例，每个实例在一个选路域内运行。 选路标记(routing tag)是为了支持外部网关协议而存在的。它携带着一个EGP和BGP的自治系统号。 每个表项的子网掩码应用于相应的IP地址上。下一站IP地址指明发往目的IP地址的报文该发往哪里。该字段为0意味着发往目的地址的报文应该发给发送RIP报文的系统。 RIP-2提供了一种简单的鉴别机制。可以指定RIP报文的前20字节表项地址系列为0xffff，路由标记为2。表项中的其余16字节包含一个明文口令。 最后，RIP-2除了广播外，还支持多播。这可以减少不收听RIP-2报文的主机的负载。 OSPF: 开放最短路径优先OSPF是除RIP外的另一个内部网关协议。它克服了RIP的所有限制。RFC 1247[Moy 1991]中对第2版OSPF进行了描述。 与采用距离向量的RIP协议不同的是，OSPF是一个链路状态协议。距离向量的意思是，RIP发送的报文包含一个距离向量（跳数）。每个路由器都根据它所接收到邻站的这些距离向量来更新自己的路由表。 在一个链路状态协议中，路由器并不与其邻站交换距离信息。它采用的是每个路由器主动地测试与其邻站相连链路的状态，将这些信息发送给它的其他邻站，而邻站将这些信息在自治系统中传播出去。每个路由器接收这些链路状态信息，并建立起完整的路由表。 从实际角度来看，二者的不同点是链路状态协议总是比距离向量协议收敛更快。收敛的意思是在路由发生变化后，例如在路由器关闭或链路出故障后，可以稳定下来。 OSPF与RIP（以及其他选路协议）的不同点在于，OSPF直接使用IP。也就是说，它并不使用UDP或TCP。对于IP首部的protocol字段，OSPF有其自己的值。 另外，作为一种链路状态协议而不是距离向量协议，OSPF还有着一些优于RIP的特点。 OSPF可以对每个IP服务类型计算各自的路由集。这意味着对于任何目的，可以有多个路由表表项，每个表项对应着一个IP服务类型。 给每个接口指派一个无维数的费用。可以通过吞吐率、往返时间、可靠性或其他性能来进行指派。可以给每个IP服务类型指派一个单独的费用。 当对同一个目的地址存在着多个相同费用的路由时，OSPF在这些路由上平均分配流量。我们称之为流量平衡。 OSPF支持子网：子网掩码与每个通告路由相连。这样就允许将一个任何类型的IP地址分割成多个不同大小的子网（变长度子网）。到一个主机的路由是通过全1子网掩码进行通告的。默认路由是以IP地址为0.0.0.0、网络掩码为全0进行通告的。 路由器之间的点对点链路不需要每端都有一个IP地址，我们称之为无编号网络。这样可以节省IP地址—现在非常紧缺的一种资源。 采用了一种简单鉴别机制。可以采用类似于RIP-2机制的方法指定一个明文口令。 OSPF采用多播，而不是广播形式，以减少不参与OSPF的系统负载。 随着大部分厂商支持OSPF，在很多网络中OSPF将逐步取代RIP。 BGP: 边界网关协议BGP是一种不同自治系统的路由器之间进行通信的外部网关协议。BGP是ARPANET所使用的老EGP的取代品。RFC1267 [Lougheed and Rekhter 1991]对第3版的BGP进行了描述。 BGP系统与其他BGP系统之间交换网络可到达信息。这些信息包括数据到达这些网络所必须经过的自治系统AS中的所有路径。这些信息足以构造一幅自治系统连接图。然后，可以根据连接图删除选路环，制订选路策略。 首先，我们将一个自治系统中的IP数据报分成本地流量和通过流量。在自治系统中，本地流量是起始或终止于该自治系统的流量。也就是说，其信源IP地址或信宿IP地址所指定的主机位于该自治系统中。其他的流量则称为通过流量。在Internet中使用BGP的一个目的就是减少通过流量。 可以将自治系统分为以下几种类型： 残桩自治系统(stub AS)，它与其他自治系统只有单个连接。stub AS只有本地流量。 多接口自治系统(multihomed AS)，它与其他自治系统有多个连接，但拒绝传送通过流量。 转送自治系统(transit AS)，它与其他自治系统有多个连接，在一些策略准则之下，它可以传送本地流量和通过流量。 这样，可以将Internet的总拓扑结构看成是由一些残桩自治系统、多接口自治系统以及转送自治系统的任意互连。残桩自治系统和多接口自治系统不需要使用BGP——它们通过运行EGP在自治系统之间交换可到达信息。 BGP允许使用基于策略的选路。由自治系统管理员制订策略，并通过配置文件将策略指定给BGP。制订策略并不是协议的一部分，但指定策略允许BGP实现在存在多个可选路径时选择路径，并控制信息的重发送。选路策略与政治、安全或经济因素有关。 BGP与RIP和OSPF的不同之处在于BGP使用TCP作为其传输层协议。两个运行BGP的系统之间建立一条TCP连接，然后交换整个BGP路由表。从这个时候开始，在路由表发生变化时，再发送更新信号。 BGP是一个距离向量协议，但是与（通告到目的地址跳数的）RIP不同的是，BGP列举了到每个目的地址的路由（自治系统到达目的地址的序列号）。这样就排除了一些距离向量协议的问题。采用16 bit数字表示自治系统标识。 BGP通过定期发送keepalive报文给其邻站来检测TCP连接对端的链路或主机失败。两个报文之间的时间间隔建议值为30秒。应用层的keepalive报文与TCP的keepalive选项是独立的。 CIDR: 无类型域间选路由于B类地址的缺乏，因此现在的多个网络站点只能采用多个C类网络号，而不采用单个B类网络号。尽管分配这些C类地址解决了一个问题（B类地址的缺乏），但它却带来了另一个问题：每个C类网络都需要一个路由表表项。无类型域间选路（CIDR）是一个防止Internet路由表膨胀的方法，它也称为超网（supernetting）。 CIDR的基本观点是采用一种分配多个IP地址的方式，使其能够将路由表中的许多表项总和(summarization)成更少的数目。例如，如果给单个站点分配16个C类地址，以一种可以用总和的方式来分配这16个地址，这样，所有这16个地址可以参照Internet上的单个路由表表项。同时，如果有8个不同的站点是通过同一个Internet服务提供商的同一个连接点接入Internet的，且这8个站点分配的8个不同IP地址可以进行总和，那么，对于这8个站点，在Internet上，只需要单个路由表表项。 要使用这种总和，必须满足以下三种特性： 为进行选路要对多个IP地址进行总和时，这些IP地址必须具有相同的高位地址比特。 路由表和选路算法必须扩展成根据32 bit IP地址和32 bit掩码做出选路决策。 必须扩展选路协议使其除了32 bit地址外，还要有32 bit掩码。OSPF和RIP-2都能够携带第4版BGP所提出的32 bit掩码。 例如，RFC 1466 [Gerich 1993]建议欧洲新的C类地址的范围是194.0.0.0～195.255.255.255。以16进制表示，这些地址的范围是0xc2000000～0xc3ffffff。它代表了65536个不同的C类网络号，但它们地址的高7bit是相同的。在欧洲以外的国家里，可以采用IP地址为0xc2000000和32 bit 0xfe000000(254.0.0.0)为掩码的单个路由表表项来对所有这些65536个C类网络号选路到单个点上。C类地址的后面各比特位（即在194或195后面各比特）也可以进行层次分配，例如以国家或服务提供商分配，以允许对在欧洲路由器之间使用除了这32 bit掩码的高7bit外的其他比特进行概括。 CIDR同时还使用一种技术，使最佳匹配总是最长的匹配：即在32 bit掩码中，它具有最大值。我们继续采用上一段中所用的例子，欧洲的一个服务提供商可能会采用一个与其他欧洲服务提供商不同的接入点。如果给该提供商分配的地址组是从 194.0.16.0到 194.0.31.255(16个C类网络号)，那么可能只有这些网络的路由表项的IP地址是 194.0.16.0，掩码为 255.255.240.0(0xfffff 000)。发往194.0.22.1地址的数据报将同时与这个路由表表项和其他欧洲C类地址的表项进行匹配。但是由于掩码 255.255.240 比 254.0.0.0 更“长”，因此将采用具有更长掩码的路由表表项。 “无类型”的意思是现在的选路决策是基于整个32 bit IP地址的掩码操作，而不管其IP地址是A类、B类或是C类，都没有什么区别。 CIDR最初是针对新的C类地址提出的。这种变化将使Internet路由表增长的速度缓慢下来，但对于现存的选路则没有任何帮助。这是一个短期解决方案。作为一个长期解决方案，如果将CIDR应用于所有IP地址，并根据各洲边界和服务提供商对已经存在的IP地址进行重新分配（且所有现有主机重新进行编址！），那么[Ford, Rekhter, and Braun 1993]宣称，目前包含10 000网络表项的路由表将会减少成只有200个表项。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>RIP</tag>
        <tag>OSPF</tag>
        <tag>BGP</tag>
        <tag>CIDR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) IP选路]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F07%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-ip-routing%2F</url>
    <content type="text"><![CDATA[选路是IP最重要的功能之一。需要进行选路的数据报可以由本地主机产生，也可以由其他主机产生。在后一种情况下，主机必须配置成一个路由器，否则通过网络接口接收到的数据报，如果目的地址不是本机就要被丢弃（例如，悄无声息地被丢弃）。 选路的原理IP搜素路由表的步骤： 搜索匹配的主机地址； 搜索匹配的网络地址； 搜索默认表项（默认表项一般在路由表中被指定为一个网络表项，其网络号为0）。 匹配主机地址步骤始终发生在匹配网络地址步骤之前。 IP层进行的选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。这区别于选路策略，它只是一组决定把哪些路由放入路由表的规则。IP执行选路机制，而路由守护程序则一般提供选路策略。 简单路由表1234567svr4 % netstat -rnRouting tablesDestination Gateway Flags Refcnt Use Interface140.252.13.65 140.252.13.35 UGH 0 0 emd0127.0.0.1 127.0.0.1 UH 1 0 lo0default 140.252.13.33 UG 0 0 emd0140.252.13.32 140.252.13.34 U 4 25043 emd0 第1行说明，如果目的地是140.252.13.65（slip主机），那么网关（路由器）将把分组转发给140.252.13.35（bsdi）。这正是我们所期望的，因为主机slip通过SLIP链路与bsdi相连接，而bsdi与该主机在同一个以太网上。 对于一个给定的路由器，可以打印出五种不同的标志（flag）：U 该路由可以使用。G 该路由是到一个网关（路由器）。如果没有设置该标志，说明目的地是直接相连的。H 该路由是到一个主机，也就是说，目的地址是一个完整的主机地址。如果没有设置该标志，说明该路由是到一个网络，而目的地址是一个网络地址：一个网络号，或者网络号与子网号的组合。D 该路由是由重定向报文创建的。M 该路由已被重定向报文修改。 标志G是非常重要的，因为由它区分了间接路由和直接路由（对于直接路由来说是不设置标志G的）。其区别在于，发往直接路由的分组中不但具有指明目的端的IP地址，还具有其链路层地址。当分组被发往一个间接路由时，IP地址指明的是最终的目的地，但是链路层地址指明的是网关（即下一站路由器）。在这个路由表例子中，有一个间接路由（设置了标志G），因此采用这一项路由的分组其IP地址是最终的目的地（140.252.13.65），但是其链路层地址必须对应于路由器140.252.13.35。 理解G和H标志之间的区别是很重要的。G标志区分了直接路由和间接路由，如上所述。但是H标志表明，目的地址（netstat命令输出第一行）是一个完整的主机地址。没有设置H标志说明目的地址是一个网络地址（主机号部分为0）。当为某个目的IP地址搜索路由表时，主机地址项必须与目的地址完全匹配，而网络地址项只需要匹配目的地址的网络号和子网号就可以了。另外，大多数版本的netstat命令首先打印出所有的主机路由表项，然后才是网络路由表项。 参考记数Refcnt（Reference count）列给出的是正在使用路由的活动进程个数。面向连接的协议如TCP在建立连接时要固定路由。如果在主机svr4和slip之间建立Telnet连接，可以看到参考记数值变为1。建立另一个Telnet连接时，它的值将增加为2，依此类推。 下一列（“use”）显示的是通过该路由发送的分组数。如果我们是这个路由的唯一用户，那么运行ping程序发送5个分组后，它的值将变为5。最后一列（interface）是本地接口的名字。 输出的第2行是环回接口，它的名字始终为lo0。没有设置G标志，因为该路由不是一个网关。H标志说明目的地址（127.0.0.1）是一个主机地址，而不是一个网络地址。由于没有设置G标志，说明这是一个直接路由，网关列给出的是外出IP地址。 输出的第3行是默认路由。每个主机都有一个或多个默认路由。这一项表明，如果在表中没有找到特定的路由，就把分组发送到路由器140.252.13.33（sun主机）。这说明当前主机（svr4）利用这一个路由表项就可以通过Internet经路由器sun（及其SLIP链路）访问其他的系统。建立默认路由是一个功能很强的概念。该路由标志（UG）表明它是一个网关，这是我们所期望的。 这里，我们有意称sun为路由器而不是主机，因为它被当作默认路由器来使用，它发挥的是IP转发功能，而不是主机功能。 输出中的最后一行是所在的以太网。H标志没有设置，说明目的地址（140.252.13.32）是一个网络地址，其主机地址部分设为0。事实上，是它的低5位设为0。由于这是一个直接路由（G标志没有被设置），网关列指出的IP地址是外出地址。 netstat命令输出的最后一项还隐含了另一个信息，那就是目的地址（140.252.13.32）的子网掩码。如果要把该目的地址与140.252.13.33进行比较，那么在比较之前首先要把它与目的地址掩码(0xffffe0)进行逻辑与。由于内核知道每个路由表项对应的接口，而且每个接口都有一个对应的子网掩码，因此每个路由表项都有一个隐含的子网掩码。 主机路由表的复杂性取决于主机所在网络的拓扑结构。 最简单的（也是最不令人感兴趣的）情况是主机根本没有与任何网络相连。TCP/IP协议仍然能用于这样的主机，但是只能与自己本身通信！这种情况下的路由表只包含环回接口一项。 接下来的情况是主机连在一个局域网上，只能访问局域网上的主机。这时路由表包含两项：一项是环回接口，另一项是局域网（如以太网）。 如果主机能够通过单个路由器访问其他网络（如Internet）时，那么就要进行下一步。一般情况下增加一个默认表项指向该路由器。 如果要新增其他的特定主机或网络路由，那么就要进行最后一步。在我们的例子中，到主机slip的路由要通过路由器bsdi就是这样的例子。 我们根据上述IP操作的步骤使用这个路由表为主机svr4上的一些分组例子选择路由。 假定目的地址是主机sun，140.252.13.33。首先进行主机地址的匹配。路由表中的两个主机地址表项（slip和localhost）均不匹配，接着进行网络地址匹配。这一次匹配成功，找到表项140.252.13.32（网络号和子网号都相同），因此使用emd0接口。这是一个直接路由，因此链路层地址将是目的端的地址。 假定目的地址是主机slip，140.252.13.65。首先在路由表搜索主机地址，并找到一个匹配地址。这是一个间接路由，因此目的端的IP地址仍然是140.252.13.65，但是链路层地址必须是网关140.252.13.35的链路层地址，其接口名为emd0。 这一次我们通过Internet给主机aw.com（192.207.11 7.2）发送一份数据报。首先在路由表中搜索主机地址，失败后进行网络地址匹配。最后成功地找到默认表项。该路由是一个间接路由，通过网关140.252.13.33，并使用接口名为emd0。 在我们最后一个例子中，我们给本机发送一份数据报。有四种方法可以完成这件事，如用主机名、主机IP地址、环回名或者环回IP地址：ftp svr4ftp 140.252.13.34ftp localhostftp 127.0.0.1在前两种情况下，对路由表的第2次搜索得到一个匹配的网络地址140.252.13.32，并把IP报文传送给以太网驱动程序。IP报文中的目的地址为本机IP地址，因此报文被送给环回驱动程序，然后由驱动程序把报文放入IP输出队列中。在后两种情况下，由于指定了环回接口的名字或IP地址，第一次搜索就找到匹配的主机地址，因此报文直接被送给环回驱动程序，然后由驱动程序把报文放入IP输出队列中。上述四种情况报文都要被送给环回驱动程序，但是采用的两种路由决策是不相同的。 初始化路由表我们从来没有说过这些路由表是如何被创建的。每当初始化一个接口时（通常是用ifconfig命令设置接口地址），就为接口自动创建一个直接路由。对于点对点链路和环回接口来说，路由是到达主机（例如，设置H标志）。对于广播接口来说，如以太网，路由是到达网络。 到达主机或网络的路由如果不是直接相连的，那么就必须加入路由表。一个常用的方法是在系统引导时显式地在初始化文件中运行route命令。在主机svr4上，我们运行下面两个命令来添加路由表中的表项：route add default sun 1route add slip bsdi 1第3个参数（default和slip）代表目的端，第4个参数代表网关（路由器），最后一个参数代表路由的度量(metric)。route命令在度量值大于0时要为该路由设置G标志，否则，当耗费值为0时就不设置G标志。 不幸的是，几乎没有系统愿意在启动文件中包含route命令。在4.4BSD和BSD/386系统中，启动文件是/etc/netstart；在SVR4系统中，启动文件是/etc/inet/rc.inet；在Solaris 2.x中，启动文件是/etc/rc2.d/S69inet；在SunOS 4.1.x中，启动文件是/etc/rc.local；而AIX 3.2.2则使用文件/etc/rc.net。 一些系统允许在某个文件中指定默认的路由器，如/etc/defaultrouter。于是在每次重新启动系统时都要在路由表中加入该默认项。初始化路由表的其他方法是运行路由守护程序或者用较新的路由器发现协议。 较复杂的路由表在我们的子网上，主机sun是所有主机的默认路由器，因为它有拨号SLIP链路连接到Internet上。12345678sun % netstat -rnRouting tablesDestination Gateway Flags Refcnt Use Interface140.252.13.65 140.252.13.35 UGH 0 171 le0127.0.0.1 127.0.0.1 UH 1 766 lo0140.252.1.183 140.252.1.29 UH 0 0 sl0default 140.252.1.183 UG 1 2955 sl0140.252.13.32 140.252.13.33 U 8 99551 le0 前两项与主机svr4的前两项一致：通过路由器bsdi到达slip的特定主机路由，以及环回路由。 第3行是新加的。这是一个直接到达主机的路由(没有设置G标志，但设置了H标志)，对应于点对点的链路，即SLIP接口。如果我们把它与ifconfig命令的输出进行比较：123sun % ifconfig sl0sl0: flags=1051&lt;UP,POINTOPOINT,RUNNING&gt; inet 140.252.1.29 --&gt; 140.252.1.183 netmask ffffff00 可以发现路由表中的目的地址就是点对点链路的另一端(即路由器netb),网关地址为外出接口的本地IP地址(140.252.1.29)(前面已经说过,netstat为直接路由打印出来的网关地址就是本地接口所用的IP地址)。 默认的路由表项是一个到达网络的间接路由(设置了G标志，但没有设置H标志)，这正是我们所希望的。网关地址是路由器的地址(140.252.1.183，SLIP链路的另一端),而不是SLIP链路的本地IP地址(140.252.1.29)。其原因还是因为是间接路由，不是直接路由。 还应该指出的是，netstat输出的第3和第4行(接口名为sl0)由SLIP软件在启动时创建，并在关闭时删除。 没有到达目的地的路由我们所有的例子都假定对路由表的搜索能找到匹配的表项，即使匹配的是默认项。如果路由表中没有默认项，而又没有找到匹配项，这时会发生什么情况呢？ 结果取决于该IP数据报是由主机产生的还是被转发的（例如，我们就充当一个路由器）。如果数据报是由本地主机产生的，那么就给发送该数据报的应用程序返回一个差错，或者是“主机不可达差错”或者是“网络不可达差错”。如果是被转发的数据报，那么就给原始发送端发送一份ICMP主机不可达的差错报文。 ICMP 主机与网络不可达差错当路由器收到一份IP数据报但又不能转发时，就要发送一份ICMP“主机不可达”差错报文。可以很容易发现，在我们的网络上把接在路由器sun上的拨号SLIP链路断开，然后试图通过该SLIP链路发送分组给任何指定sun为默认路由器的主机。 我们在上一节通过在路由器sun上运行netstat命令可以看到，当接通SLIP链路启动时就要在路由表中增加一项使用SLIP链路的表项，而当断开SLIP链路时则删除该表项。这说明当SLIP链路断开时，sun的路由表中就没有默认项了。但是我们不想改变网络上其他主机的路由表，即同时删除它们的默认路由。相反，对于sun不能转发的分组，我们对它产生的ICMP主机不可达差错报文进行计数。 在主机svr4上运行ping程序就可以看到这一点，它在拨号SLIP链路的另一端（拨号链路已被断开）：1234svr4 % ping geminiICMP Host Unreachable from gateway sun (140.252.13.33)ICMP Host Unreachable from gateway sun (140.252.13.33)^? type interrupt key to stop 在主机bsdi上运行tcpdump命令的输出:12341 0.0 svr4 &gt; gemini: icmp: echo request2 0.00 (0.00) sun &gt; svr4: icmp: host gemini unreachable3 0.99 (0.99) svr4 &gt; gemini: icmp: echo request4 0.99 (0.00) sun &gt; svr4: icmp: host gemini unreachable 当路由器sun发现找不到能到达主机gemini的路由时，它就响应一个主机不可达的回显请求报文。 如果把SLIP链路接到Internet上，然后试图ping一个与Internet没有连接的IP地址，那么应该会产生差错。但令人感兴趣的是，我们可以看到在返回差错报文之前，分组要在Internet上传送多远：1234sun % ping 192.82.148.1PING 192.82.148.1: 56 data bytesICMP Host Unreachable from gateway enss142.UT.westnet.net (192.31.39.21) for icmp from sun (140.252.1.29) to 192.82.148.1 在发现该IP地址是无效的之前，该分组已通过了6个路由器。只有当它到达NSFNET骨干网的边界时才检测到差错。这说明，6个路由器之所以能转发分组是因为路由表中有默认项。只有当分组到达NSFNET骨干网时，路由器才能知道每个连接到Internet上的每个网络的信息。这说明许多路由器只能在局部范围内工作。 参考文献[Ford, Rekhter, and Braun 1993]定义了顶层选路域（top-level routing domain），由它来维护大多数Internet网站的路由信息，而不使用默认路由。他们指出，在Internet上存在5个这样的顶层选路域：NSFNET主干网、商业互联网交换（Commercial Internet Exchange: CIX）、NASA科学互联网（NASA Science Internet: NSI）、SprintLink以及欧洲IP主干网（EBONE）。 转发或不转发一般都假定主机不转发IP数据报，除非对它们进行特殊配置而作为路由器使用。如何进行这样的配置呢？ 大多数伯克利派生出来的系统都有一个内核变量ipforwarding，或其他类似的名字（参见附录E）。一些系统（如BSD/386和SVR4）只有在该变量值不为0的情况下才转发数据报。SunOS 4.1.x允许该变量可以有三个不同的值：-1表示始终不转发并且始终不改变它的值；0表示默认条件下不转发，但是当打开两个或更多个接口时就把该值设为1；1表示始终转发。Solaris 2.x把这三个值改为0（始终不转发）、1（始终转发）和2（在打开两个或更多个接口时才转发）。 较早版本的4.2BSD主机在默认条件下可以转发数据报，这给没有进行正确配置的系统带来了许多问题。这就是内核选项为什么要设成默认的“始终不转发”的原因，除非系统管理员进行特殊设置。 ICMP 重定向差错 当IP数据报应该被发送到另一个路由器时，收到数据报的路由器就要发送ICMP重定向差错报文给IP数据报的发送端。这在概念上是很简单的，正如图所示的那样。只有当主机可以选择路由器发送分组的情况下，我们才可能看到ICMP重定向报文。 我们假定主机发送一份IP数据报给R1。这种选路决策经常发生，因为R1是该主机的默认路由。 R1收到数据报并且检查它的路由表，发现R2是发送该数据报的下一站。当它把数据报发送给R2时，R1检测到它正在发送的接口与数据报到达接口是相同的（即主机和两个路由器所在的LAN）。这样就给路由器发送重定向报文给原始发送端提供了线索。 R1发送一份ICMP重定向报文给主机，告诉它以后把数据报发送给R2而不是R1。 重定向一般用来让具有很少选路信息的主机逐渐建立更完善的路由表。主机启动时路由表中可以只有一个默认表项（在图所示的例子中，为R1或R2）。一旦默认路由发生差错，默认路由器将通知它进行重定向，并允许主机对路由表作相应的改动。ICMP重定向允许TCP/IP主机在进行选路时不需要具备智能特性，而把所有的智能特性放在路由器端。显然，在我们的例子中，R1和R2必须知道有关相连网络的更多拓扑结构的信息，但是连在LAN上的所有主机在启动时只需一个默认路由，通过接收重定向报文来逐步学习。 ICMP重定向报文的格式: 有四种不同类型的重定向报文，有不同的代码值: 代码 描述 0 网络重定向 1 主机重定向 2 服务类型和网络重定向 3 服务类型和主机重定向 ICMP重定向报文的接收者必须查看三个IP地址：(1)导致重定向的IP地址（即ICMP重定向报文的数据网络重定向主机重定向位于IP数据报的首部）；(2)发送重定向报文的路由器的IP地址（包含重定向信息的IP数据报中的源地址；(3)应该采用的路由器IP地址（在ICMP报文中的4~7字节）。 关于ICMP重定向报文有很多规则。首先，重定向报文只能由路由器生成，而不能由主机生成。另外，重定向报文是为主机而不是为路由器使用的。假定路由器和其他一些路由器共同参与某一种选路协议，则该协议就能消除重定向的需要（这意味着路由表应该消除或者能被选路守护程序修改，或者能被重定向报文修改，但不能同时被二者修改）。 在4.4BSD系统中，当主机作为路由器使用时，要进行下列检查。在生成ICMP重定向报文之前这些条件都要满足。 出接口必须等于入接口。 用于向外传送数据报的路由不能被ICMP重定向报文创建或修改过，而且不能是路由器的默认路由。 数据报不能用源站选路来转发。 内核必须配置成可以发送重定向报文。 另外，一台4.4BSD主机收到ICMP重定向报文后，在修改路由表之前要作一些检查。这是为了防止路由器或主机的误操作，以及恶意用户的破坏，导致错误地修改系统路由表。 新的路由器必须直接与网络相连接。 重定向报文必须来自当前到目的地所选择的路由器。 重定向报文不能让主机本身作为路由器。 被修改的路由必须是一个间接路由。 关于重定向最后要指出的是，路由器应该发送的只是对主机的重定向(代码1或3)，而不是对网络的重定向。子网的存在使得难于准确指明何时应发送对网络的重定向而不是对主机的重定向。只当路由器发送了错误的类型时，一些主机才把收到的对网络的重定向当作对主机的重定向来处理。 ICMP 路由器发现报文前面已提到过一种初始化路由表的方法，即在配置文件中指定静态路由。这种方法经常用来设置默认路由。另一种新的方法是利用ICMP路由器通告和请求报文。 一般认为，主机在引导以后要广播或多播传送一份路由器请求报文。一台或更多台路由器响应一份路由器通告报文。另外，路由器定期地广播或多播传送它们的路由器通告报文，允许每个正在监听的主机相应地更新它们的路由表。 ICMP 路由器请求报文格式： ICMP 路由器通告报文格式： 接下来是一对或多对IP地址和优先级。IP地址必须是发送路由器的某个地址。优先级是一个有符号的32 bit整数，指出该IP地址作为默认路由器地址的优先等级，这是与子网上的其他路由器相比较而言的。值越大说明优先级越高。优先级为0x80000000说明对应的地址不能作为默认路由器地址使用，尽管它也包含中通告报文中。优先级的默认值一般为0。 路由器操作当路由器启动时，它定期在所有广播或多播传送接口上发送通告报文。准确地说，这些通告报文不是定期发送的，而是随机传送的，以减小与子网上其他路由器发生冲突的概率。一般每两次通告间隔450秒和600秒。一份给定的通告报文默认生命周期是30分钟。 使用生命周期域的另一个时机是当路由器上的某个接口被关闭时。在这种情况下，路由器可以在该接口上发送最后一份通告报文，并把生命周期值设为0。 除了定期发送主动提供的通告报文以外，路由器还要监听来自主机的请求报文，并发送路由器通告报文以响应这些请求报文。 如果子网上有多台路由器，由系统管理员为每个路由器设置优先等级。例如，主默认路由器就要比备份路由器具有更高的优先级。 主机操作主机在引导期间一般发送三份路由器请求报文，每三秒钟发送一次。一旦接收到一个有效的通告报文，就停止发送请求报文。 主机也监听来自相邻路由器的通告报文。这些通告报文可以改变主机的默认路由器。另外，如果没有接收到来自当前默认路由器的通告报文，那么默认路由器会超时。 只要有一般的默认路由器，该路由器就会每隔10分钟发送通告报文，报文的生命周期是30分钟。这说明主机的默认表项是不会超时的，即使错过一份或两份通告报文。 实现路由器发现报文一般由用户进程（守护程序）创建和处理。守护程序必须把它配置成一台路由器或主机来使用。 小结IP路由操作对于运行TCP/IP的系统来说是最基本的，不管是主机还是路由器。路由表项的内容很简单，包括：5bit标志、目的IP地址（主机、网络或默认）、下一站路由器的IP地址（间接路由）或者本地接口的IP地址（直接路由）及指向本地接口的指针。主机表项比网络表项具有更高的优先级，而网络表项比默认项具有更高的优先级。 系统产生的或转发的每份IP数据报都要搜索路由表，它可以被路由守护程序或ICMP重定向报文修改。系统在默认情况下不转发数据报，除非进行特殊的配置。用route命令可以进入静态路由，可以利用新ICMP路由器发现报文来初始化默认表项，并进行动态修改。主机在启动时只有一个简单的路由表，它可以被来自默认路由器的ICMP重定向报文动态修改。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>IP选路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) Traceroute程序]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F04%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-traceroute%2F</url>
    <content type="text"><![CDATA[由Van Jacobson编写的Traceroute程序是一个能更深入探索TCP/IP协议的方便可用的工具。尽管不能保证从源端发往目的端的两份连续的IP数据报具有相同的路由，但是大多数情况下是这样的。Traceroute程序可以让我们看到IP数据报从一台主机传到另一台主机所经过的路由。Traceroute程序还可以让我们使用IP源路由选项。 Traceroute程序的操作为什么不使用IP记录路由选项(RR)这个选项而另外开发一个新的应用程序？有三个方面的原因。首先，原先并不是所有的路由器都支持记录路由选项，因此该选项在某些路径上不能使用（Traceroute程序不需要中间路由器具备任何特殊的或可选的功能）。其次，记录路由一般是单向的选项。发送端设置了该选项，那么接收端不得不从收到的IP首部中提取出所有的信息，然后全部返回给发送端。在7.3节中，我们看到大多数Ping服务器的实现（内核中的ICMP回显应答功能）把接收到的RR清单返回，但是这样使得记录下来的IP地址翻了一番（一来一回）。这样做会受到一些限制，这一点我们在下一段讨论（Traceroute程序只需要目的端运行一个UDP模块—其他不需要任何特殊的服务器应用程序）。最后一个原因也是最主要的原因是，IP首部中留给选项的空间有限，不能存放当前大多数的路径。在IP首部选项字段中最多只能存放9个IP地址。在原先的ARPANET中这是足够的，但是对现在来说是远远不够的。 Traceroute程序使用ICMP报文和IP首部中的TTL字段（生存周期）。TTL字段是由发送端初始设置一个8bit字段。推荐的初始值由分配数字RFC指定，当前值为64。较老版本的系统经常初始化为15或32。我们从第7章中的一些ping程序例子中可以看出，发送ICMP回显应答时经常把TTL设为最大值255。 每个处理数据报的路由器都需要把TTL的值减1或减去数据报在路由器中停留的秒数。由于大多数的路由器转发数据报的时延都小于1秒钟，因此TTL最终成为一个跳站的计数器，所经过的每个路由器都将其值减1。 TTL字段的目的是防止数据报在选路时无休止地在网络中流动。例如，当路由器瘫痪或者两个路由器之间的连接丢失时，选路协议有时会去检测丢失的路由并一直进行下去。在这段时间内，数据报可能在循环回路被终止。TTL字段就是在这些循环传递的数据报上加上一个生存上限。 当路由器收到一份IP数据报，如果其TTL字段是0或1，则路由器不转发该数据报（接收到这种数据报的目的主机可以将它交给应用程序，这是因为不需要转发该数据报。但是在通常情况下，系统不应该接收TTL字段为0的数据报）。相反，路由器将该数据报丢弃，并给信源机发一份ICMP“超时”信息。Traceroute程序的关键在于包含这份ICMP信息的IP报文的信源地址是该路由器的IP地址。 我们现在可以猜想一下Traceroute程序的操作过程。它发送一份TTL字段为1的IP数据报给目的主机。处理这份数据报的第一个路由器将TTL值减1，丢弃该数据报，并发回一份超时ICMP报文。这样就得到了该路径中的第一个路由器的地址。然后Traceroute程序发送一份TTL值为2的数据报，这样我们就可以得到第二个路由器的地址。继续这个过程直至该数据报到达目的主机。但是目的主机哪怕接收到TTL值为1的IP数据报，也不会丢弃该数据报并产生一份超时ICMP报文，这是因为数据报已经到达其最终目的地。那么我们该如何判断是否已经到达目的主机了呢？ Traceroute程序发送一份UDP数据报给目的主机，但它选择一个不可能的值作为UDP端口号（大于30000），使目的主机的任何一个应用程序都不可能使用该端口。因为，当该数据报到达时，将使目的主机的UDP模块产生一份“端口不可达”错误的ICMP报文。这样，Traceroute程序所要做的就是区分接收到的ICMP报文是超时还是端口不可达，以判断什么时候结束。 局域网输出现在已经做好运行Traceroute程序并观察其输出的准备了。我们将使用从svr4到slip，经路由器bsdi的简单互联网。bsdi和slip之间是9600 b/s的SLIP链路。 1234svr4 % traceroute sliptraceroute to slip (140.252.13.65), 30 hops max. 40 byte packets1 bsdi (140.252.13.35) 20 ms 10 ms 10 ms2 slip (140.252.13.65) 120 ms 120 ms 120 ms 输出的第1个无标号行给出了目的主机名和其IP地址，指出traceroute程序最大的TTL字段值为30。40字节的数据报包含20字节IP首部、8字节的UDP首部和12字节的用户数据（12字节的用户数据包含每发一个数据报就加1的序列号，送出TTL的副本以及发送数据报的时间）。 输出的后面两行以TTL开始，接下来是主机或路由器名以及其IP地址。对于每个TTL值，发送3份数据报。每接收到一份ICMP报文，就计算并打印出往返时间。如果在5秒种内仍未收到3份数据报的任意一份的响应，则打印一个星号，并发送下一份数据报。在上述输出结果中，TTL字段为1的前3份数据报的ICMP报文分别在20 ms、10 ms和10 ms收到。TTL字段为2的3份数据报的ICMP报文则在120 ms后收到。由于TTL字段为2到达最终目的主机，因此程序就此停止。 往返时间是由发送主机的traceroute程序计算的。它是指从traceroute程序到该路由器的总往返时间。如果我们对每段路径的时间感兴趣，可以用TTL字段为N+1所打印出来的时间减去TTL字段为N的时间。 正如我们所预想的那样，第1个发往bsdi的探测数据报的往返时间是20 ms、而后面两个数据报往返时间是10 ms的原因是发生了一次ARP交换。tcpdump结果证实了确实是这种情况。 12345678910111213141 0.0 arp who-has bsdi tell svr42 0.000586 (0.0006) arp reply bsdi is-at 0:0:c0:6f:2d:403 0.003067 (0.0025) svr4.42804 &gt; slip.33435; udp 12 [ttl 1]4 0.004325 (0.0013) bsdi &gt; svr4: icmp: time exceeded in-transit5 0.069810 (0.0655) svr4.42804 &gt; slip.33436: udp 12 [ttl 1]6 0.071149 (0.0013) bsdi &gt; svr4: icmp: time exceeded in-transit7 0.085162 (0.0140) svr4.42804 &gt; slip.33437: udp 12 [ttl 1]8 0.086375 (0.0012) bsdi &gt; svr4: icmp: time exceeded in-transit9 0.118608 (0.0322) svr4.42804 &gt; slip.33438: udp 1210 0.226464 (0.1079) slip &gt; svr4: icmp: slip udp port 33438 unreachable11 0.287296 (0.0608) svr4.42804 &gt; slip.33439: udp 1212 0.395230 (0.1079) slip &gt; svr4: icmp: slip udp port 33439 unreachable13 0.409504 (0.0143) svr4.42804 &gt; slip.33440: udp 1214 0.517430 (0.1079) slip &gt; svr4: icmp: slip udp port 33440 unreachable 目的主机UDP端口号最开始设置为33435，且每发送一个数据报加1。可以通过命令行选项来改变开始的端口号。UDP数据报包含12个字节的用户数据，我们在前面traceroute程序输出的40字节数据报中已经对其进行了描述。 后面tcpdump打印出了TTL字段为1的IP数据报的注释[ttl 1]。当TTL值为0或1时，tcpdump打印出这条信息，以提示我们数据报中有些不太寻常之处。在这里可以预见到TTL值为1；而在其他一些应用程序中，它可以警告我们数据报可能无法到达其最终目的主机。我们不可能看到路由器传送一个TTL值为0的数据报，除非发出该数据报的该路由器已经崩溃。 因为bsdi路由器将TTL值减到0，因此我们预计它将发回“传送超时”的ICMP报文。即使这份被丢弃的IP报文发送往slip，路由器也会发回ICMP报文。 第9~14行对应于TTL为2的3份数据报。这3份报文到达最终目的主机，并产生一份ICMP端口不可达报文。 源端口号（42804）看起来有些大。traceroute程序将其发送的UDP数据报的源端口号设置为Unix进程号与32768之间的逻辑或值。对于在同一台主机上多次运行traceroute程序的情况，每个进程都查看ICMP返回的UDP首部的源端口号，并且只处理那些对自己发送应答的报文。 关于traceroute程序，还有一些必须指出的事项。首先，并不能保证现在的路由也是将来所要采用的路由，甚至两份连续的IP数据报都可能采用不同的路由。如果在运行程序时，路由发生改变，就会观察到这种变化，这是因为对于一个给定的TTL，如果其路由发生变化，traceroute程序将打印出新的IP地址。第二，不能保证ICMP报文的路由与traceroute程序发送的UDP数据报采用同一路由。这表明所打印出来的往返时间可能并不能真正体现数据报发出和返回的时间差（如果UDP数据报从信源到路由器的时间是1秒，而ICMP报文用另一条路由返回信源用了3秒时间，则打印出来的往返时间是4秒）。第三，返回的ICMP报文中的信源IP地址是UDP数据报到达的路由器接口的IP地址。这与IP记录路由选项（7.3节）不同，记录的IP地址指的是发送接口地址。由于每个定义的路由器都有2个或更多的接口，因此，从A主机到B主机上运行traceroute程序和从B主机到A主机上运行traceroute程序所得到的结果可能是不同的。 最后，在广域网情况下，如果traceroute程序的输出是可读的域名形式，而不是IP地址形式，那么会更好理解一些。但是由于traceroute程序接收到ICMP报文时，它所获得的唯一信息就是IP地址，因此，在给定IP地址的情况下，它做一个“反向域名查看”工作来获得域名。这就需要路由器或主机的管理员正确配置其反向域名查看功能（并非所有的情况下都是如此）。 IP 源站选路选项通常IP路由是动态的，即每个路由器都要判断数据报下面该转发到哪个路由器。应用程序对此不进行控制，而且通常也并不关心路由。它采用类似Traceroute程序的工具来发现实际的路由。 源站选路(source routing)的思想是由发送者指定路由。它可以采用以下两种形式： 严格的源路由选择。发送端指明IP数据报所必须采用的确切路由。如果一个路由器发现源路由所指定的下一个路由器不在其直接连接的网络上，那么它就返回一个“源站路由失败”的ICMP差错报文。 宽松的源站选路。发送端指明了一个数据报经过的IP地址清单，但是数据报在清单上指明的任意两个地址之间可以通过其他路由器。 Traceroute程序提供了一个查看源站选路的方法，我们可以在选项中指明源站路由，然后检查其运行情况。 源站路由选项的格式： 这个格式与记录路由选项格式基本一致。不同之处是，对于源站选路，我们必须在发送IP数据报前填充IP地址清单；而对于记录路由选项，我们需要为IP地址清单分配并清空一些空间，并让路由器填充该清单中的各项。同时，对于源站选路，只要为所需要的IP地址数分配空间并进行初始化，通常其数量小于9。而对于记录路由选项来说，必须尽可能地分配空间，以达到9个地址。 对于宽松的源站选路来说，code字段的值是0x83；而对于严格的源站选路，其值为0x89。len和ptr与记录路由选项一致。 源站路由选项的实际称呼为“源站及记录路由”（对于宽松的源站选路和严格的源站选路，分别用LSRR和SSRR表示），这是因为在数据报沿路由发送过程中，对IP地址清单进行了更新。下面是其运行过程： 发送主机从应用程序接收源站路由清单，将第1个表项去掉（它是数据报的最终目的地址），将剩余的项移到1个项中（如图8-6所示），并将原来的目的地址作为清单的最后一项。指针仍然指向清单的第1项（即，指针的值为4）。 每个处理数据报的路由器检查其是否为数据报的最终地址。如果不是，则正常转发数据报（在这种情况下，必须指明宽松源站选路，否则就不能接收到该数据报）。 如果该路由器是最终目的，且指针不大于路径的长度，那么(1)由ptr所指定的清单中的下一个地址就是数据报的最终目的地址；(2)由外出接口(outgoing interface)相对应的IP地址取代刚才使用的源地址；(3)指针加4。 我们假设主机S上的发送应用程序发送一份数据报给D，指定源路由为R1，R2和R3。 在上图中，#表示指针字段，其值分别是4、8、12和16。长度字段恒为15（三个IP地址加上三个字节首部）。可以看出，每一跳IP数据报中的目的地址都发生改变。 当一个应用程序接收到由信源指定路由的数据时，在发送应答时，应该读出接收到的路由值，并提供反向路由。 小结在一个TCP/IP网络中，traceroute程序是不可缺少的工具。其操作很简单：开始时发送一个TTL字段为1的UDP数据报，然后将TTL字段每次加1，以确定路径中的每个路由器。每个路由器在丢弃UDP数据报时都返回一个ICMP超时报文2，而最终目的主机则产生一个ICMP端口不可达的报文。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>Traceroute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) Ping程序]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F04%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-ping%2F</url>
    <content type="text"><![CDATA[“ping”这个名字源于声纳定位操作。Ping程序由Mike Muuss编写，目的是为了测试另一台主机是否可达。该程序发送一份ICMP回显请求报文给主机，并等待返回ICMP回显应答。 Ping程序我们称发送回显请求的ping程序为客户，而称被ping的主机为服务器。大多数的TCP/IP实现都在内核中直接支持Ping服务器—这种服务器不是一个用户进程（两种ICMP查询服务，地址掩码和时间戳请求，也都是直接在内核中进行处理的）。ICMP回显请求和回显应答报文如下： 对于其他类型的ICMP查询报文，服务器必须响应标识符和序列号字段。另外，客户发送的选项数据必须回显，假设客户对这些信息都会感兴趣。 Unix系统在实现ping程序时是把ICMP报文中的标识符字段置成发送进程的ID号。这样即使在同一台主机上同时运行了多个ping程序实例，ping程序也可以识别出返回的信息。 序列号从0开始，每发送一次新的回显请求就加1。ping程序打印出返回的每个分组的序列号，允许我们查看是否有分组丢失、失序或重复。IP是一种最好的数据报传递服务，因此这三个条件都有可能发生。 旧版本的ping程序曾经以这种模式运行，即每秒发送一个回显请求，并打印出返回的每个回显应答。但是，新版本的实现需要加上-s选项才能以这种模式运行。默认情况下，新版本的ping程序只发送一个回显请求。如果收到回显应答，则输出“host is alive”；否则，在20秒内没有收到应答就输出“no answer（没有回答）”。 LAN 输出在局域网上运行ping程序的结果输出一般有如下格式：1234567891011121314bsdi % ping svr4PING svr4 (140.252.13.34): 56 data bytes64 bytes from 140.252.13.34: icmp_seq=0 ttl=255 time=0 ms64 bytes from 140.252.13.34: icmp_seq=l ttl=255 time=0 ms64 bytes from 140.252.13.34: icmp_seq=2 ttl=255 time=0 ms64 bytes from 140.252.13.34: icmp_seq=3 ttl=255 time=0 ms64 bytes from 140.252.13.34: icmp_seq=4 ttl=255 time=0 ms64 bytes from 140.252.13.34: icmp_seq=5 ttl=255 time=0 ms64 bytes from 140.252.13.34: icmp_seq=6 ttl=255 time=0 ms64 bytes from 140.252.13.34: icmp_seq=7 ttl=255 time=0 ms^? type interrupt key to stop--- svr4 ping statistics ---8 packets transmitted, 8 packets received, 0% packet lossround-trip min/avg/max = 0/0/0 ms 当返回ICMP回显应答时，要打印出序列号和TTL，并计算往返时间（TTL位于IP首部中的生存时间字段。当前的BSD系统中的ping程序每次收到回显应答时都打印出收到的TTL—有些系统并不这样做）。 从上面的输出中可以看出，回显应答是以发送的次序返回的（0，1，2等）。 ping程序通过在ICMP报文数据中存放发送请求的时间值来计算往返时间。当应答返回时，用当前时间减去存放在ICMP报文中的时间值，即是往返时间。 输出的第一行包括目的主机的IP地址，尽管指定的是它的名字（svr4）。这说明名字已经经过解析器被转换成IP地址了。现在，我们发现，如果敲入ping命令，几秒钟过后会在第1行打印出IP地址，DNS就是利用这段时间来确定主机名所对应的IP地址。 通常，第1个往返时间值要比其他的大。这是由于目的端的硬件地址不在ARP高速缓存中的缘故。在发送第一个回显请求之前要发送一个ARP请求并接收ARP应答，这需要花费几毫秒的时间。 IP 记录路由选项ping程序为我们提供了查看IP记录路由（RR）选项的机会。大多数不同版本的ping程序都提供-R选项，以提供记录路由的功能。它使得ping程序在发送出去的IP数据报中设置IPRR选项（该IP数据报包含ICMP回显请求报文）。这样，每个处理该数据报的路由器都把它的IP地址放入选项字段中。当数据报到达目的端时，IP地址清单应该复制到ICMP回显应答中，这样返回途中所经过的路由器地址也被加入清单中。当ping程序收到回显应答时，它就打印出这份IP地址清单。 这个过程听起来简单，但存在一些缺陷。源端主机生成RR选项，中间路由器对RR选项的处理，以及把ICMP回显请求中的RR清单复制到ICMP回显应答中，所有这些都是选项功能。幸运的是，现在的大多数系统都支持这些选项功能，只是有一些系统不把ICMP请求中的IP清单复制到ICMP应答中。 但是，最大的问题是IP首部中只有有限的空间来存放IP地址。IP首部中的首部长度字段只有4bit，因此整个IP首部最长只能包括15个32bit长的字（即60个字节）。由于IP首部固定长度为20字节，RR选项用去3个字节（下面我们再讨论），这样只剩下37个字节（60-20-3）来存放IP地址清单，也就是说只能存放9个IP地址。对于早期的ARPANET来说，9个IP地址似乎是很多了，但是现在看来是非常有限的（在第8章中，我们将用Traceroute工具来确定数据报的路由）。除了这些缺点，记录路由选项工作得很好，为详细查看如何处理IP选项提供了一个机会。 IP数据报中的RR选项的一般格式如下： code是一个字节，指明IP选项的类型。对于RR选项来说，它的值为7。len是RR选项总字节长度，在这种情况下为39（尽管可以为RR选项设置比最大长度小的长度，但是ping程序总是提供39字节的选项字段，最多可以记录9个IP地址。由于IP首部中留给选项的空间有限，它一般情况都设置成最大长度）。 ptr称作指针字段。它是一个基于1的指针，指向存放下一个IP地址的位置。它的最小值为4，指向存放第一个IP地址的位置。随着每个IP地址存入清单，ptr的值分别为8，12，16，最大到36。当记录下9个IP地址后，ptr的值为40，表示清单已满。 当路由器（根据定义应该是多穴的）在清单中记录IP地址时，它应该记录哪个地址呢？是入口地址还是出口地址？为此，RFC 791[Postel 1981a]指定路由器记录出口IP地址。我们在后面将看到，当原始主机（运行ping程序的主机）收到带有RR选项的ICMP回显应答时，它也要把它的入口IP地址放入清单中。 IP 时间戳选项IP时间戳选项与记录路由选项类似。IP时间戳选项的格式如下： 时间戳选项的代码为0x44。其他两个字段len和ptr与记录路由选项相同：选项的总长度（一般为36或40）和指向下一个可用空间的指针（5，9，13等）。 接下来的两个字段是4bit的值：OF表示溢出字段，FL表示标志字段。时间戳选项的操作根据标志字段来进行，如下所示。 标志 描述 0 只记录时间戳 1 每台路由器都记录它的IP地址和时间戳。在选项列表中只有存放4对地址和时间戳的空间 2 发送端对选项列表进行初始化，存放了4个IP地址和4个取值为0的时间戳值。只有当列表中的下一个IP地址与当前路由器地址相匹配时，才记录它的时间戳 如果路由器由于没有空间而不能增加时间戳选项，那么它将增加溢出字段的值。 时间戳的取值一般为自UTC午夜开始计的毫秒数，与ICMP时间戳请求和应答相类似。如果路由器不使用这种格式，它就可以插入任何它使用的时间表示格式，但是必须打开时间戳中的高位以表明为非标准值。 与我们遇到的记录路由选项所受到的限制相比，时间戳选项遇到情况要更坏一些。如果我们要同时记录IP地址和时间戳（标志位为1），那么就可以同时存入其中的四对值。只记录时间戳是没有用处的，因为我们没有标明时间戳与路由器之间的对应关系（除非有一个永远不变的拓扑结构）。标志值取3会更好一些，因为我们可以插入时间戳的路由器。一个更为基本的问题是，很可能无法控制任何给定路由器上时间戳的正确性。这使得试图用IP选项来计算路由器之间的跳站数是徒劳的。我们将看到traceroute程序可以提供一种更好的方法来计算路由器之间的跳站数。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>Ping</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) ICMP：Internet控制报文协议]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F03%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-icmp%2F</url>
    <content type="text"><![CDATA[ICMP经常被认为是IP层的一个组成部分。它传递差错报文以及其他需要注意的信息。ICMP报文通常被IP层或更高层协议（TCP或UDP）使用。一些ICMP报文把差错报文返回给用户进程。 ICMP报文是在IP数据报内部被传输的，格式为：20个字节的IP首部加上后面的ICMP报文。 ICMP 报文格式中，类型字段可以有15个不同的值，以描述特定类型的ICMP报文。某些ICMP报文还使用代码字段的值来进一步描述不同的条件。检验和字段覆盖整个ICMP报文。使用的算法与IP首部检验和算法相同。ICMP的检验和是必需的。 ICMP 报文的类型 类型 代码 描述 查询 差错 0 0 回显应答(Ping应答) * 3 目的不可达： 0 网络不可达 * 1 主机不可达 * 2 协议不可达 * 3 端口不可达 * 4 需要进行分片但设置了不分片比特 * 5 源站选路失败 * 6 目的网络不认识 * 7 目的主机不认识 * 8 源主机被隔离(作废不用) * 9 目的网络被强制禁止 * 10 目的主机被强制禁止 * 11 由于服务类型TOS，网络不可达 * 12 由于服务类型TOS，主机不可达 * 13 由于过滤，通信被强制禁止 * 14 主机越权 * 15 优先权中止生效 * 4 0 源端被关闭(基本流控制) * 5 重定向： * 0 对网络重定向 * 1 对主机重定向 * 2 对服务类型和网络重定向 * 3 对服务类型和主机重定向 * 8 0 请求回显(Ping请求) * 9 0 路由器通告 * 10 0 路由器请求 * 11 超时： 0 传输期间生存时间为0(Traceroute) * 1 在数据报组装期间生存时间为 0 * 12 参数问题： 0 坏的IP首部(包括各种差错) * 1 缺少必需的选项 * 13 0 时间戳请求 * 14 0 时间戳应答 * 15 0 信息请求(作废不用) * 16 0 信息应答(作废不用) * 17 0 地址掩码请求 * 18 0 地址掩码应答 * 不同类型由报文中的类型字段和代码字段来共同决定。 最后两列表明ICMP报文是一份查询报文还是一份差错报文。因为对ICMP差错报文有时需要作特殊处理，因此我们需要对它们进行区分。例如，在对ICMP差错报文进行响应时，永远不会生成另一份ICMP差错报文（如果没有这个限制规则，可能会遇到一个差错产生另一个差错的情况，而差错再产生差错，这样会无休止地循环下去）。 当发送一份ICMP差错报文时，报文始终包含IP的首部和产生ICMP差错报文的IP数据报的前8个字节。这样，接收ICMP差错报文的模块就会把它与某个特定的协议（根据IP数据报首部中的协议字段来判断）和用户进程（根据包含在IP数据报前8个字节中的TCP或UDP报文首部中的TCP或UDP端口号来判断）联系起来。 下面各种情况都不会导致产生ICMP差错报文： ICMP差错报文（但是，ICMP查询报文可能会产生ICMP差错报文）。 目的地址是广播地址或多播地址（D类地址）的IP数据报。 作为链路层广播的数据报。 不是IP分片的第一片。 源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地址或多播地址。 这些规则是为了防止过去允许ICMP差错报文对广播分组响应所带来的广播风暴。 ICMP 地址掩码请求与应答ICMP地址掩码请求用于无盘系统在引导过程中获取自己的子网掩码。系统广播它的ICMP请求报文（这一过程与无盘系统在引导过程中用RARP获取IP地址是类似的）。无盘系统获取子网掩码的另一个方法是BOOTP协议。ICMP地址掩码请求和应答报文的格式如下： ICMP报文中的标识符和序列号字段由发送端任意选择设定，这些值在应答中将被返回。这样，发送端就可以把应答与请求进行匹配。 ICMP 时间戳请求与应答ICMP时间戳请求允许系统向另一个系统查询当前的时间。返回的建议值是自午夜开始计算的毫秒数，协调的统一时间（Coordinated Universal Time,UTC）（早期的参考手册认为UTC是格林尼治时间）。这种ICMP报文的好处是它提供了毫秒级的分辨率，而利用其他方法从别的主机获取的时间（如某些Unix系统提供的rdate命令）只能提供秒级的分辨率。由于返回的时间是从午夜开始计算的，因此调用者必须通过其他方法获知当时的日期，这是它的一个缺陷。 请求端填写发起时间戳，然后发送报文。应答系统收到请求报文时填写接收时间戳，在发送应答时填写发送时间戳。但是，实际上，大多数的实现把后面两个字段都设成相同的值（提供三个字段的原因是可以让发送方分别计算发送请求的时间和发送应答的时间）。 ICMP 不可达差错ICMP的一个规则是，ICMP差错报文必须包括生成该差错报文的数据报IP首部（包含任何选项），还必须至少包括跟在该IP首部后面的前8个字节。 导致差错的数据报中的IP首部要被送回的原因是因为IP首部中包含了协议字段，使得ICMP可以知道如何解释后面的8个字节。事实上，UDP首部中的内容是源端口号和目的端口号，如果我们来查看TCP首部,可以发现源端口和目的端口被包含在TCP首部的前8个字节中。 ICMP 报文的 4.4BSD 处理 类型 代码 描述 处理方法 0 0 回显应答(Ping应答) 用户进程 3 目的不可达： 0 网络不可达 “无路由到达主机” 1 主机不可达 “无路由到达主机” 2 协议不可达 “连接被拒绝” 3 端口不可达 “连接被拒绝” 4 需要进行分片但设置了不分片比特 “报文太长” 5 源站选路失败 “无路由到达主机” 6 目的网络不认识 “无路由到达主机” 7 目的主机不认识 “无路由到达主机” 8 源主机被隔离(作废不用) “无路由到达主机” 9 目的网络被强制禁止 “无路由到达主机” 10 目的主机被强制禁止 “无路由到达主机” 11 由于服务类型TOS，网络不可达 “无路由到达主机” 12 由于服务类型TOS，主机不可达 “无路由到达主机” 13 由于过滤，通信被强制禁止 (忽略) 14 主机越权 (忽略) 15 优先权中止生效 (忽略) 4 0 源端被关闭(quench) TCP由内核处理，UDP则忽略 5 重定向： 0 对网络重定向 内核更新路由表 1 对主机重定向 内核更新路由表 2 对服务类型和网络重定向 内核更新路由表 3 对服务类型和主机重定向 内核更新路由表 8 0 请求回显(Ping请求) 9 0 路由器通告 用户进程 10 0 路由器请求 用户进程 11 超时： 0 传输期间生存时间为0(Traceroute) 用户进程 1 在数据报组装期间生存时间为 0 用户进程 12 参数问题： 0 坏的IP首部(包括各种差错) “协议不可用” 1 缺少必需的选项 “协议不可用” 13 0 时间戳请求 内核产生应答 14 0 时间戳应答 用户进程 15 0 信息请求(作废不用) (忽略) 16 0 信息应答(作废不用) 用户进程 17 0 地址掩码请求 内核产生应答 18 0 地址掩码应答 用户进程 如果最后一列标明是“内核”，那么ICMP就由内核来处理。如果最后一列指明是“用户进程”，那么报文就被传送到所有在内核中登记的用户进程，以读取收到的ICMP报文。如果不存在任何这样的用户进程，那么报文就悄悄地被丢弃（这些用户进程还会收到所有其他类型的ICMP报文的拷贝，虽然它们应该由内核来处理，当然用户进程只有在内核处理以后才能收到这些报文）。有一些报文完全被忽略。最后，如果最后一列标明的是引号内的一串字符，那么它就是对应的Unix差错。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>ICMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) RARP：逆地址解析协议]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F03%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-rarp%2F</url>
    <content type="text"><![CDATA[具有本地磁盘的系统引导时，一般是从磁盘上的配置文件中读取IP地址。但是无盘机，如X终端或无盘工作站，则需要采用其他方法来获得IP地址。 网络上的每个系统都具有唯一的硬件地址，它是由网络接口生产厂家配置的。无盘系统的RARP实现过程是从接口卡上读取唯一的硬件地址，然后发送一份RARP请求（一帧在网络上广播的数据），请求某个主机响应该无盘系统的IP地址（在RARP应答中）。 RARP 的分组格式RARP分组的格式与ARP分组基本一致。它们之间主要的差别是RARP请求或应答的帧类型代码为0x8035，而且RARP请求的操作代码为3，应答操作代码为4。 对应于ARP，RARP请求以广播方式传送，而RARP应答一般是单播(unicast)传送的。 RARP 服务器的设计虽然RARP在概念上很简单，但是一个RARP服务器的设计与系统相关而且比较复杂。相反，提供一个ARP服务器很简单，通常是TCP/IP在内核中实现的一部分。由于内核知道IP地址和硬件地址，因此当它收到一个询问IP地址的ARP请求时，只需用相应的硬件地址来提供应答就可以了。 作为用户进程的 RARP 服务器RARP服务器的复杂性在于，服务器一般要为多个主机（网络上所有的无盘系统）提供硬件地址到IP地址的映射。该映射包含在一个磁盘文件中（在Unix系统中一般位于/etc/ethers目录中）。由于内核一般不读取和分析磁盘文件，因此RARP服务器的功能就由用户进程来提供，而不是作为内核的TCP/IP实现的一部分。 更为复杂的是，RARP请求是作为一个特殊类型的以太网数据帧来传送的。这说明RARP服务器必须能够发送和接收这种类型的以太网数据帧。由于发送和接收这些数据帧与系统有关，因此RARP服务器的实现是与系统捆绑在一起的。 每个网络有多个 RARP 服务器RARP服务器实现的一个复杂因素是RARP请求是在硬件层上进行广播的，如图5-2所示。这意味着它们不经过路由器进行转发。为了让无盘系统在RARP服务器关机的状态下也能引导，通常在一个网络上（例如一根电缆）要提供多个RARP服务器。 当服务器的数目增加时（以提供冗余备份），网络流量也随之增加，因为每个服务器对每个RARP请求都要发送RARP应答。发送RARP请求的无盘系统一般采用最先收到的RARP应答（对于ARP，我们从来没有遇到这种情况，因为只有一台主机发送ARP应答）。另外，还有一种可能发生的情况是每个RARP服务器同时应答，这样会增加以太网发生冲突的概率。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>RARP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) ARP：地址解析协议]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F02%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-arp%2F</url>
    <content type="text"><![CDATA[数据链路如以太网或令牌环网都有自己的寻址机制（常常为48 bit地址），这是使用数据链路的任何网络层都必须遵从的。 当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据48 bit的以太网地址来确定目的接口的。设备驱动程序从不检查IP数据报中的目的IP地址。 地址解析为这两种不同的地址形式提供映射：32 bit的IP地址和数据链路层使用的任何类型的地址。 ARP为IP地址到对应的硬件地址之间提供动态映射。 ARP 高速缓存ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了最近Internet地址到硬件地址之间的映射记录。高速缓存中每一项的生存时间一般为20分钟，起始时间从被创建时开始算起。使用 arp -a 命令来检查 ARP 高速缓存。 ARP 分组格式 以太网报头中的前两个字段是以太网的源地址和目的地址。目的地址为全1的特殊地址是广播地址。电缆上的所有以太网接口都要接收广播的数据帧。 两个字节长的以太网帧类型表示后面数据的类型。对于ARP请求或应答来说，该字段的值为0x0806。 硬件类型字段表示硬件地址的类型。它的值为1即表示以太网地址。协议类型字段表示要映射的协议地址类型。它的值为0x0800即表示IP地址。它的值与包含IP数据报的以太网数据帧中的类型字段的值相同，这是有意设计的。 接下来的两个1字节的字段，硬件地址长度和协议地址长度分别指出硬件地址和协议地址的长度，以字节为单位。对于以太网上IP地址的ARP请求或应答来说，它们的值分别为6和4。 操作字段指出四种操作类型，它们是ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为3）和RARP应答（值为4）。这个字段必需的，因为ARP请求和ARP应答的帧类型字段值是相同的。 接下来的四个字段是发送端的硬件地址（在本例中是以太网地址）、发送端的协议地址（IP地址）、目的端的硬件地址和目的端的协议地址。注意，这里有一些重复信息：在以太网的数据帧报头中和ARP请求数据帧中都有发送端的硬件地址。 对于一个ARP请求来说，除目的端硬件地址外的所有其他的字段都有填充值。当系统收到一份目的端为本机的ARP请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为2，最后把它发送回去。 ARP 高速缓存超时设置在ARP高速缓存中的表项一般都要设置超时值。从伯克利系统演变而来的系统一般对完整的表项设置超时值为20分钟，而对不完整的表项设置超时值为3分钟（例如在以太网上对一个不存在的主机发出ARP请求。）当这些表项再次使用时，这些实现一般都把超时值重新设为20分钟。 ARP 代理如果ARP请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作委托ARP或ARP代理(Proxy ARP)。这样可以欺骗发起ARP请求的发送端，使它误以为路由器就是目的主机，而事实上目的主机是在路由器的“另一边”。路由器的功能相当于目的主机的代理，把分组从其他主机转发给它。 ARP代理也称作混合ARP（promiscuousARP）或ARP出租(ARP hack)。这些名字来自于ARP代理的其他用途：通过两个物理网络之间的路由器可以互相隐藏物理网络。在这种情况下，两个物理网络可以使用相同的网络号，只要把中间的路由器设置成一个ARP代理，以响应一个网络到另一个网络主机的ARP请求。这种技术在过去用来隐藏一组在不同物理电缆上运行旧版TCP/IP的主机。分开这些旧主机有两个共同的理由，其一是它们不能处理子网划分，其二是它们使用旧的广播地址（所有比特值为0的主机号，而不是目前使用的所有比特值为1 的主机号）。 免费 ARP我们可以看到的另一个ARP特性称作免费ARP(gratuitous ARP)。它是指主机发送ARP查找自己的IP地址。通常，它发生在系统引导期间进行接口配置的时候。 免费ARP可以有两个方面的作用： 一个主机可以通过它来确定另一个主机是否设置了相同的IP地址。主机bsdi并不希望对此请求有一个回答。但是，如果收到一个回答，那么就会在终端日志上产生一个错误消息“以太网地址：a:b:c:d:e:f发送来重复的IP地址”。这样就可以警告系统管理员，某个系统有不正确的设置。 如果发送免费ARP的主机正好改变了硬件地址（很可能是主机关机了，并换了一块接口卡，然后重新启动），那么这个分组就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。一个比较著名的ARP协议事实[Plummer 1982]是，如果主机收到某个IP地址的ARP请求，而且它已经在接收者的高速缓存中，那么就要用ARP请求中的发送端硬件地址（如以太网地址）对高速缓存中相应的内容进行更新。主机接收到任何ARP请求都要完成这个操作（ARP请求是在网上广播的，因此每次发送ARP请求时网络上的所有主机都要这样做）。 arp 命令123ARP -s inet_addr eth_addr [if_addr]ARP -d inet_addr [if_addr]ARP -a [inet_addr] [-N if_addr] [-v] -a 通过询问当前协议数据，显示当前 ARP 项。如果指定 inet_addr，则只显示指定计算机的 IP 地址和物理地址。如果不止一个网络接口使用 ARP，则显示每个 ARP 表的项。 -g 与 -a 相同。 -v 在详细模式下显示当前 ARP 项。所有无效项和环回接口上的项都将显示。 inet_addr 指定 Internet 地址。 -N if_addr 显示 if_addr 指定的网络接口的 ARP 项。 -d 删除 inet_addr 指定的主机。inet_addr 可以是通配符 *，以删除所有主机。 -s 添加主机并且将 Internet 地址 inet_addr与物理地址 eth_addr 相关联。物理地址是用连字符分隔的 6 个十六进制字节。该项是永久的。 eth_addr 指定物理地址。 if_addr 如果存在，此项指定地址转换表应修改的接口的 Internet 地址。如果不存在，则使用第一个适用的接口。 示例: arp -s 157.55.85.212 00-aa-00-62-c6-09…. 添加静态项。arp -a …. 显示 ARP 表。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>ARP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 10 Version 1803 is out]]></title>
    <url>%2Fhexo-blog%2F2018%2F05%2F02%2Fwindows10-version-1803-is-out%2F</url>
    <content type="text"><![CDATA[简体中文零售版家庭版、专业版、教育版、家庭单语言版、专业工作站版、专业教育版 架构: x64文件: cn_windows_10_consumer_editions_version_1803_updated_march_2018_x64_dvd_12063766.isoSHA-1: 82091D67FFF5B49726FFC22D35D9C1CBE81DC443文件大小: 4.38 GB释出时间: 2018-04-30下载地址：ed2k://|file|cn_windows_10_consumer_editions_version_1803_updated_march_2018_x64_dvd_12063766.iso|4714162176|FB8C05DE594CD7E58D88993652DD2102|/ 架构: x86文件: cn_windows_10_consumer_editions_version_1803_updated_march_2018_x86_dvd_12063452.isoSHA-1: D5E89FB54169F5A2E610C75813CE833A4CB9A4E4文件大小: 3.24 GB释出时间: 2018-04-30下载地址：ed2k://|file|cn_windows_10_consumer_editions_version_1803_updated_march_2018_x86_dvd_12063452.iso|3480692736|0EC3C40EF13D772798209981F18B6A5D|/ 简体中文 VL 版专业版、企业版、教育版、专业工作站版、专业教育版 架构: x64文件: cn_windows_10_business_editions_version_1803_updated_march_2018_x64_dvd_12063730.isoSHA-1: E39B9347FC5BE4A0548FB15E666FB92E0A965C6E文件大小: 4.31 GB释出时间: 2018-04-30下载地址：ed2k://|file|cn_windows_10_business_editions_version_1803_updated_march_2018_x64_dvd_12063730.iso|4634574848|5674B3586C866EB2F47D7736A1FDE27A|/ 架构: x86文件: cn_windows_10_business_editions_version_1803_updated_march_2018_x86_dvd_12063369.isoSHA-1: 6250FDF0B91F64E114F4CFEC7A75546974CF6FEB文件大小: 3.18 GB释出时间: 2018-04-30下载地址：ed2k://|file|cn_windows_10_business_editions_version_1803_updated_march_2018_x86_dvd_12063369.iso|3421925376|87EC2484858101C40782F42AFBAD02B0|/]]></content>
      <categories>
        <category>News</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emacs add yasnippet to company backends]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F27%2Femacs-add-yasnippet-to-company-backends%2F</url>
    <content type="text"><![CDATA[12345678910(defvar company-mode/enable-yas t &quot;Enable yasnippet for all backends.&quot;)(defun company-mode/backend-with-yas (backend) (if (or (not company-mode/enable-yas) (and (listp backend) (member &apos;company-yasnippet backend))) backend (append (if (consp backend) backend (list backend)) &apos;(:with company-yasnippet))))(setq company-backends (mapcar #&apos;company-mode/backend-with-yas company-backends))]]></content>
      <categories>
        <category>Software</category>
        <category>emacs</category>
      </categories>
      <tags>
        <tag>yasnippet</tag>
        <tag>company</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 18.04 LTS is out]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F27%2Fubuntu-18.04-lts-is-out%2F</url>
    <content type="text"><![CDATA[What’s new in 18.04 LTS Supported by Canonical until 2023 Runs on all major architectures – x86, x86-64, ARM v7, ARM64, POWER8 and IBM s390x (LinuxONE) New ubuntu-minimal images that are smaller and boot faster Fast and accurate time synchronization with chrony A new, default server installer ISO with a new interface and faster install Supports ZFS, the next-generation volume management/ file system ideal for servers and containers LXD 3.0 - Linux containers including clustering, Qos, and resource controls (CPU, memory, block I/O/ graphics, and storage quota) Updates to LXD (v3.0), DPDK (v17.11.1), Postgresql (v10.3), Libvirt (v4.0), NGINX (v1.13), Qemu (v2.11.1), Docker (v17.03), Puppet (v4.10), MySQL (v5.7), PHP (v7.2), and more Install snaps for simple application installation and release management Linux 4.15 kernel Certification as a guest on AWS, Microsoft Azure, Joyent, IBM, Google Cloud Platform and Rackspace Easily configure networking through netplan.io Download Ubuntu 18.04 LTSImages can be downloaded from a location near you. You can download ISOs and flashable images from: http://releases.ubuntu.com/18.04/ (Ubuntu Desktop and Server)http://cdimage.ubuntu.com/ubuntu/releases/18.04/release/ (Less Popular Ubuntu Images)http://cloud-images.ubuntu.com/daily/server/bionic/current/ (Ubuntu Cloud Images)http://cdimage.ubuntu.com/netboot/18.04/ (Ubuntu Netboot)http://cdimage.ubuntu.com/kubuntu/releases/18.04/release/ (Kubuntu)http://cdimage.ubuntu.com/lubuntu/releases/18.04/release/ (Lubuntu and Lubuntu Alternate)http://cdimage.ubuntu.com/ubuntu-budgie/releases/18.04/release/ (Ubuntu Budgie)http://cdimage.ubuntu.com/ubuntukylin/releases/18.04/release/ (Ubuntu Kylin)https://ubuntu-mate.org/download/ (Ubuntu MATE)http://cdimage.ubuntu.com/ubuntustudio/releases/18.04/release/ (Ubuntu Studio)http://cdimage.ubuntu.com/xubuntu/releases/18.04/release/ (Xubuntu)]]></content>
      <categories>
        <category>News</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传输对象模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F26%2Fdesign-pattern%2Ftransfer-object-pattern%2F</url>
    <content type="text"><![CDATA[传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。 业务对象（Business Object） - 为传输对象填充数据的业务服务。传输对象（Transfer Object） - 简单的 POJO，只有设置/获取属性的方法。客户端（Client） - 客户端可以发送请求或者发送传输对象到业务对象。 实现我们将创建一个作为业务对象的 StudentBO 和作为传输对象的 StudentVO，它们都代表了我们的实体。TransferObjectPatternDemo，我们的演示类在这里是作为一个客户端，将使用 StudentBO 和 Student 来演示传输对象设计模式。 步骤 1创建传输对象。 StudentVO.java12345678910111213141516171819202122232425public class StudentVO &#123; private String name; private int rollNo; StudentVO(String name, int rollNo)&#123; this.name = name; this.rollNo = rollNo; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getRollNo() &#123; return rollNo; &#125; public void setRollNo(int rollNo) &#123; this.rollNo = rollNo; &#125;&#125; 步骤 2创建业务对象。 StudentBO.java123456789101112131415161718192021222324252627282930313233343536import java.util.ArrayList;import java.util.List;public class StudentBO &#123; //列表是当作一个数据库 List&lt;StudentVO&gt; students; public StudentBO()&#123; students = new ArrayList&lt;StudentVO&gt;(); StudentVO student1 = new StudentVO("Robert",0); StudentVO student2 = new StudentVO("John",1); students.add(student1); students.add(student2); &#125; public void deleteStudent(StudentVO student) &#123; students.remove(student.getRollNo()); System.out.println("Student: Roll No " + student.getRollNo() +", deleted from database"); &#125; //从数据库中检索学生名单 public List&lt;StudentVO&gt; getAllStudents() &#123; return students; &#125; public StudentVO getStudent(int rollNo) &#123; return students.get(rollNo); &#125; public void updateStudent(StudentVO student) &#123; students.get(student.getRollNo()).setName(student.getName()); System.out.println("Student: Roll No " + student.getRollNo() +", updated in the database"); &#125;&#125; 步骤 3使用 StudentBO 来演示传输对象设计模式。 TransferObjectPatternDemo.java123456789101112131415161718192021public class TransferObjectPatternDemo &#123; public static void main(String[] args) &#123; StudentBO studentBusinessObject = new StudentBO(); //输出所有的学生 for (StudentVO student : studentBusinessObject.getAllStudents()) &#123; System.out.println("Student: [RollNo : " +student.getRollNo()+", Name : "+student.getName()+" ]"); &#125; //更新学生 StudentVO student =studentBusinessObject.getAllStudents().get(0); student.setName("Michael"); studentBusinessObject.updateStudent(student); //获取学生 studentBusinessObject.getStudent(0); System.out.println("Student: [RollNo : " +student.getRollNo()+", Name : "+student.getName()+" ]"); &#125;&#125; 步骤 4验证输出。1234Student: [RollNo : 0, Name : Robert ]Student: [RollNo : 1, Name : John ]Student: Roll No 0, updated in the databaseStudent: [RollNo : 0, Name : Michael ]]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>J2EE模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务定位器模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F26%2Fdesign-pattern%2Fservice-locator-pattern%2F</url>
    <content type="text"><![CDATA[服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。 服务（Service） - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。Context / 初始的 Context - JNDI Context 带有对要查找的服务的引用。服务定位器（Service Locator） - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。缓存（Cache） - 缓存存储服务的引用，以便复用它们。客户端（Client） - Client 是通过 ServiceLocator 调用服务的对象。 实现我们将创建 ServiceLocator、InitialContext、Cache、Service 作为表示实体的各种对象。Service1 和 Service2 表示实体服务。ServiceLocatorPatternDemo，我们的演示类在这里是作为一个客户端，将使用 ServiceLocator 来演示服务定位器设计模式。 步骤 1创建服务接口 Service。 Service.java1234public interface Service &#123; public String getName(); public void execute();&#125; 步骤 2创建实体服务。 Service1.java12345678910public class Service1 implements Service &#123; public void execute()&#123; System.out.println("Executing Service1"); &#125; @Override public String getName() &#123; return "Service1"; &#125;&#125; Service2.java12345678910public class Service2 implements Service &#123; public void execute()&#123; System.out.println("Executing Service2"); &#125; @Override public String getName() &#123; return "Service2"; &#125;&#125; 步骤 3为 JNDI 查询创建 InitialContext。 InitialContext.java123456789101112public class InitialContext &#123; public Object lookup(String jndiName)&#123; if(jndiName.equalsIgnoreCase("SERVICE1"))&#123; System.out.println("Looking up and creating a new Service1 object"); return new Service1(); &#125;else if (jndiName.equalsIgnoreCase("SERVICE2"))&#123; System.out.println("Looking up and creating a new Service2 object"); return new Service2(); &#125; return null; &#125;&#125; 步骤 4创建缓存 Cache。 Cache.java123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.List;public class Cache &#123; private List&lt;Service&gt; services; public Cache()&#123; services = new ArrayList&lt;Service&gt;(); &#125; public Service getService(String serviceName)&#123; for (Service service : services) &#123; if(service.getName().equalsIgnoreCase(serviceName))&#123; System.out.println("Returning cached "+serviceName+" object"); return service; &#125; &#125; return null; &#125; public void addService(Service newService)&#123; boolean exists = false; for (Service service : services) &#123; if(service.getName().equalsIgnoreCase(newService.getName()))&#123; exists = true; &#125; &#125; if(!exists)&#123; services.add(newService); &#125; &#125;&#125; 步骤 5创建服务定位器。 ServiceLocator.java123456789101112131415161718192021public class ServiceLocator &#123; private static Cache cache; static &#123; cache = new Cache(); &#125; public static Service getService(String jndiName)&#123; Service service = cache.getService(jndiName); if(service != null)&#123; return service; &#125; InitialContext context = new InitialContext(); Service service1 = (Service)context.lookup(jndiName); cache.addService(service1); return service1; &#125;&#125; 步骤 6使用 ServiceLocator 来演示服务定位器设计模式。 ServiceLocatorPatternDemo.java123456789101112public class ServiceLocatorPatternDemo &#123; public static void main(String[] args) &#123; Service service = ServiceLocator.getService("Service1"); service.execute(); service = ServiceLocator.getService("Service2"); service.execute(); service = ServiceLocator.getService("Service1"); service.execute(); service = ServiceLocator.getService("Service2"); service.execute(); &#125;&#125; 步骤 7验证输出。12345678Looking up and creating a new Service1 objectExecuting Service1Looking up and creating a new Service2 objectExecuting Service2Returning cached Service1 objectExecuting Service1Returning cached Service2 objectExecuting Service2]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>J2EE模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拦截过滤器模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F26%2Fdesign-pattern%2Fintercepting-filter-pattern%2F</url>
    <content type="text"><![CDATA[拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。 过滤器（Filter） - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。过滤器链（Filter Chain） - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。Target - Target 对象是请求处理程序。过滤管理器（Filter Manager） - 过滤管理器管理过滤器和过滤器链。客户端（Client） - Client 是向 Target 对象发送请求的对象。 实现我们将创建 FilterChain、FilterManager、Target、Client 作为表示实体的各种对象。AuthenticationFilter 和 DebugFilter 表示实体过滤器。InterceptingFilterDemo，我们的演示类使用 Client 来演示拦截过滤器设计模式。 步骤 1创建过滤器接口 Filter。 Filter.java123public interface Filter &#123; public void execute(String request);&#125; 步骤 2创建实体过滤器。 AuthenticationFilter.java12345public class AuthenticationFilter implements Filter &#123; public void execute(String request)&#123; System.out.println("Authenticating request: " + request); &#125;&#125; DebugFilter.java12345public class DebugFilter implements Filter &#123; public void execute(String request)&#123; System.out.println("request log: " + request); &#125;&#125; 步骤 3创建 Target。 Target.java12345public class Target &#123; public void execute(String request)&#123; System.out.println("Executing request: " + request); &#125;&#125; 步骤 4创建过滤器链。 FilterChain.java12345678910111213141516171819202122import java.util.ArrayList;import java.util.List;public class FilterChain &#123; private List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;(); private Target target; public void addFilter(Filter filter)&#123; filters.add(filter); &#125; public void execute(String request)&#123; for (Filter filter : filters) &#123; filter.execute(request); &#125; target.execute(request); &#125; public void setTarget(Target target)&#123; this.target = target; &#125;&#125; 步骤 5创建过滤管理器。 FilterManager.java123456789101112131415public class FilterManager &#123; FilterChain filterChain; public FilterManager(Target target)&#123; filterChain = new FilterChain(); filterChain.setTarget(target); &#125; public void setFilter(Filter filter)&#123; filterChain.addFilter(filter); &#125; public void filterRequest(String request)&#123; filterChain.execute(request); &#125;&#125; 步骤 6创建客户端 Client。 Client.java1234567891011public class Client &#123; FilterManager filterManager; public void setFilterManager(FilterManager filterManager)&#123; this.filterManager = filterManager; &#125; public void sendRequest(String request)&#123; filterManager.filterRequest(request); &#125;&#125; 步骤 7使用 Client 来演示拦截过滤器设计模式。 InterceptingFilterDemo.java1234567891011public class InterceptingFilterDemo &#123; public static void main(String[] args) &#123; FilterManager filterManager = new FilterManager(new Target()); filterManager.setFilter(new AuthenticationFilter()); filterManager.setFilter(new DebugFilter()); Client client = new Client(); client.setFilterManager(filterManager); client.sendRequest("HOME"); &#125;&#125; 步骤 8验证输出。123Authenticating request: HOMErequest log: HOMEExecuting request: HOME]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>J2EE模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端控制器模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F26%2Fdesign-pattern%2Ffront-controller-pattern%2F</url>
    <content type="text"><![CDATA[前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。 前端控制器（Front Controller） - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。调度器（Dispatcher） - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。视图（View） - 视图是为请求而创建的对象。 实现我们将创建 FrontController、Dispatcher 分别当作前端控制器和调度器。HomeView 和 StudentView 表示各种为前端控制器接收到的请求而创建的视图。FrontControllerPatternDemo，我们的演示类使用 FrontController 来演示前端控制器设计模式。 步骤 1创建视图。 HomeView.java12345public class HomeView &#123; public void show()&#123; System.out.println("Displaying Home Page"); &#125;&#125; StudentView.java12345public class StudentView &#123; public void show()&#123; System.out.println("Displaying Student Page"); &#125;&#125; 步骤 2创建调度器 Dispatcher。 Dispatcher.java12345678910111213141516public class Dispatcher &#123; private StudentView studentView; private HomeView homeView; public Dispatcher()&#123; studentView = new StudentView(); homeView = new HomeView(); &#125; public void dispatch(String request)&#123; if(request.equalsIgnoreCase("STUDENT"))&#123; studentView.show(); &#125;else&#123; homeView.show(); &#125; &#125;&#125; 步骤 3创建前端控制器 FrontController。 FrontController.java1234567891011121314151617181920212223242526public class FrontController &#123; private Dispatcher dispatcher; public FrontController()&#123; dispatcher = new Dispatcher(); &#125; private boolean isAuthenticUser()&#123; System.out.println("User is authenticated successfully."); return true; &#125; private void trackRequest(String request)&#123; System.out.println("Page requested: " + request); &#125; public void dispatchRequest(String request)&#123; //记录每一个请求 trackRequest(request); //对用户进行身份验证 if(isAuthenticUser())&#123; dispatcher.dispatch(request); &#125; &#125;&#125; 步骤 4使用 FrontController 来演示前端控制器设计模式。 FrontControllerPatternDemo.java1234567public class FrontControllerPatternDemo &#123; public static void main(String[] args) &#123; FrontController frontController = new FrontController(); frontController.dispatchRequest("HOME"); frontController.dispatchRequest("STUDENT"); &#125;&#125; 步骤 5验证输出。123456Page requested: HOMEUser is authenticated successfully.Displaying Home PagePage requested: STUDENTUser is authenticated successfully.Displaying Student Page]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>J2EE模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据访问对象模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F26%2Fdata-access-object-pattern%2F</url>
    <content type="text"><![CDATA[数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。 数据访问对象接口（Data Access Object Interface） - 该接口定义了在一个模型对象上要执行的标准操作。数据访问对象实体类（Data Access Object concrete class） - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。模型对象/数值对象（Model Object/Value Object） - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。 实现我们将创建一个作为模型对象或数值对象的 Student 对象。StudentDao 是数据访问对象接口。StudentDaoImpl 是实现了数据访问对象接口的实体类。DaoPatternDemo，我们的演示类使用 StudentDao 来演示数据访问对象模式的用法。 步骤 1创建数值对象。 Student.java12345678910111213141516171819202122232425public class Student &#123; private String name; private int rollNo; Student(String name, int rollNo)&#123; this.name = name; this.rollNo = rollNo; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getRollNo() &#123; return rollNo; &#125; public void setRollNo(int rollNo) &#123; this.rollNo = rollNo; &#125;&#125; 步骤 2创建数据访问对象接口。 StudentDao.java12345678import java.util.List;public interface StudentDao &#123; public List&lt;Student&gt; getAllStudents(); public Student getStudent(int rollNo); public void updateStudent(Student student); public void deleteStudent(Student student);&#125; 步骤 3创建实现了上述接口的实体类。 StudentDaoImpl.java12345678910111213141516171819202122232425262728293031323334353637383940import java.util.ArrayList;import java.util.List;public class StudentDaoImpl implements StudentDao &#123; //列表是当作一个数据库 List&lt;Student&gt; students; public StudentDaoImpl()&#123; students = new ArrayList&lt;Student&gt;(); Student student1 = new Student("Robert",0); Student student2 = new Student("John",1); students.add(student1); students.add(student2); &#125; @Override public void deleteStudent(Student student) &#123; students.remove(student.getRollNo()); System.out.println("Student: Roll No " + student.getRollNo() +", deleted from database"); &#125; //从数据库中检索学生名单 @Override public List&lt;Student&gt; getAllStudents() &#123; return students; &#125; @Override public Student getStudent(int rollNo) &#123; return students.get(rollNo); &#125; @Override public void updateStudent(Student student) &#123; students.get(student.getRollNo()).setName(student.getName()); System.out.println("Student: Roll No " + student.getRollNo() +", updated in the database"); &#125;&#125; 步骤 4使用 StudentDao 来演示数据访问对象模式的用法。 DaoPatternDemo.java12345678910111213141516171819202122public class DaoPatternDemo &#123; public static void main(String[] args) &#123; StudentDao studentDao = new StudentDaoImpl(); //输出所有的学生 for (Student student : studentDao.getAllStudents()) &#123; System.out.println("Student: [RollNo : " +student.getRollNo()+", Name : "+student.getName()+" ]"); &#125; //更新学生 Student student =studentDao.getAllStudents().get(0); student.setName("Michael"); studentDao.updateStudent(student); //获取学生 studentDao.getStudent(0); System.out.println("Student: [RollNo : " +student.getRollNo()+", Name : "+student.getName()+" ]"); &#125;&#125; 步骤 5验证输出。1234Student: [RollNo : 0, Name : Robert ]Student: [RollNo : 1, Name : John ]Student: Roll No 0, updated in the databaseStudent: [RollNo : 0, Name : Michael ]]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>J2EE模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合实体模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F26%2Fdesign-pattern%2Fcomposite-entity-pattern%2F</url>
    <content type="text"><![CDATA[组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。 组合实体（Composite Entity） - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。粗粒度对象（Coarse-Grained Object） - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。依赖对象（Dependent Object） - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。策略（Strategies） - 策略表示如何实现组合实体。 实现我们将创建作为组合实体的 CompositeEntity 对象。CoarseGrainedObject 是一个包含依赖对象的类。CompositeEntityPatternDemo，我们的演示类使用 Client 类来演示组合实体模式的用法。 步骤 1创建依赖对象。DependentObject1.java123456789101112public class DependentObject1 &#123; private String data; public void setData(String data)&#123; this.data = data; &#125; public String getData()&#123; return data; &#125;&#125; DependentObject2.java123456789101112public class DependentObject2 &#123; private String data; public void setData(String data)&#123; this.data = data; &#125; public String getData()&#123; return data; &#125;&#125; 步骤 2创建粗粒度对象。 CoarseGrainedObject.java12345678910111213public class CoarseGrainedObject &#123; DependentObject1 do1 = new DependentObject1(); DependentObject2 do2 = new DependentObject2(); public void setData(String data1, String data2)&#123; do1.setData(data1); do2.setData(data2); &#125; public String[] getData()&#123; return new String[] &#123;do1.getData(),do2.getData()&#125;; &#125;&#125; 步骤 3创建组合实体。 CompositeEntity.java1234567891011public class CompositeEntity &#123; private CoarseGrainedObject cgo = new CoarseGrainedObject(); public void setData(String data1, String data2)&#123; cgo.setData(data1, data2); &#125; public String[] getData()&#123; return cgo.getData(); &#125;&#125; 步骤 4创建使用组合实体的客户端类。 Client.java12345678910111213public class Client &#123; private CompositeEntity compositeEntity = new CompositeEntity(); public void printData()&#123; for (int i = 0; i &lt; compositeEntity.getData().length; i++) &#123; System.out.println("Data: " + compositeEntity.getData()[i]); &#125; &#125; public void setData(String data1, String data2)&#123; compositeEntity.setData(data1, data2); &#125;&#125; 步骤 5使用 Client 来演示组合实体设计模式的用法。 CompositeEntityPatternDemo.java123456789public class CompositeEntityPatternDemo &#123; public static void main(String[] args) &#123; Client client = new Client(); client.setData("Test", "Data"); client.printData(); client.setData("Second Test", "Data1"); client.printData(); &#125;&#125; 步骤 6验证输出。1234Data: TestData: DataData: Second TestData: Data1]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>J2EE模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[业务代表模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F26%2Fdesign-pattern%2Fbusiness-delegate-pattern%2F</url>
    <content type="text"><![CDATA[业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。 客户端（Client） - 表示层代码可以是 JSP、servlet 或 UI java 代码。业务代表（Business Delegate） - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。查询服务（LookUp Service） - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。业务服务（Business Service） - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。 实现我们将创建 Client、BusinessDelegate、BusinessService、LookUpService、JMSService 和 EJBService 来表示业务代表模式中的各种实体。BusinessDelegatePatternDemo，我们的演示类使用 BusinessDelegate 和 Client 来演示业务代表模式的用法。 步骤 1创建 BusinessService 接口。BusinessService.java123public interface BusinessService &#123; public void doProcessing();&#125; 步骤 2创建实体服务类。EJBService.java1234567public class EJBService implements BusinessService &#123; @Override public void doProcessing() &#123; System.out.println("Processing task by invoking EJB Service"); &#125;&#125; JMSService.java1234567public class JMSService implements BusinessService &#123; @Override public void doProcessing() &#123; System.out.println("Processing task by invoking JMS Service"); &#125;&#125; 步骤 3创建业务查询服务。BusinessLookUp.java123456789public class BusinessLookUp &#123; public BusinessService getBusinessService(String serviceType)&#123; if(serviceType.equalsIgnoreCase("EJB"))&#123; return new EJBService(); &#125;else &#123; return new JMSService(); &#125; &#125;&#125; 步骤 4创建业务代表。BusinessDelegate.java1234567891011121314public class BusinessDelegate &#123; private BusinessLookUp lookupService = new BusinessLookUp(); private BusinessService businessService; private String serviceType; public void setServiceType(String serviceType)&#123; this.serviceType = serviceType; &#125; public void doTask()&#123; businessService = lookupService.getBusinessService(serviceType); businessService.doProcessing(); &#125;&#125; 步骤 5创建客户端。Client.java123456789101112public class Client &#123; BusinessDelegate businessService; public Client(BusinessDelegate businessService)&#123; this.businessService = businessService; &#125; public void doTask()&#123; businessService.doTask(); &#125;&#125; 步骤 6使用 BusinessDelegate 和 Client 类来演示业务代表模式。BusinessDelegatePatternDemo.java1234567891011121314public class BusinessDelegatePatternDemo &#123; public static void main(String[] args) &#123; BusinessDelegate businessDelegate = new BusinessDelegate(); businessDelegate.setServiceType("EJB"); Client client = new Client(businessDelegate); client.doTask(); businessDelegate.setServiceType("JMS"); client.doTask(); &#125;&#125; 步骤 7验证输出。12Processing task by invoking EJB ServiceProcessing task by invoking JMS Service]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>J2EE模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC 模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F26%2Fdesign-pattern%2Fmvc-pattern%2F</url>
    <content type="text"><![CDATA[MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。 Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。View（视图） - 视图代表模型包含的数据的可视化。Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。 实现我们将创建一个作为模型的 Student 对象。StudentView 是一个把学生详细信息输出到控制台的视图类，StudentController 是负责存储数据到 Student 对象中的控制器类，并相应地更新视图 StudentView。MVCPatternDemo，我们的演示类使用 StudentController 来演示 MVC 模式的用法。 步骤 1创建模型。Student.java12345678910111213141516public class Student &#123; private String rollNo; private String name; public String getRollNo() &#123; return rollNo; &#125; public void setRollNo(String rollNo) &#123; this.rollNo = rollNo; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 步骤 2创建视图。8StudentView.java*1234567public class StudentView &#123; public void printStudentDetails(String studentName, String studentRollNo)&#123; System.out.println("Student: "); System.out.println("Name: " + studentName); System.out.println("Roll No: " + studentRollNo); &#125;&#125; 步骤 3创建控制器。StudentController.java1234567891011121314151617181920212223242526272829public class StudentController &#123; private Student model; private StudentView view; public StudentController(Student model, StudentView view)&#123; this.model = model; this.view = view; &#125; public void setStudentName(String name)&#123; model.setName(name); &#125; public String getStudentName()&#123; return model.getName(); &#125; public void setStudentRollNo(String rollNo)&#123; model.setRollNo(rollNo); &#125; public String getStudentRollNo()&#123; return model.getRollNo(); &#125; public void updateView()&#123; view.printStudentDetails(model.getName(), model.getRollNo()); &#125;&#125; 步骤 4使用 StudentController 方法来演示 MVC 设计模式的用法。MVCPatternDemo.java1234567891011121314151617181920212223242526public class MVCPatternDemo &#123; public static void main(String[] args) &#123; //从数据可获取学生记录 Student model = retriveStudentFromDatabase(); //创建一个视图：把学生详细信息输出到控制台 StudentView view = new StudentView(); StudentController controller = new StudentController(model, view); controller.updateView(); //更新模型数据 controller.setStudentName("John"); controller.updateView(); &#125; private static Student retriveStudentFromDatabase()&#123; Student student = new Student(); student.setName("Robert"); student.setRollNo("10"); return student; &#125;&#125; 步骤 5验证输出。123456Student:Name: RobertRoll No: 10Student:Name: JohnRoll No: 10]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>J2EE模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问者模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F26%2Fdesign-pattern%2Fvisitor-pattern%2F</url>
    <content type="text"><![CDATA[在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。 介绍意图：主要将数据结构与数据操作分离。主要解决：稳定的数据结构和易变的操作耦合问题。何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。如何解决：在被访问的类里面加一个对外提供接待访问者的接口。关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。优点： 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。缺点： 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。使用场景： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。 实现我们将创建一个定义接受操作的 ComputerPart 接口。Keyboard、Mouse、Monitor 和 Computer 是实现了 ComputerPart 接口的实体类。我们将定义另一个接口 ComputerPartVisitor，它定义了访问者类的操作。Computer 使用实体访问者来执行相应的动作。VisitorPatternDemo，我们的演示类使用 Computer、ComputerPartVisitor 类来演示访问者模式的用法。 步骤 1定义一个表示元素的接口。ComputerPart.java123public interface ComputerPart &#123; public void accept(ComputerPartVisitor computerPartVisitor);&#125; 步骤 2创建扩展了上述类的实体类。Keyboard.java1234567public class Keyboard implements ComputerPart &#123; @Override public void accept(ComputerPartVisitor computerPartVisitor) &#123; computerPartVisitor.visit(this); &#125;&#125; Monitor.java1234567public class Monitor implements ComputerPart &#123; @Override public void accept(ComputerPartVisitor computerPartVisitor) &#123; computerPartVisitor.visit(this); &#125;&#125; Mouse.java1234567public class Mouse implements ComputerPart &#123; @Override public void accept(ComputerPartVisitor computerPartVisitor) &#123; computerPartVisitor.visit(this); &#125;&#125; Computer.java12345678910111213141516public class Computer implements ComputerPart &#123; ComputerPart[] parts; public Computer()&#123; parts = new ComputerPart[] &#123;new Mouse(), new Keyboard(), new Monitor()&#125;; &#125; @Override public void accept(ComputerPartVisitor computerPartVisitor) &#123; for (int i = 0; i &lt; parts.length; i++) &#123; parts[i].accept(computerPartVisitor); &#125; computerPartVisitor.visit(this); &#125;&#125; 步骤 3定义一个表示访问者的接口。ComputerPartVisitor.java123456public interface ComputerPartVisitor &#123; public void visit(Computer computer); public void visit(Mouse mouse); public void visit(Keyboard keyboard); public void visit(Monitor monitor);&#125; 步骤 4创建实现了上述类的实体访问者。ComputerPartDisplayVisitor.java12345678910111213141516171819202122public class ComputerPartDisplayVisitor implements ComputerPartVisitor &#123; @Override public void visit(Computer computer) &#123; System.out.println("Displaying Computer."); &#125; @Override public void visit(Mouse mouse) &#123; System.out.println("Displaying Mouse."); &#125; @Override public void visit(Keyboard keyboard) &#123; System.out.println("Displaying Keyboard."); &#125; @Override public void visit(Monitor monitor) &#123; System.out.println("Displaying Monitor."); &#125;&#125; 步骤 5使用 ComputerPartDisplayVisitor 来显示 Computer 的组成部分。VisitorPatternDemo.java1234567public class VisitorPatternDemo &#123; public static void main(String[] args) &#123; ComputerPart computer = new Computer(); computer.accept(new ComputerPartDisplayVisitor()); &#125;&#125; 步骤 6验证输出。1234Displaying Mouse.Displaying Keyboard.Displaying Monitor.Displaying Computer.]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) IP：网际协议]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F25%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-internet-protocol%2F</url>
    <content type="text"><![CDATA[IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输。IP提供不可靠、无连接的数据报传送服务。不可靠（unreliable）的意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）。无连接（connectionless）这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明，IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达。 IP首部 普通的IP首部长为20个字节，除非含有选项字段。 4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15 bit，然后16～23 bit，最后是24~31 bit。这种传输次序称作big endian字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。以其他形式存储二进制整数的机器，如little endian格式，则必须在传输数据之前把首部转换成网络字节序。 目前的协议版本号是4，因此IP有时也称作IPv4。 首部长度指的是首部占32 bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部最长为60个字节。 服务类型（TOS）字段包括一个3bit的优先权子字段（现在已被忽略），4bit的TOS子字段和1bit未用位但必须置0。4bit的TO S分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。4bit中只能置其中1bit。如果所有4bit均为0，那么就意味着是一般服务。对不同应用建议的TOS值: 总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度字段和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16比特，所以IP数据报最长可达65535字节（回忆图2-5，超级通道的MTU为65535。它的意思其实不是一个真正的MTU—它使用了最长的IP数据报）。当数据报被分片时，该字段的值也随着变化。 标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。 TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。 协议字段被IP用来对数据报进行分用。根据它可以识别是哪个协议向IP传送数据。 首部检验和字段是根据IP首部计算的检验和码。它不对首部后面的数据进行计算。ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。 为了计算一份数据报的IP检验和，首先把检验和字段置为0。然后，对首部中每个16 bit进行二进制反码求和（整个首部看成是由一串16 bit的字组成），结果存在检验和字段中。当收到一份IP数据报后，同样对首部中每个16 bit进行二进制反码的求和。由于接收方在计算过程中包含了发送方存在首部中的检验和，因此，如果首部在传输过程中没有发生任何差错，那么接收方计算的结果应该为全1。如果结果不是全1（即检验和错误），那么IP就丢弃收到的数据报。但是不生成差错报文，由上层去发现丢失的数据报并进行重传。 ICMP、IGMP、UDP和TCP都采用相同的检验和算法，尽管TCP和UDP除了本身的首部和数据外，在IP首部中还包含不同的字段。由于路由器经常只修改TTL字段（减1），因此当路由器转发一份报文时可以增加它的检验和，而不需要对IP整个首部进行重新计算。 每一份IP数据报都包含源IP地址和目的IP地址。它们都是32 bit的值。 最后一个字段是任选项，是数据报中的一个可变长的可选信息。目前，这些任选项定义如下： 安全和处理限制（用于军事领域，详细内容参见RFC 1108[Kent 1991]） 记录路径（让每个路由器都记下它的IP地址，见7.3节） 时间戳（让每个路由器都记下它的IP地址和时间，见7.4节） 宽松的源站选路（为数据报指定一系列必须经过的IP地址，见8.5节） 严格的源站选路（与宽松的源站选路类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。 这些选项很少被使用，并非所有的主机和路由器都支持这些选项。 选项字段一直都是以32 bit作为界限，在必要的时候插入值为0的填充字节。这样就保证IP首部始终是32 bit的整数倍（这是首部长度字段所要求的）。 IP 路由选择路由表中的每一项都包含下面这些信息： 目的IP地址。它既可以是一个完整的主机地址，也可以是一个网络地址，由该表目中的标志字段来指定（如下所述）。主机地址有一个非0的主机号，以指定某一特定的主机，而网络地址中的主机号为0，以指定网络中的所有主机（如以太网，令牌环网）。 下一站（或下一跳）路由器（next-hop router）的IP地址，或者有直接连接的网络IP地址。下一站路由器是指一个在直接相连网络上的路由器，通过它可以转发数据报。下一站路由器不是最终的目的，但是它可以把传送给它的数据报转发到最终目的。 标志。其中一个标志指明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口。 为数据报的传输指定一个网络接口。 IP路由选择主要完成以下这些功能： 搜索路由表，寻找能与目的IP地址完全匹配的表目（网络号和主机号都要匹配）。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。 搜索路由表，寻找能与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。目的网络上的所有主机都可以通过这个表目来处置。例如，一个以太网上的所有主机都是通过这种表目进行寻径的。这种搜索网络的匹配方法必须考虑可能的子网掩码。关于这一点我们在下一节中进行讨论。 搜索路由表，寻找标为“默认（default）”的表目。如果找到，则把报文发送给该表目指定的下一站路由器。如果上面这些步骤都没有成功，那么该数据报就不能被传送。 如果不能传送的数据报来自本机，那么一般会向生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。 完整主机地址匹配在网络号匹配之前执行。只有当它们都失败后才选择默认路由。默认路由，以及下一站路由器发送的ICMP间接报文（如果我们为数据报选择了错误的默认路由），是IP路由选择机制中功能强大的特性。 子网寻址不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号。这样做的原因是因为A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数为$2^{24}-2$和$2^{16}-2$。 子网掩码给定IP地址和子网掩码以后，主机就可以确定IP数据报的目的是：(1)本子网上的主机；(2)本网络中其他子网中的主机；(3)其他网络上的主机。如果知道本机的IP地址，那么就知道它是否为A类、B类或C类地址(从IP地址的高位可以得知)，也就知道网络号和子网号之间的分界线。而根据子网掩码就可知道子网号与主机号之间的分界线。 特殊情况的IP地址 0表示所有的比特位全为0；-1表示所有的比特位全为1；netid、subnetid和hostid分别表示不为全0或全1的对应字段。子网号栏为空表示该地址没有进行子网划分。 表的头两项是特殊的源地址，中间项是特殊的环回地址，最后四项是广播地址。 表中的头两项，网络号为0，如主机使用BOOTP协议确定本机IP地址时只能作为初始化过程中的源地址出现。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F25%2Fdesign-pattern%2Ftemplate-pattern%2F</url>
    <content type="text"><![CDATA[在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 介绍意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。主要解决：一些方法通用，却在每一个子类都重新写了这一方法。何时使用：有一些通用的方法。如何解决：将这些通用算法抽象出来。关键代码：在抽象类实现，其他步骤在子类实现。应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。 实现我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。TemplatePatternDemo，我们的演示类使用 Game 来演示模板模式的用法。 步骤 1创建一个抽象类，它的模板方法被设置为 final。Game.java123456789101112131415161718public abstract class Game &#123; abstract void initialize(); abstract void startPlay(); abstract void endPlay(); //模板 public final void play()&#123; //初始化游戏 initialize(); //开始游戏 startPlay(); //结束游戏 endPlay(); &#125;&#125; 步骤 2创建扩展了上述类的实体类。Cricket.java1234567891011121314151617public class Cricket extends Game &#123; @Override void endPlay() &#123; System.out.println("Cricket Game Finished!"); &#125; @Override void initialize() &#123; System.out.println("Cricket Game Initialized! Start playing."); &#125; @Override void startPlay() &#123; System.out.println("Cricket Game Started. Enjoy the game!"); &#125;&#125; Football.java1234567891011121314151617public class Football extends Game &#123; @Override void endPlay() &#123; System.out.println("Football Game Finished!"); &#125; @Override void initialize() &#123; System.out.println("Football Game Initialized! Start playing."); &#125; @Override void startPlay() &#123; System.out.println("Football Game Started. Enjoy the game!"); &#125;&#125; 步骤 3使用 Game 的模板方法 play() 来演示游戏的定义方式。TemplatePatternDemo.java12345678910public class TemplatePatternDemo &#123; public static void main(String[] args) &#123; Game game = new Cricket(); game.play(); System.out.println(); game = new Football(); game.play(); &#125;&#125; 步骤 4验证输出。1234567Cricket Game Initialized! Start playing.Cricket Game Started. Enjoy the game!Cricket Game Finished!Football Game Initialized! Start playing.Football Game Started. Enjoy the game!Football Game Finished!]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F25%2Fdesign-pattern%2Fstrategy-pattern%2F</url>
    <content type="text"><![CDATA[在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 介绍意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。如何解决：将这些算法封装成一个一个的类，任意地替换。关键代码：实现同一个接口。应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 实现我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。 步骤 1创建一个接口。Strategy.java123public interface Strategy &#123; public int doOperation(int num1, int num2);&#125; 步骤 2创建实现接口的实体类。OperationAdd.java123456public class OperationAdd implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 + num2; &#125;&#125; OperationSubstract.java123456public class OperationSubstract implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 - num2; &#125;&#125; OperationMultiply.java123456public class OperationMultiply implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 * num2; &#125;&#125; 步骤 3创建 Context 类。Context.java1234567891011public class Context &#123; private Strategy strategy; public Context(Strategy strategy)&#123; this.strategy = strategy; &#125; public int executeStrategy(int num1, int num2)&#123; return strategy.doOperation(num1, num2); &#125;&#125; 步骤 4使用 Context 来查看当它改变策略 Strategy 时的行为变化。StrategyPatternDemo.java123456789101112public class StrategyPatternDemo &#123; public static void main(String[] args) &#123; Context context = new Context(new OperationAdd()); System.out.println("10 + 5 = " + context.executeStrategy(10, 5)); context = new Context(new OperationSubstract()); System.out.println("10 - 5 = " + context.executeStrategy(10, 5)); context = new Context(new OperationMultiply()); System.out.println("10 * 5 = " + context.executeStrategy(10, 5)); &#125;&#125; 步骤 5验证输出。12310 + 5 = 1510 - 5 = 510 * 5 = 50]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空对象模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F25%2Fdesign-pattern%2Fnull-object-pattern%2F</url>
    <content type="text"><![CDATA[在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。 实现我们将创建一个定义操作（在这里，是客户的名称）的 AbstractCustomer 抽象类，和扩展了 AbstractCustomer 类的实体类。工厂类 CustomerFactory 基于客户传递的名字来返回 RealCustomer 或 NullCustomer 对象。NullPatternDemo，我们的演示类使用 CustomerFactory 来演示空对象模式的用法。 步骤 1创建一个抽象类。AbstractCustomer.java12345public abstract class AbstractCustomer &#123; protected String name; public abstract boolean isNil(); public abstract String getName();&#125; 步骤 2创建扩展了上述类的实体类。8RealCustomer.java*12345678910111213141516public class RealCustomer extends AbstractCustomer &#123; public RealCustomer(String name) &#123; this.name = name; &#125; @Override public String getName() &#123; return name; &#125; @Override public boolean isNil() &#123; return false; &#125;&#125; NullCustomer.java123456789101112public class NullCustomer extends AbstractCustomer &#123; @Override public String getName() &#123; return "Not Available in Customer Database"; &#125; @Override public boolean isNil() &#123; return true; &#125;&#125; 步骤 3创建 CustomerFactory 类。CustomerFactory.java12345678910111213public class CustomerFactory &#123; public static final String[] names = &#123;"Rob", "Joe", "Julie"&#125;; public static AbstractCustomer getCustomer(String name)&#123; for (int i = 0; i &lt; names.length; i++) &#123; if (names[i].equalsIgnoreCase(name))&#123; return new RealCustomer(name); &#125; &#125; return new NullCustomer(); &#125;&#125; 步骤 4使用 CustomerFactory，基于客户传递的名字，来获取 RealCustomer 或 NullCustomer 对象。NullPatternDemo.java123456789101112131415public class NullPatternDemo &#123; public static void main(String[] args) &#123; AbstractCustomer customer1 = CustomerFactory.getCustomer("Rob"); AbstractCustomer customer2 = CustomerFactory.getCustomer("Bob"); AbstractCustomer customer3 = CustomerFactory.getCustomer("Julie"); AbstractCustomer customer4 = CustomerFactory.getCustomer("Laura"); System.out.println("Customers"); System.out.println(customer1.getName()); System.out.println(customer2.getName()); System.out.println(customer3.getName()); System.out.println(customer4.getName()); &#125;&#125; 步骤 5验证输出。12345CustomersRobNot Available in Customer DatabaseJulieNot Available in Customer Database]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F25%2Fdesign-pattern%2Fstate-pattern%2F</url>
    <content type="text"><![CDATA[在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。 介绍意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。何时使用：代码中包含大量与对象状态有关的条件语句。如何解决：将各种具体的状态类抽象出来。关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。应用实例： 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。优点： 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。缺点： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。使用场景： 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。 实现我们将创建一个 State 接口和实现了 State 接口的实体状态类。Context 是一个带有某个状态的类。StatePatternDemo，我们的演示类使用 Context 和状态对象来演示 Context 在状态改变时的行为变化。 步骤 1创建一个接口。State.java123public interface State &#123; public void doAction(Context context);&#125; 步骤 2创建实现接口的实体类。StartState.java1234567891011public class StartState implements State &#123; public void doAction(Context context) &#123; System.out.println("Player is in start state"); context.setState(this); &#125; public String toString()&#123; return "Start State"; &#125;&#125; StopState.java1234567891011public class StopState implements State &#123; public void doAction(Context context) &#123; System.out.println("Player is in stop state"); context.setState(this); &#125; public String toString()&#123; return "Stop State"; &#125;&#125; 步骤 3创建 Context 类。Context.java123456789101112131415public class Context &#123; private State state; public Context()&#123; state = null; &#125; public void setState(State state)&#123; this.state = state; &#125; public State getState()&#123; return state; &#125;&#125; 步骤 4使用 Context 来查看当状态 State 改变时的行为变化。StatePatternDemo.java123456789101112131415public class StatePatternDemo &#123; public static void main(String[] args) &#123; Context context = new Context(); StartState startState = new StartState(); startState.doAction(context); System.out.println(context.getState().toString()); StopState stopState = new StopState(); stopState.doAction(context); System.out.println(context.getState().toString()); &#125;&#125; 步骤 5验证输出。1234Player is in start stateStart StatePlayer is in stop stateStop State]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F24%2Fdesign-pattern%2Fobserver-pattern%2F</url>
    <content type="text"><![CDATA[当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。 介绍意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。如何解决：使用面向对象技术，可以将这种依赖关系弱化。关键代码：在抽象类里有一个 ArrayList 存放观察者们。应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。使用场景： 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。 实现观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。ObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。 步骤 1创建 Subject 类。Subject.java12345678910111213141516171819202122232425262728import java.util.ArrayList;import java.util.List;public class Subject &#123; private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); private int state; public int getState() &#123; return state; &#125; public void setState(int state) &#123; this.state = state; notifyAllObservers(); &#125; public void attach(Observer observer)&#123; observers.add(observer); &#125; public void notifyAllObservers()&#123; for (Observer observer : observers) &#123; observer.update(); &#125; &#125;&#125; 步骤 2创建 Observer 类。Observer.java1234public abstract class Observer &#123; protected Subject subject; public abstract void update();&#125; 步骤 3创建实体观察者类。BinaryObserver.java12345678910111213public class BinaryObserver extends Observer&#123; public BinaryObserver(Subject subject)&#123; this.subject = subject; this.subject.attach(this); &#125; @Override public void update() &#123; System.out.println( "Binary String: " + Integer.toBinaryString( subject.getState() ) ); &#125;&#125; OctalObserver.java12345678910111213public class OctalObserver extends Observer&#123; public OctalObserver(Subject subject)&#123; this.subject = subject; this.subject.attach(this); &#125; @Override public void update() &#123; System.out.println( "Octal String: " + Integer.toOctalString( subject.getState() ) ); &#125;&#125; HexaObserver.java12345678910111213public class HexaObserver extends Observer&#123; public HexaObserver(Subject subject)&#123; this.subject = subject; this.subject.attach(this); &#125; @Override public void update() &#123; System.out.println( "Hex String: " + Integer.toHexString( subject.getState() ).toUpperCase() ); &#125;&#125; 步骤 4使用 Subject 和实体观察者对象。ObserverPatternDemo.java1234567891011121314public class ObserverPatternDemo &#123; public static void main(String[] args) &#123; Subject subject = new Subject(); new HexaObserver(subject); new OctalObserver(subject); new BinaryObserver(subject); System.out.println("First state change: 15"); subject.setState(15); System.out.println("Second state change: 10"); subject.setState(10); &#125;&#125; 步骤 5验证输出。12345678First state change: 15Hex String: FOctal String: 17Binary String: 1111Second state change: 10Hex String: AOctal String: 12Binary String: 1010]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备忘录模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F24%2Fdesign-pattern%2Fmemento-pattern%2F</url>
    <content type="text"><![CDATA[备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。 介绍意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。如何解决：通过一个备忘录类专门存储对象状态。关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。应用实例： 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。优点： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。使用场景： 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。注意事项： 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。 实现备忘录模式使用三个类 Memento、Originator 和 CareTaker。Memento 包含了要被恢复的对象的状态。Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。MementoPatternDemo，我们的演示类使用 CareTaker 和 Originator 对象来显示对象的状态恢复。 步骤 1创建 Memento 类。Memento.java1234567891011public class Memento &#123; private String state; public Memento(String state)&#123; this.state = state; &#125; public String getState()&#123; return state; &#125;&#125; 步骤 2创建 Originator 类。Originator.java12345678910111213141516171819public class Originator &#123; private String state; public void setState(String state)&#123; this.state = state; &#125; public String getState()&#123; return state; &#125; public Memento saveStateToMemento()&#123; return new Memento(state); &#125; public void getStateFromMemento(Memento Memento)&#123; state = Memento.getState(); &#125;&#125; 步骤 3创建 CareTaker 类。CareTaker.java1234567891011121314import java.util.ArrayList;import java.util.List;public class CareTaker &#123; private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;(); public void add(Memento state)&#123; mementoList.add(state); &#125; public Memento get(int index)&#123; return mementoList.get(index); &#125;&#125; 步骤 4使用 CareTaker 和 Originator 对象。MementoPatternDemo.java123456789101112131415161718public class MementoPatternDemo &#123; public static void main(String[] args) &#123; Originator originator = new Originator(); CareTaker careTaker = new CareTaker(); originator.setState("State #1"); originator.setState("State #2"); careTaker.add(originator.saveStateToMemento()); originator.setState("State #3"); careTaker.add(originator.saveStateToMemento()); originator.setState("State #4"); System.out.println("Current State: " + originator.getState()); originator.getStateFromMemento(careTaker.get(0)); System.out.println("First saved State: " + originator.getState()); originator.getStateFromMemento(careTaker.get(1)); System.out.println("Second saved State: " + originator.getState()); &#125;&#125; 步骤 5验证输出。123Current State: State #4First saved State: State #2Second saved State: State #3]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中介者模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F24%2Fdesign-pattern%2Fmediator-pattern%2F</url>
    <content type="text"><![CDATA[中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 介绍意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。何时使用：多个类相互耦合，形成了网状结构。如何解决：将上述网状结构分离为星型结构。关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。应用实例： 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。优点： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。缺点：中介者会庞大，变得复杂难以维护。使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。注意事项：不应当在职责混乱的时候使用。 实现我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 ChatRoom 和 User。User 对象使用 ChatRoom 方法来分享他们的消息。MediatorPatternDemo，我们的演示类使用 User 对象来显示他们之间的通信。 步骤 1创建中介类。ChatRoom.java12345678import java.util.Date;public class ChatRoom &#123; public static void showMessage(User user, String message)&#123; System.out.println(new Date().toString() + " [" + user.getName() +"] : " + message); &#125;&#125; 步骤 2创建 user 类。User.java12345678910111213141516171819public class User &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public User(String name)&#123; this.name = name; &#125; public void sendMessage(String message)&#123; ChatRoom.showMessage(this,message); &#125;&#125; 步骤 3使用 User 对象来显示他们之间的通信。MediatorPatternDemo.java123456789public class MediatorPatternDemo &#123; public static void main(String[] args) &#123; User robert = new User("Robert"); User john = new User("John"); robert.sendMessage("Hi! John!"); john.sendMessage("Hello! Robert!"); &#125;&#125; 步骤 4验证输出。12Thu Jan 31 16:05:46 IST 2013 [Robert] : Hi! John!Thu Jan 31 16:05:46 IST 2013 [John] : Hello! Robert!]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F24%2Fdesign-pattern%2Fiterator-pattern%2F</url>
    <content type="text"><![CDATA[迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。迭代器模式属于行为型模式。 介绍意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。主要解决：不同的方式来遍历整个整合对象。何时使用：遍历一个聚合对象。如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。关键代码：定义接口：hasNext, next。应用实例：JAVA 中的 iterator。优点： 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。使用场景： 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。 实现我们将创建一个叙述导航方法的 Iterator 接口和一个返回迭代器的 Container 接口。实现了 Container 接口的实体类将负责实现 Iterator 接口。IteratorPatternDemo，我们的演示类使用实体类 NamesRepository 来打印 NamesRepository 中存储为集合的 Names。 步骤 1创建接口。Iterator.java1234public interface Iterator &#123; public boolean hasNext(); public Object next();&#125; Container.java123public interface Container &#123; public Iterator getIterator();&#125; 步骤 2创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 NameIterator。NameRepository.java1234567891011121314151617181920212223242526272829public class NameRepository implements Container &#123; public String names[] = &#123;"Robert" , "John" ,"Julie" , "Lora"&#125;; @Override public Iterator getIterator() &#123; return new NameIterator(); &#125; private class NameIterator implements Iterator &#123; int index; @Override public boolean hasNext() &#123; if(index &lt; names.length)&#123; return true; &#125; return false; &#125; @Override public Object next() &#123; if(this.hasNext())&#123; return names[index++]; &#125; return null; &#125; &#125;&#125; 步骤 3使用 NameRepository 来获取迭代器，并打印名字。IteratorPatternDemo.java1234567891011public class IteratorPatternDemo &#123; public static void main(String[] args) &#123; NameRepository namesRepository = new NameRepository(); for(Iterator iter = namesRepository.getIterator(); iter.hasNext();)&#123; String name = (String)iter.next(); System.out.println("Name : " + name); &#125; &#125;&#125; 步骤 4验证输出。1234Name : RobertName : JohnName : JulieName : Lora]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解释器模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F24%2Fdesign-pattern%2Finterpreter-pattern%2F</url>
    <content type="text"><![CDATA[解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。 介绍意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。主要解决：对于一些固定文法构建一个解释句子的解释器。何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。如何解决：构件语法树，定义终结符与非终结符。关键代码：构件环境类，包含解释器之外的一些全局信息，一般是 HashMap。应用实例：编译器、运算表达式计算。优点： 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。缺点： 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。使用场景： 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。 实现我们将创建一个接口 Expression 和实现了 Expression 接口的实体类。定义作为上下文中主要解释器的 TerminalExpression 类。其他的类 OrExpression、AndExpression 用于创建组合式表达式。InterpreterPatternDemo，我们的演示类使用 Expression 类创建规则和演示表达式的解析。 步骤 1创建一个表达式接口。Expression.java123public interface Expression &#123; public boolean interpret(String context);&#125; 步骤 2创建实现了上述接口的实体类。TerminalExpression.java12345678910111213141516public class TerminalExpression implements Expression &#123; private String data; public TerminalExpression(String data)&#123; this.data = data; &#125; @Override public boolean interpret(String context) &#123; if(context.contains(data))&#123; return true; &#125; return false; &#125;&#125; OrExpression.java123456789101112131415public class OrExpression implements Expression &#123; private Expression expr1 = null; private Expression expr2 = null; public OrExpression(Expression expr1, Expression expr2) &#123; this.expr1 = expr1; this.expr2 = expr2; &#125; @Override public boolean interpret(String context) &#123; return expr1.interpret(context) || expr2.interpret(context); &#125;&#125; AndExpression.java123456789101112131415public class AndExpression implements Expression &#123; private Expression expr1 = null; private Expression expr2 = null; public AndExpression(Expression expr1, Expression expr2) &#123; this.expr1 = expr1; this.expr2 = expr2; &#125; @Override public boolean interpret(String context) &#123; return expr1.interpret(context) &amp;&amp; expr2.interpret(context); &#125;&#125; 步骤 3InterpreterPatternDemo 使用 Expression 类来创建规则，并解析它们。InterpreterPatternDemo.java12345678910111213141516171819202122232425public class InterpreterPatternDemo &#123; //规则：Robert 和 John 是男性 public static Expression getMaleExpression()&#123; Expression robert = new TerminalExpression("Robert"); Expression john = new TerminalExpression("John"); return new OrExpression(robert, john); &#125; //规则：Julie 是一个已婚的女性 public static Expression getMarriedWomanExpression()&#123; Expression julie = new TerminalExpression("Julie"); Expression married = new TerminalExpression("Married"); return new AndExpression(julie, married); &#125; public static void main(String[] args) &#123; Expression isMale = getMaleExpression(); Expression isMarriedWoman = getMarriedWomanExpression(); System.out.println("John is male? " + isMale.interpret("John")); System.out.println("Julie is a married women? " + isMarriedWoman.interpret("Married Julie")); &#125;&#125; 步骤 4验证输出。12John is male? trueJulie is a married women? true]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) 链路层]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F24%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-link-layer%2F</url>
    <content type="text"><![CDATA[在 TCP/IP 协议族中，链路层主要有三个目的：（1）为 IP 模块发送和接收 IP 数据报；（2）为 ARP 模块发送 ARP 请求和接收 ARP 应答；（3）为 RARP 发送 RARP 请求和接收 RARP 应答。 以太网和 IEEE 802封装主机需求 RFC 要求每台 Internet 主机都与一个10 Mb/s的以太网电缆相连接： 必须能发送和接收采用 RFC 894（以太网）封装格式的分组。 应该能接收与 RFC 894 混合的 RFC 1042（IEEE 802）封装格式的分组。 也许能够发送采用 RFC 1042 格式封装的分组。如果主机能同时发送两种类型的分组数据，那么发送的分组必须是可以设置的，而且默认条件下必须是 RFC 894 分组。 两种格式都采用48bit（6字节）的目的地址和源地址。接下来的2个字节在两种帧格式中互不相同。在802标准定义的帧格式中，长度字段是指它后续数据的字节长度，但不包括 CRC 检验码。以太网的类型字段定义了后续数据的类型。在802标准定义的帧格式中，类型字段则由后续的子网接入协议（Sub-network Access Protocol，SNAP）的首部给出。幸运的是， 802定义的有效长度值与以太网的有效类型值无一相同，这样，就可以对两种帧格式进行区分。 802.3标准定义的帧和以太网的帧都有最小长度要求。 802.3规定数据部分必须至少为38字节,而对于以太网,则要求最少要有46字节。 为了保证这一点, 必须在不足的空间插入填充(pad)字节。 SLIP 串行线路IP下面的规则描述了SLIP协议定义的帧格式： IP数据报以一个称作END（0xc0）的特殊字符结束。同时，为了防止数据报到来之前的线路噪声被当成数据报内容，大多数实现在数据报的开始处也传一个END字符（如果有线路噪声，那么END字符将结束这份错误的报文。这样当前的报文得以正确地传输，而前一个错误报文交给上层后，会发现其内容毫无意义而被丢弃）。 如果IP报文中某个字符为END，那么就要连续传输两个字节0xdb和0xdc来取代它。0xdb这个特殊字符被称作SLIP的ESC字符，但是它的值与ASCII码的ESC字符（0x1b）不同。 如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它。 SLIP是一种简单的帧封装方法，还有一些值得一提的缺陷： 每一端必须知道对方的IP地址。没有办法把本端的IP地址通知给另一端。 数据帧中没有类型字段（类似于以太网中的类型字段）。如果一条串行线路用于SLIP，那么它不能同时使用其他协议。 SLIP没有在数据帧中加上检验和（类似于以太网中的CRC字段）。如果SLIP传输的报文被线路噪声影响而发生错误，只能通过上层协议来发现（另一种方法是，新型的调制解调器可以检测并纠正错误报文）。这样，上层协议提供某种形式的CRC就显得很重要。IP首部和TCP首部及其数据始终都有检验和。UDP首部及其数据的检验和却是可选的。 压缩的SLIP由于串行线路的速率通常较低（19200 b/s或更低），而且通信经常是交互式的（如Telnet和Rlogin，二者都使用TCP），因此在SLIP线路上有许多小的TCP分组进行交换。为了传送1个字节的数据需要20个字节的IP首部和20个字节的TCP首部，总数超过40个字节。 既然承认这些性能上的缺陷，于是人们提出一个被称作CSLIP（即压缩SLIP）的新协议，它在RFC 1144[Jacobson 1990a]中被详细描述。CSLIP一般能把上面的40个字节压缩到3或5个字节。它能在CSLIP的每一端维持多达16个TCP连接，并且知道其中每个连接的首部中的某些字段一般不会发生变化。对于那些发生变化的字段，大多数只是一些小的数字和的改变。这些被压缩的首部大大地缩短了交互响应时间。 PPP：点对点协议PPP，点对点协议修改了SLIP协议中的所有缺陷。PPP包括以下三个部分： 在串行链路上封装IP数据报的方法。PPP既支持数据为8位和无奇偶检验的异步模式（如大多数计算机上都普遍存在的串行接口），还支持面向比特的同步链接。 建立、配置及测试数据链路的链路控制协议（LCP：Link Control Protocol）。它允许通信双方进行协商，以确定不同的选项。 针对不同网络层协议的网络控制协议（NCP：Network Control Protocol）体系。当前RFC定义的网络层有IP、OSI网络层、DECnet以及AppleTalk。例如，IP NCP允许双方商定是否对报文首部进行压缩，类似于CSLIP（缩写词NCP也可用在TCP的前面）。 CRC字段（或FCS，帧检验序列）是一个循环冗余检验码，以检测数据帧中的错误。 由于标志字符的值是0x7e，因此当该字符出现在信息字段中时，PPP需要对它进行转义。在同步链路中，该过程是通过一种称作比特填充(bit stuffing)的硬件技术来完成的[Tanenbaum 1989]。在异步链路中，特殊字符0x7d用作转义字符。当它出现在PPP数据帧中时，那么紧接着的字符的第6个比特要取其补码，具体实现过程如下： 当遇到字符0x7e时，需连续传送两个字符：0x7d和0x5e，以实现标志字符的转义。 当遇到转义字符0x7d时，需连续传送两个字符：0x7d和0x5d，以实现转义字符的转义。 默认情况下，如果字符的值小于0x20（比如，一个ASCII控制字符），一般都要进行转义。例如，遇到字符0x01时需连续传送0x7d和0x21两个字符（这时，第6个比特取补码后变为1，而前面两种情况均把它变为0）。 总的来说，PPP比SLIP具有下面这些优点：(1)PPP支持在单根串行线路上运行多种协议，不只是IP协议；(2)每一帧都有循环冗余检验；(3)通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；(4)与CSLIP类似，对TCP和IP报文首部进行压缩；(5)链路控制协议可以对多个数据链路选项进行设置。为这些优点付出的代价是在每一帧的首部增加3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。 环回接口大多数的产品都支持环回接口（Loopback Interface），以允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信。A类网络号127就是为环回接口预留的。根据惯例，大多数系统把IP地址127.0.0.1分配给这个接口，并命名为localhost。一个传给环回接口的IP数据报不能在任何网络上出现。 我们想象，一旦传输层检测到目的端地址是环回地址时，应该可以省略部分传输层和所有网络层的逻辑操作。但是大多数的产品还是照样完成传输层和网络层的所有过程，只是当IP数据报离开网络层时把它返回给自己。 传给环回地址（一般是127.0.0.1）的任何数据均作为IP输入。 传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是因为广播传送和多播传送的定义（第12章）包含主机本身。 任何传给该主机IP地址的数据均送到环回接口。 最大传输单元MTU以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。链路层的这个特性称作MTU,最大传输单元。 如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大,那么IP层就需要进行分片（fragmentation），把数据报分成若干片，这样每一片都小于MTU。 路径MTU当在同一个网络上的两台主机互相进行通信时，该网络的MTU是非常重要的。但是如果两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的MTU。重要的不是两台主机所在网络的MTU的值，重要的是两台通信主机路径中的最小MTU。它被称作路径MTU。 两台主机之间的路径MTU不一定是个常数。它取决于当时所选择的路由。而选路不一定是对称的（从A到B的路由可能与从B到A的路由不同），因此路径MTU在两个方向上不一定是一致的。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>Link Layer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解(卷一) 概述]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F23%2Ftcp-ip%2Ftcp-ip-illustrated-volume1-introduction%2F</url>
    <content type="text"><![CDATA[TCP/IP 的分层TCP/IP 通常被认为是一个四层协议系统： 链路层：也称作数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。 网络层：处理分组在网络中的活动，例如分组的选路。在 TCP/IP 协议族中，网络层协议包括 IP协议、ICMP协议以及 IGMP协议。 运输层：主要为两台主机上的应用程序提供端到端的通信。TCP协议 和 UDP协议。 应用层：负责处理特定的应用程序细节。 封装当应用程序用 TCP 传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息）。 分用当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。]]></content>
      <categories>
        <category>Study</category>
        <category>TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F23%2Fdesign-pattern%2Fcommand-pattern%2F</url>
    <content type="text"><![CDATA[命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 介绍意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。何时使用：在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。缺点：使用命令模式可能会导致某些系统有过多的具体命令类。使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。 实现我们首先创建作为命令的接口 Order，然后创建作为请求的 Stock 类。实体命令类 BuyStock 和 SellStock，实现了 Order 接口，将执行实际的命令处理。创建作为调用对象的类 Broker，它接受订单并能下订单。Broker 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。CommandPatternDemo，我们的演示类使用 Broker 类来演示命令模式。 步骤 1创建一个命令接口。Order.java123public interface Order &#123; void execute();&#125; 步骤 2创建一个请求类。Stock.java1234567891011121314public class Stock &#123; private String name = "ABC"; private int quantity = 10; public void buy()&#123; System.out.println("Stock [ Name: "+name+", Quantity: " + quantity +" ] bought"); &#125; public void sell()&#123; System.out.println("Stock [ Name: "+name+", Quantity: " + quantity +" ] sold"); &#125;&#125; 步骤 3创建实现了 Order 接口的实体类。BuyStock.java1234567891011public class BuyStock implements Order &#123; private Stock abcStock; public BuyStock(Stock abcStock)&#123; this.abcStock = abcStock; &#125; public void execute() &#123; abcStock.buy(); &#125;&#125; SellStock.java1234567891011public class SellStock implements Order &#123; private Stock abcStock; public SellStock(Stock abcStock)&#123; this.abcStock = abcStock; &#125; public void execute() &#123; abcStock.sell(); &#125;&#125; 步骤 4创建命令调用类。Broker.java1234567891011121314151617import java.util.ArrayList;import java.util.List; public class Broker &#123; private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); public void takeOrder(Order order)&#123; orderList.add(order); &#125; public void placeOrders()&#123; for (Order order : orderList) &#123; order.execute(); &#125; orderList.clear(); &#125;&#125; 步骤 5使用 Broker 类来接受并执行命令。CommandPatternDemo.java1234567891011121314public class CommandPatternDemo &#123; public static void main(String[] args) &#123; Stock abcStock = new Stock(); BuyStock buyStockOrder = new BuyStock(abcStock); SellStock sellStockOrder = new SellStock(abcStock); Broker broker = new Broker(); broker.takeOrder(buyStockOrder); broker.takeOrder(sellStockOrder); broker.placeOrders(); &#125;&#125; 步骤 6验证输出。12Stock [ Name: ABC, Quantity: 10 ] boughtStock [ Name: ABC, Quantity: 10 ] sold]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[责任链模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F21%2Fdesign-pattern%2Fchain-of-responsibility-pattern%2F</url>
    <content type="text"><![CDATA[顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 介绍意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。何时使用：在处理消息的时候以过滤很多道。如何解决：拦截的类都实现统一接口。关键代码：Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。应用实例： 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。注意事项：在 JAVA WEB 中遇到很多应用。 实现我们创建抽象类 AbstractLogger，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 AbstractLogger。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。 步骤 1创建抽象的记录器类。AbstractLogger.java1234567891011121314151617181920212223242526public abstract class AbstractLogger &#123; public static int INFO = 1; public static int DEBUG = 2; public static int ERROR = 3; protected int level; //责任链中的下一个元素 protected AbstractLogger nextLogger; public void setNextLogger(AbstractLogger nextLogger)&#123; this.nextLogger = nextLogger; &#125; public void logMessage(int level, String message)&#123; if(this.level &lt;= level)&#123; write(message); &#125; if(nextLogger !=null)&#123; nextLogger.logMessage(level, message); &#125; &#125; abstract protected void write(String message);&#125; 步骤 2创建扩展了该记录器类的实体类。ConsoleLogger.java1234567891011public class ConsoleLogger extends AbstractLogger &#123; public ConsoleLogger(int level)&#123; this.level = level; &#125; @Override protected void write(String message) &#123; System.out.println("Standard Console::Logger: " + message); &#125;&#125; ErrorLogger.java1234567891011public class ErrorLogger extends AbstractLogger &#123; public ErrorLogger(int level)&#123; this.level = level; &#125; @Override protected void write(String message) &#123; System.out.println("Error Console::Logger: " + message); &#125;&#125; FileLogger.java1234567891011public class FileLogger extends AbstractLogger &#123; public FileLogger(int level)&#123; this.level = level; &#125; @Override protected void write(String message) &#123; System.out.println("File::Logger: " + message); &#125;&#125; 步骤 3创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。ChainPatternDemo.java123456789101112131415161718192021222324252627public class ChainPatternDemo &#123; private static AbstractLogger getChainOfLoggers()&#123; AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR); AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG); AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO); errorLogger.setNextLogger(fileLogger); fileLogger.setNextLogger(consoleLogger); return errorLogger; &#125; public static void main(String[] args) &#123; AbstractLogger loggerChain = getChainOfLoggers(); loggerChain.logMessage(AbstractLogger.INFO, "This is an information."); loggerChain.logMessage(AbstractLogger.DEBUG, "This is an debug level information."); loggerChain.logMessage(AbstractLogger.ERROR, "This is an error information."); &#125;&#125; 步骤 4验证输出。123456Standard Console::Logger: This is an information.File::Logger: This is an debug level information.Standard Console::Logger: This is an debug level information.Error Console::Logger: This is an error information.File::Logger: This is an error information.Standard Console::Logger: This is an error information.]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F21%2Fdesign-pattern%2Fproxy-pattern%2F</url>
    <content type="text"><![CDATA[在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 介绍意图：为其他对象提供一种代理以控制对这个对象的访问。主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。何时使用：想在访问一个类时做一些控制。如何解决：增加中间层。关键代码：实现与被代理类组合。应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。优点： 1、职责清晰。 2、高扩展性。 3、智能化。缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。使用场景：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 实现我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。 步骤 1创建一个接口。Image.java123public interface Image &#123; void display();&#125; 步骤 2创建实现接口的实体类。RealImage.java123456789101112131415161718public class RealImage implements Image &#123; private String fileName; public RealImage(String fileName)&#123; this.fileName = fileName; loadFromDisk(fileName); &#125; @Override public void display() &#123; System.out.println("Displaying " + fileName); &#125; private void loadFromDisk(String fileName)&#123; System.out.println("Loading " + fileName); &#125;&#125; ProxyImage.java1234567891011121314151617public class ProxyImage implements Image&#123; private RealImage realImage; private String fileName; public ProxyImage(String fileName)&#123; this.fileName = fileName; &#125; @Override public void display() &#123; if(realImage == null)&#123; realImage = new RealImage(fileName); &#125; realImage.display(); &#125;&#125; 步骤 3当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。ProxyPatternDemo.java123456789101112public class ProxyPatternDemo &#123; public static void main(String[] args) &#123; Image image = new ProxyImage("test_10mb.jpg"); //图像将从磁盘加载 image.display(); System.out.println(""); //图像将无法从磁盘加载 image.display(); &#125;&#125; 步骤 4验证输出。1234Loading test_10mb.jpgDisplaying test_10mb.jpgDisplaying test_10mb.jpg]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 升级内核]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F20%2Fubuntu-upgrade-kernel%2F</url>
    <content type="text"><![CDATA[查看当前内核版本12$ uname -r4.4.0-53-generic 下载内核下载最新 Ubuntu 编译好的内核地址： http://kernel.ubuntu.com/~kernel-ppa/mainline/选取当前最新的内核 4.16.3 版本进行下载：1234$ mkdir 4.16.3 &amp;&amp; cd 4.16.3$ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.16.3/linux-headers-4.16.3-041603_4.16.3-041603.201804190730_all.deb$ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.16.3/linux-headers-4.16.3-041603-generic_4.16.3-041603.201804190730_amd64.deb$ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.16.3/linux-image-4.16.3-041603-generic_4.16.3-041603.201804190730_amd64.deb 安装内核1$ dpkg -i *.deb 卸载旧内核123456# 查看目前安装的内核$ dpkg -l | grep linuxii linux-image-4.4.0-53-generic 4.4.0-53.74 amd64 Linux kernel image for version 4.4.0 on 64 bit x86 SMPii linux-image-4.16.3-041603-generic 4.16.3-041603.201804190730 amd64 Linux kernel image for version 4.16.3 on 64 bit x86 SMP## 卸载旧内核$ apt-get purge linux-image-4.4.0-53-generic linux-headers-4.4.0-53 如果查询的结果中还有显示已卸载的内核，可以使用dpkg -P linux-image-4.4.0-53-generic命令将其删除。 更新启动引导123$ update-grub# 重启后再查看内核版本验证 uname -a$ reboot Linode在 Linode 提供的服务器上面，需要将 Boot Setting 下 Kernel 设定为 GRUB 2。]]></content>
      <categories>
        <category>Technology</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linode</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[享元模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F20%2Fdesign-pattern%2Fflyweight-pattern%2F</url>
    <content type="text"><![CDATA[享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。 介绍意图：运用共享技术有效地支持大量细粒度的对象。主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。何时使用： 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。关键代码：用 HashMap 存储这些对象。应用实例： 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。优点：大大减少对象的创建，降低系统的内存，使效率提高。缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。使用场景： 1、系统有大量相似对象。 2、需要缓冲池的场景。注意事项： 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。 实现我们将创建一个 Shape 接口和实现了 Shape 接口的实体类 Circle。下一步是定义工厂类 ShapeFactory。ShapeFactory 有一个 Circle 的 HashMap，其中键名为 Circle 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。ShapeFactory 检查它的 HashMap 中的 circle 对象，如果找到 Circle 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。FlyWeightPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（red / green / blue/ black / white），以便获取它所需对象的颜色。 步骤 1创建一个接口。Shape.java123public interface Shape &#123; void draw();&#125; 步骤 2创建实现接口的实体类。Circle.java12345678910111213141516171819202122232425262728public class Circle implements Shape &#123; private String color; private int x; private int y; private int radius; public Circle(String color)&#123; this.color = color; &#125; public void setX(int x) &#123; this.x = x; &#125; public void setY(int y) &#123; this.y = y; &#125; public void setRadius(int radius) &#123; this.radius = radius; &#125; @Override public void draw() &#123; System.out.println("Circle: Draw() [Color : " + color +", x : " + x +", y :" + y +", radius :" + radius); &#125;&#125; 步骤 3创建一个工厂，生成基于给定信息的实体类的对象。ShapeFactory.java12345678910111213141516import java.util.HashMap;public class ShapeFactory &#123; private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;(); public static Shape getCircle(String color) &#123; Circle circle = (Circle)circleMap.get(color); if(circle == null) &#123; circle = new Circle(color); circleMap.put(color, circle); System.out.println("Creating circle of color : " + color); &#125; return circle; &#125;&#125; 步骤 4使用该工厂，通过传递颜色信息来获取实体类的对象。FlyweightPatternDemo.java123456789101112131415161718192021222324public class FlyweightPatternDemo &#123; private static final String colors[] = &#123; "Red", "Green", "Blue", "White", "Black" &#125;; public static void main(String[] args) &#123; for(int i=0; i &lt; 20; ++i) &#123; Circle circle = (Circle)ShapeFactory.getCircle(getRandomColor()); circle.setX(getRandomX()); circle.setY(getRandomY()); circle.setRadius(100); circle.draw(); &#125; &#125; private static String getRandomColor() &#123; return colors[(int)(Math.random()*colors.length)]; &#125; private static int getRandomX() &#123; return (int)(Math.random()*100 ); &#125; private static int getRandomY() &#123; return (int)(Math.random()*100); &#125;&#125; 步骤 5验证输出。12345678910111213141516171819202122232425Creating circle of color : BlackCircle: Draw() [Color : Black, x : 36, y :71, radius :100Creating circle of color : GreenCircle: Draw() [Color : Green, x : 27, y :27, radius :100Creating circle of color : WhiteCircle: Draw() [Color : White, x : 64, y :10, radius :100Creating circle of color : RedCircle: Draw() [Color : Red, x : 15, y :44, radius :100Circle: Draw() [Color : Green, x : 19, y :10, radius :100Circle: Draw() [Color : Green, x : 94, y :32, radius :100Circle: Draw() [Color : White, x : 69, y :98, radius :100Creating circle of color : BlueCircle: Draw() [Color : Blue, x : 13, y :4, radius :100Circle: Draw() [Color : Green, x : 21, y :21, radius :100Circle: Draw() [Color : Blue, x : 55, y :86, radius :100Circle: Draw() [Color : White, x : 90, y :70, radius :100Circle: Draw() [Color : Green, x : 78, y :3, radius :100Circle: Draw() [Color : Green, x : 64, y :89, radius :100Circle: Draw() [Color : Blue, x : 3, y :91, radius :100Circle: Draw() [Color : Blue, x : 62, y :82, radius :100Circle: Draw() [Color : Green, x : 97, y :61, radius :100Circle: Draw() [Color : Green, x : 86, y :12, radius :100Circle: Draw() [Color : Green, x : 38, y :93, radius :100Circle: Draw() [Color : Red, x : 76, y :82, radius :100Circle: Draw() [Color : Blue, x : 95, y :82, radius :100]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[外观模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F19%2Fdesign-pattern%2Ffacade-pattern%2F</url>
    <content type="text"><![CDATA[外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 介绍意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。如何解决：客户端不与系统耦合，外观类与系统耦合。关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。应用实例： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。使用场景： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。 实现我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。下一步是定义一个外观类 ShapeMaker。ShapeMaker 类使用实体类来代表用户对这些类的调用。FacadePatternDemo，我们的演示类使用 ShapeMaker 类来显示结果。 步骤 1创建一个接口。 Shape.java123public interface Shape &#123; void draw();&#125; 步骤 2创建实现接口的实体类。 Rectangle.java1234567public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Rectangle::draw()"); &#125;&#125; Square.java1234567public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Square::draw()"); &#125;&#125; Circle.java1234567public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Circle::draw()"); &#125;&#125; 步骤 3创建一个外观类。 ShapeMaker.java123456789101112131415161718192021public class ShapeMaker &#123; private Shape circle; private Shape rectangle; private Shape square; public ShapeMaker() &#123; circle = new Circle(); rectangle = new Rectangle(); square = new Square(); &#125; public void drawCircle()&#123; circle.draw(); &#125; public void drawRectangle()&#123; rectangle.draw(); &#125; public void drawSquare()&#123; square.draw(); &#125;&#125; 步骤 4使用该外观类画出各种类型的形状。 FacadePatternDemo.java123456789public class FacadePatternDemo &#123; public static void main(String[] args) &#123; ShapeMaker shapeMaker = new ShapeMaker(); shapeMaker.drawCircle(); shapeMaker.drawRectangle(); shapeMaker.drawSquare(); &#125;&#125; 步骤 5验证输出。123Circle::draw()Rectangle::draw()Square::draw()]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F18%2Fdesign-pattern%2Fdecorator-pattern%2F</url>
    <content type="text"><![CDATA[装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。 介绍意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。何时使用：在不想增加很多子类的情况下扩展类。如何解决：将具体功能职责划分，同时继承装饰者模式。关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。应用实例： 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。缺点：多层装饰比较复杂。使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。注意事项：可代替继承。 实现我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。RedShapeDecorator 是实现了 ShapeDecorator 的实体类。DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。 步骤 1创建一个接口。Shape.java123public interface Shape &#123; void draw();&#125; 步骤 2创建实现接口的实体类。Rectangle.java1234567public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Shape: Rectangle"); &#125;&#125; Circle.java1234567public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Shape: Circle"); &#125;&#125; 步骤 3创建实现了 Shape 接口的抽象装饰类。ShapeDecorator.java1234567891011public abstract class ShapeDecorator implements Shape &#123; protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape)&#123; this.decoratedShape = decoratedShape; &#125; public void draw()&#123; decoratedShape.draw(); &#125;&#125; 步骤 4创建扩展了 ShapeDecorator 类的实体装饰类。RedShapeDecorator.java12345678910111213141516public class RedShapeDecorator extends ShapeDecorator &#123; public RedShapeDecorator(Shape decoratedShape) &#123; super(decoratedShape); &#125; @Override public void draw() &#123; decoratedShape.draw(); setRedBorder(decoratedShape); &#125; private void setRedBorder(Shape decoratedShape)&#123; System.out.println("Border Color: Red"); &#125;&#125; 步骤 5使用 RedShapeDecorator 来装饰 Shape 对象。DecoratorPatternDemo.java123456789101112131415161718public class DecoratorPatternDemo &#123; public static void main(String[] args) &#123; Shape circle = new Circle(); Shape redCircle = new RedShapeDecorator(new Circle()); Shape redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println("Circle with normal border"); circle.draw(); System.out.println("\nCircle of red border"); redCircle.draw(); System.out.println("\nRectangle of red border"); redRectangle.draw(); &#125;&#125; 步骤 6验证输出。12345678910Circle with normal borderShape: CircleCircle of red borderShape: CircleBorder Color: RedRectangle of red borderShape: RectangleBorder Color: Red]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 增加和删除 PPA 软件源]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F13%2Fubuntu-add-delete-ppa%2F</url>
    <content type="text"><![CDATA[PPA，英文全称为 Personal Package Archives，即个人软件包档案。是 Ubuntu Launchpad 网站提供的一项源服务，允许个人用户上传软件源代码，通过 Launchpad 进行编译并发布为二进制软件包，作为 apt / 新立得（Synaptic）源供其他用户下载和更新。 PPA 的一般形式是： ppa:user/ppa-name 添加 PPA 源: 添加 PPA 源的命令为： sudo add-apt-repository ppa:user/ppa-name 添加好记得要更新一下： sudo apt-get update 删除 PPA 源: 删除 PPA 源的命令格式则为：sudo add-apt-repository -r ppa:user/ppa-name 然后进入 /etc/apt/sources.list.d 目录，将相应 ppa 源的保存文件删除。 最后同样更新一下：sudo apt-get update Ubuntu 下安装 emacs25：12345$ sudo add-apt-repository ppa:kelleyk/emacs# 或者是 sudo add-apt-repository ppa:ubuntu-elisp/ppa$ sudo apt-get update$ sudo apt-get install emacs25# 或者是 sudo apt-get install emacs-snapshot]]></content>
      <categories>
        <category>Technology</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>emacs</tag>
        <tag>Ubuntu</tag>
        <tag>PPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linode 上搭建 Shadowsocks]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F13%2Fsetup-shadowsocks-on-linode%2F</url>
    <content type="text"><![CDATA[VPS 选择Linode老大哥Linode近年最大的变化是，倍感digitalocean和vultr的压力了。Linode近期最大的福利是，全面由原来的Xen架构改用最流行的KVM架构服务器，套餐内存全部翻倍！ 例如，过去每月$10只能买1G内存套餐，现在你可购买Linode 2G套餐，目前最低$5可以买1G内存套餐，这也是最低套餐配置了，绝对具有性价比。 Linode也允许用户按月付费，仍然采用信用卡付款的方式。新增了Paypal付款方式，目前处于测试阶段。需要提醒中国用户，Paypal仍然会要求你绑定一张双币信用卡（支持国内发行的visa信用卡），所以你应当尽快申请一张属于自己的信用卡。 Linode日本机房长期缺货，无法购买。美国西海岸Fremont机房位于加州，是中国大陆用户最应当购买的机房位置。 VultrVultr这两年的增长速度惊人，中国站长把原来digitalocean的服务器搬到了vultr，原因是vultr日本机房速度很快、同样的1G内存套餐，每月只要$8，具有超高性价比。 日本机房速度一直很快，没有绕行美国。今年9月初，杭州开会期间，Vultr日本机房线路突然变得非常慢，ping丢包严重，但是此事件仅持续了一周左右时间，又恢复正常，怀疑是中国电信国际出口线路调整导致的。在该期间，用户可把vps搬家到Vultr美国SFO机房，速度仍然很棒。 digitaloceandigitalocean新增SFO 2号机房，是对中国用户来说相当不错的选择。印度机房虽然距离中国近，但线路并未优化，速度不如美国西海岸机房。 价格方便，$10每月享受1G内存、2TB月流量、单核CPU、KVM架构，在当前竞争激烈的VPS市场，表现中庸。 digitalocean最大的变化是，过去三年间，中国买家疯狂涌入，导致线路表现不佳。大批用户搭建出国梯子，导致digitalocean机房很多IP被封。 不明就里的新用户兴奋地创建一个新账号，结果竟然ping不通服务器，无法连接ssh，其实是因为自动分配的IP被墙的原因。目前，digitalocean线路稳定，原因之一是竞争对手vultr把很多中国用户吸引了过去。 注册/申请服务器注册账号登陆 Linode 注册账号，需要绑定一张信用卡，注册时填写邀请码(0a89daeb73aede849b760c66127f1bb8960c73dc)可获得奖励。 申请服务器 Add a Linode 创建服务器 Select an instance type 因为这里只做流量转发，所以选最小的类型:1024 Location 服务器位置选 Fremont, CA 点击 Add This Linode 配置操作系统镜像 进入 Linodes 界面，点击 Deploy an Image。 操作系统镜像选择 Ubuntu 16.04 LTS，输入 root 用户密码，其他保持默认。 Boot 启动服务器。 更新系统123456# 更新源$ apt-get update# 更新已安装的包$ apt-get upgrade# 升级系统$ apt-get dist-upgrade 更新完成后 reboot 重新启动系统。 开启 bbrBBR是Google开源的TCP拥堵控制算法，与2016年9月开源。BBR的目的是要尽量跑满带宽, 并且尽量不要有排队的情况。linux 内核4.9版本以上已集成了bbr算法支持，使用 uname -r查看内核版本。12$ uname -r4.15.12-x86_64-linode105 执行以下命令修改系统配置并保存：12$ echo "net.ipv4.tcp_congestion_control=bbr" &gt;&gt; /etc/sysctl.conf$ sysctl -p 检查系统配置：1234$ sysctl net.ipv4.tcp_available_congestion_controlnet.ipv4.tcp_available_congestion_control = reno bbr bic cubic westwood htcp$ sysctl net.ipv4.tcp_congestion_controlnet.ipv4.tcp_congestion_control = bbr Linux 4.13内核版本及以上，不再需要配置 net.core.default_qdisc=fq。 优化Step 1修改 /etc/security/limits.conf 文件，加入以下两行：12* soft nofile 51200* hard nofile 51200 执行 ulimit -n 51200 命令。 Step 2修改 /etc/sysctl.conf 文件，增加以下配置：123456789101112131415161718192021fs.file-max = 51200net.core.rmem_max = 67108864net.core.wmem_max = 67108864net.core.netdev_max_backlog = 250000net.core.somaxconn = 4096net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 0net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 1200net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_max_syn_backlog = 8192net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_fastopen = 3net.ipv4.tcp_mem = 25600 51200 102400net.ipv4.tcp_rmem = 4096 87380 67108864net.ipv4.tcp_wmem = 4096 65536 67108864net.ipv4.tcp_mtu_probing = 1net.ipv4.tcp_congestion_control = bbr 执行 sysctl -p 生效。 搭建 Shadowsockslibsodium 安装12345678$ apt-get install build-essential$ wget -N --no-check-certificate https://github.com/jedisct1/libsodium/releases/download/1.0.16/libsodium-1.0.16.tar.gz$ tar zxvf libsodium-1.0.16.tar.gz$ pushd libsodium-1.0.16$ ./configure --prefix=/usr &amp;&amp; make$ make install$ popd$ ldconfig Shadowsocks-python安装 Shadowsocks-python123$ apt-get update$ apt-get install python-pip$ pip install shadowsocks 或者是通过源码安装最新版 Shadowsocks-python1234$ apt-get update$ apt-get install python-pip$ apt-get install git$ pip install git+https://github.com/shadowsocks/shadowsocks.git@master 配置 Shadowsocks修改 /etc/shadowsocks-python/config.json 文件，填入以下内容：12345678910&#123; &quot;server&quot;:&quot;xxx.xxx.xxx.xxx&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;xxxxxxxx&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-gcm&quot;, &quot;fast_open&quot;: false&#125; 多用户配置：1234567891011&#123; &quot;server&quot;: &quot;xxx.xxx.xxx.xxx&quot;, &quot;port_password&quot;: &#123; &quot;8381&quot;: &quot;xxxxxxxx&quot;, &quot;8382&quot;: &quot;xxxxxxxx&quot;, &quot;8383&quot;: &quot;xxxxxxxx&quot;, &quot;8384&quot;: &quot;xxxxxxxx&quot; &#125;, &quot;timeout&quot;: 300, &quot;method&quot;: &quot;aes-256-gcm&quot;&#125; 开启服务1234# 启动服务$ ssserver -c /etc/shadowsocks-python/config.json -d start# 关闭服务$ ssserver -c /etc/shadowsocks-python/config.json -d stop Shadowsocks-libev安装 mbedtls1234567$ wget https://tls.mbed.org/download/mbedtls-2.8.0-gpl.tgz$ tar xvf mbedtls-2.8.0-gpl.tgz$ pushd mbedtls-2.8.0$ make SHARED=1 CFLAGS=-fPIC$ sudo make DESTDIR=/usr install$ popd$ sudo ldconfig 安装 Shadowsocks-libevUbuntu 14.04 and 16.04:123$ sudo add-apt-repository ppa:max-c-lv/shadowsocks-libev -y$ sudo apt-get update$ sudo apt-get install shadowsocks-libev Ubuntu 16.10 or higher:12$ sudo apt-get update$ sudo apt-get install shadowsocks-libev 开启服务12345678# 启动$ /etc/init.d/shadowsocks-libev start# 停止$ /etc/init.d/shadowsocks-libev stop# 重启$ /etc/init.d/shadowsocks-libev restart# 查看状态$ /etc/init.d/shadowsocks-libev status Shadowsocks-go安装 Shadowsocks-go1$ apt-get install golang 编辑 ~/.bashrc，加入以下内容:12export GOPATH=/usr/gopathexport PATH=$PATH:$GOPATH/bin 执行 source ~/.bashrc使设置生效。然后再执行以下命令安装 Shadowsocks-go：1$ go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server 启动服务12# 后台启动$ shadowsocks-server -c /etc/shadowsocks-go/config.json &gt; /usr/gopath/log/log &amp;]]></content>
      <categories>
        <category>Technology</category>
        <category>Shadowsocks</category>
      </categories>
      <tags>
        <tag>Linode</tag>
        <tag>Shadowsocks</tag>
        <tag>bbr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F12%2Fdesign-pattern%2Fcomposite-pattern%2F</url>
    <content type="text"><![CDATA[组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。 介绍意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。优点： 1、高层模块调用简单。 2、节点自由增加。缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。注意事项：定义时为具体类。 实现我们有一个类 Employee，该类被当作组合模型类。CompositePatternDemo，我们的演示类使用 Employee 类来添加部门层次结构，并打印所有员工。 步骤 1创建 Employee 类，该类带有 Employee 对象的列表。Employee.java1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;import java.util.List;public class Employee &#123; private String name; private String dept; private int salary; private List&lt;Employee&gt; subordinates; //构造函数 public Employee(String name,String dept, int sal) &#123; this.name = name; this.dept = dept; this.salary = sal; subordinates = new ArrayList&lt;Employee&gt;(); &#125; public void add(Employee e) &#123; subordinates.add(e); &#125; public void remove(Employee e) &#123; subordinates.remove(e); &#125; public List&lt;Employee&gt; getSubordinates()&#123; return subordinates; &#125; public String toString()&#123; return ("Employee :[ Name : "+ name +", dept : "+ dept + ", salary :" + salary+" ]"); &#125;&#125; 步骤 2使用 Employee 类来创建和打印员工的层次结构。CompositePatternDemo.java123456789101112131415161718192021222324252627282930313233public class CompositePatternDemo &#123; public static void main(String[] args) &#123; Employee CEO = new Employee("John","CEO", 30000); Employee headSales = new Employee("Robert","Head Sales", 20000); Employee headMarketing = new Employee("Michel","Head Marketing", 20000); Employee clerk1 = new Employee("Laura","Marketing", 10000); Employee clerk2 = new Employee("Bob","Marketing", 10000); Employee salesExecutive1 = new Employee("Richard","Sales", 10000); Employee salesExecutive2 = new Employee("Rob","Sales", 10000); CEO.add(headSales); CEO.add(headMarketing); headSales.add(salesExecutive1); headSales.add(salesExecutive2); headMarketing.add(clerk1); headMarketing.add(clerk2); //打印该组织的所有员工 System.out.println(CEO); for (Employee headEmployee : CEO.getSubordinates()) &#123; System.out.println(headEmployee); for (Employee employee : headEmployee.getSubordinates()) &#123; System.out.println(employee); &#125; &#125; &#125;&#125; 步骤 3验证输出。1234567Employee :[ Name : John, dept : CEO, salary :30000 ]Employee :[ Name : Robert, dept : Head Sales, salary :20000 ]Employee :[ Name : Richard, dept : Sales, salary :10000 ]Employee :[ Name : Rob, dept : Sales, salary :10000 ]Employee :[ Name : Michel, dept : Head Marketing, salary :20000 ]Employee :[ Name : Laura, dept : Marketing, salary :10000 ]Employee :[ Name : Bob, dept : Marketing, salary :10000 ]]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过滤器模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F12%2Fdesign-pattern%2Ffilter-pattern%2F</url>
    <content type="text"><![CDATA[过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。 实现我们将创建一个 Person 对象、Criteria 接口和实现了该接口的实体类，来过滤 Person 对象的列表。CriteriaPatternDemo，我们的演示类使用 Criteria 对象，基于各种标准和它们的结合来过滤 Person 对象的列表。 步骤 1创建一个类，在该类上应用标准。Person.java12345678910111213141516171819202122public class Person &#123; private String name; private String gender; private String maritalStatus; public Person(String name,String gender,String maritalStatus)&#123; this.name = name; this.gender = gender; this.maritalStatus = maritalStatus; &#125; public String getName() &#123; return name; &#125; public String getGender() &#123; return gender; &#125; public String getMaritalStatus() &#123; return maritalStatus; &#125;&#125; 步骤 2为标准（Criteria）创建一个接口。Criteria.java12345import java.util.List;public interface Criteria &#123; public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons);&#125; 步骤 3创建实现了 Criteria 接口的实体类。CriteriaMale.java12345678910111213141516import java.util.ArrayList;import java.util.List;public class CriteriaMale implements Criteria &#123; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; malePersons = new ArrayList&lt;Person&gt;(); for (Person person : persons) &#123; if(person.getGender().equalsIgnoreCase("MALE"))&#123; malePersons.add(person); &#125; &#125; return malePersons; &#125;&#125; CriteriaFemale.java12345678910111213141516import java.util.ArrayList;import java.util.List;public class CriteriaFemale implements Criteria &#123; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; femalePersons = new ArrayList&lt;Person&gt;(); for (Person person : persons) &#123; if(person.getGender().equalsIgnoreCase("FEMALE"))&#123; femalePersons.add(person); &#125; &#125; return femalePersons; &#125;&#125; CriteriaSingle.java12345678910111213141516import java.util.ArrayList;import java.util.List;public class CriteriaSingle implements Criteria &#123; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; singlePersons = new ArrayList&lt;Person&gt;(); for (Person person : persons) &#123; if(person.getMaritalStatus().equalsIgnoreCase("SINGLE"))&#123; singlePersons.add(person); &#125; &#125; return singlePersons; &#125;&#125; AndCriteria.java123456789101112131415161718import java.util.List;public class AndCriteria implements Criteria &#123; private Criteria criteria; private Criteria otherCriteria; public AndCriteria(Criteria criteria, Criteria otherCriteria) &#123; this.criteria = criteria; this.otherCriteria = otherCriteria; &#125; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons); return otherCriteria.meetCriteria(firstCriteriaPersons); &#125;&#125; OrCriteria.java12345678910111213141516171819202122232425import java.util.List;public class OrCriteria implements Criteria &#123; private Criteria criteria; private Criteria otherCriteria; public OrCriteria(Criteria criteria, Criteria otherCriteria) &#123; this.criteria = criteria; this.otherCriteria = otherCriteria; &#125; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons); List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons); for (Person person : otherCriteriaItems) &#123; if(!firstCriteriaItems.contains(person))&#123; firstCriteriaItems.add(person); &#125; &#125; return firstCriteriaItems; &#125;&#125; 步骤4使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表。CriteriaPatternDemo.java123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.ArrayList;import java.util.List;public class CriteriaPatternDemo &#123; public static void main(String[] args) &#123; List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); persons.add(new Person("Robert","Male", "Single")); persons.add(new Person("John","Male", "Married")); persons.add(new Person("Laura","Female", "Married")); persons.add(new Person("Diana","Female", "Single")); persons.add(new Person("Mike","Male", "Single")); persons.add(new Person("Bobby","Male", "Single")); Criteria male = new CriteriaMale(); Criteria female = new CriteriaFemale(); Criteria single = new CriteriaSingle(); Criteria singleMale = new AndCriteria(single, male); Criteria singleOrFemale = new OrCriteria(single, female); System.out.println("Males: "); printPersons(male.meetCriteria(persons)); System.out.println("\nFemales: "); printPersons(female.meetCriteria(persons)); System.out.println("\nSingle Males: "); printPersons(singleMale.meetCriteria(persons)); System.out.println("\nSingle Or Females: "); printPersons(singleOrFemale.meetCriteria(persons)); &#125; public static void printPersons(List&lt;Person&gt; persons)&#123; for (Person person : persons) &#123; System.out.println("Person : [ Name : " + person.getName() +", Gender : " + person.getGender() +", Marital Status : " + person.getMaritalStatus() +" ]"); &#125; &#125;&#125; 步骤 5验证输出。123456789101112131415161718192021Males:Person : [ Name : Robert, Gender : Male, Marital Status : Single ]Person : [ Name : John, Gender : Male, Marital Status : Married ]Person : [ Name : Mike, Gender : Male, Marital Status : Single ]Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]Females:Person : [ Name : Laura, Gender : Female, Marital Status : Married ]Person : [ Name : Diana, Gender : Female, Marital Status : Single ]Single Males:Person : [ Name : Robert, Gender : Male, Marital Status : Single ]Person : [ Name : Mike, Gender : Male, Marital Status : Single ]Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]Single Or Females:Person : [ Name : Robert, Gender : Male, Marital Status : Single ]Person : [ Name : Diana, Gender : Female, Marital Status : Single ]Person : [ Name : Mike, Gender : Male, Marital Status : Single ]Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]Person : [ Name : Laura, Gender : Female, Marital Status : Married ]]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桥接模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F10%2Fdesign-pattern%2Fbridge-pattern%2F</url>
    <content type="text"><![CDATA[桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。 介绍意图：将抽象部分与实现部分分离，使它们都可以独立的变化。主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。关键代码：抽象类依赖实现类。应用实例： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。 实现我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。Shape 是一个抽象类，将使用 DrawAPI 的对象。BridgePatternDemo，我们的演示类使用 Shape 类来画出不同颜色的圆。 步骤 1创建桥接实现接口。DrawAPI.java123public interface DrawAPI &#123; public void drawCircle(int radius, int x, int y);&#125; 步骤 2创建实现了 DrawAPI 接口的实体桥接实现类。RedCircle.java1234567public class RedCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println("Drawing Circle[ color: red, radius: " + radius +", x: " +x+", "+ y +"]"); &#125;&#125; GreenCircle.java1234567public class GreenCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println("Drawing Circle[ color: green, radius: " + radius +", x: " +x+", "+ y +"]"); &#125;&#125; 步骤 3使用 DrawAPI 接口创建抽象类 Shape。Shape.java1234567public abstract class Shape &#123; protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI)&#123; this.drawAPI = drawAPI; &#125; public abstract void draw();&#125; 步骤 4创建实现了 Shape 接口的实体类。Circle.java1234567891011121314public class Circle extends Shape &#123; private int x, y, radius; public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123; super(drawAPI); this.x = x; this.y = y; this.radius = radius; &#125; public void draw() &#123; drawAPI.drawCircle(radius,x,y); &#125;&#125; 步骤 5使用 Shape 和 DrawAPI 类画出不同颜色的圆。BridgePatternDemo.java123456789public class BridgePatternDemo &#123; public static void main(String[] args) &#123; Shape redCircle = new Circle(100,100, 10, new RedCircle()); Shape greenCircle = new Circle(100,100, 10, new GreenCircle()); redCircle.draw(); greenCircle.draw(); &#125;&#125; 步骤 6验证输出。12Drawing Circle[ color: red, radius: 10, x: 100, 100]Drawing Circle[ color: green, radius: 10, x: 100, 100]]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F09%2Fdesign-pattern%2Fadapter-pattern%2F</url>
    <content type="text"><![CDATA[适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。 介绍意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）如何解决：继承或依赖（推荐）。关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。应用实例： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。 实现我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo，我们的演示类使用 AudioPlayer 类来播放各种格式。 步骤 1为媒体播放器和更高级的媒体播放器创建接口。MediaPlayer.java123public interface MediaPlayer &#123; public void play(String audioType, String fileName);&#125; AdvancedMediaPlayer.java1234public interface AdvancedMediaPlayer &#123; public void playVlc(String fileName); public void playMp4(String fileName);&#125; 步骤 2创建实现了 AdvancedMediaPlayer 接口的实体类。VlcPlayer.java1234567891011public class VlcPlayer implements AdvancedMediaPlayer&#123; @Override public void playVlc(String fileName) &#123; System.out.println("Playing vlc file. Name: "+ fileName); &#125; @Override public void playMp4(String fileName) &#123; //什么也不做 &#125;&#125; Mp4Player.java123456789101112public class Mp4Player implements AdvancedMediaPlayer&#123; @Override public void playVlc(String fileName) &#123; //什么也不做 &#125; @Override public void playMp4(String fileName) &#123; System.out.println("Playing mp4 file. Name: "+ fileName); &#125;&#125; 步骤 3创建实现了 MediaPlayer 接口的适配器类。MediaAdapter.java123456789101112131415161718192021public class MediaAdapter implements MediaPlayer &#123; AdvancedMediaPlayer advancedMusicPlayer; public MediaAdapter(String audioType)&#123; if(audioType.equalsIgnoreCase("vlc") )&#123; advancedMusicPlayer = new VlcPlayer(); &#125; else if (audioType.equalsIgnoreCase("mp4"))&#123; advancedMusicPlayer = new Mp4Player(); &#125; &#125; @Override public void play(String audioType, String fileName) &#123; if(audioType.equalsIgnoreCase("vlc"))&#123; advancedMusicPlayer.playVlc(fileName); &#125;else if(audioType.equalsIgnoreCase("mp4"))&#123; advancedMusicPlayer.playMp4(fileName); &#125; &#125;&#125; 步骤 4创建实现了 MediaPlayer 接口的实体类。AudioPlayer.java12345678910111213141516171819202122public class AudioPlayer implements MediaPlayer &#123; MediaAdapter mediaAdapter; @Override public void play(String audioType, String fileName) &#123; //播放 mp3 音乐文件的内置支持 if(audioType.equalsIgnoreCase("mp3"))&#123; System.out.println("Playing mp3 file. Name: "+ fileName); &#125; //mediaAdapter 提供了播放其他文件格式的支持 else if(audioType.equalsIgnoreCase("vlc") || audioType.equalsIgnoreCase("mp4"))&#123; mediaAdapter = new MediaAdapter(audioType); mediaAdapter.play(audioType, fileName); &#125; else&#123; System.out.println("Invalid media. "+ audioType + " format not supported"); &#125; &#125;&#125; 步骤 5使用 AudioPlayer 来播放不同类型的音频格式。AdapterPatternDemo.java12345678910public class AdapterPatternDemo &#123; public static void main(String[] args) &#123; AudioPlayer audioPlayer = new AudioPlayer(); audioPlayer.play("mp3", "beyond the horizon.mp3"); audioPlayer.play("mp4", "alone.mp4"); audioPlayer.play("vlc", "far far away.vlc"); audioPlayer.play("avi", "mind me.avi"); &#125;&#125; 步骤 6验证输出。1234Playing mp3 file. Name: beyond the horizon.mp3Playing mp4 file. Name: alone.mp4Playing vlc file. Name: far far away.vlcInvalid media. avi format not supported]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F08%2Fdesign-pattern%2Fprototype-pattern%2F</url>
    <content type="text"><![CDATA[原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 介绍意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。主要解决：在运行期建立和删除原型。何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。应用实例： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。优点： 1、性能提高。 2、逃避构造函数的约束。缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。 实现我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。PrototypPatternDemo，我们的演示类使用 ShapeCache 类来获取 Shape 对象。 步骤 1创建一个实现了 Clonable 接口的抽象类。Shape.java1234567891011121314151617181920212223242526272829public abstract class Shape implements Cloneable &#123; private String id; protected String type; abstract void draw(); public String getType()&#123; return type; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public Object clone() &#123; Object clone = null; try &#123; clone = super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return clone; &#125;&#125; 步骤 2创建扩展了上面抽象类的实体类。Rectangle.java1234567891011public class Rectangle extends Shape &#123; public Rectangle()&#123; type = "Rectangle"; &#125; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125; Square.java1234567891011public class Square extends Shape &#123; public Square()&#123; type = "Square"; &#125; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; Circle.java1234567891011public class Circle extends Shape &#123; public Circle()&#123; type = "Circle"; &#125; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; 步骤 3创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中。ShapeCache.java1234567891011121314151617181920212223242526272829import java.util.Hashtable;public class ShapeCache &#123; private static Hashtable&lt;String, Shape&gt; shapeMap = new Hashtable&lt;String, Shape&gt;(); public static Shape getShape(String shapeId) &#123; Shape cachedShape = shapeMap.get(shapeId); return (Shape) cachedShape.clone(); &#125; // 对每种形状都运行数据库查询，并创建该形状 // shapeMap.put(shapeKey, shape); // 例如，我们要添加三种形状 public static void loadCache() &#123; Circle circle = new Circle(); circle.setId("1"); shapeMap.put(circle.getId(),circle); Square square = new Square(); square.setId("2"); shapeMap.put(square.getId(),square); Rectangle rectangle = new Rectangle(); rectangle.setId("3"); shapeMap.put(rectangle.getId(),rectangle); &#125;&#125; 步骤 4PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。PrototypePatternDemo.java1234567891011121314public class PrototypePatternDemo &#123; public static void main(String[] args) &#123; ShapeCache.loadCache(); Shape clonedShape = (Shape) ShapeCache.getShape("1"); System.out.println("Shape : " + clonedShape.getType()); Shape clonedShape2 = (Shape) ShapeCache.getShape("2"); System.out.println("Shape : " + clonedShape2.getType()); Shape clonedShape3 = (Shape) ShapeCache.getShape("3"); System.out.println("Shape : " + clonedShape3.getType()); &#125;&#125; 步骤 5验证输出。123Shape : CircleShape : SquareShape : Rectangle]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F04%2F04%2Fdesign-pattern%2Fbuilder-pattern%2F</url>
    <content type="text"><![CDATA[建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。 介绍意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。主要解决：主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。何时使用：一些基本部件不会变，而其组合经常变化的时候。如何解决：将变与不变分离开。关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。优点： 1、建造者独立，易扩展。 2、便于控制细节风险。缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。 实现我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。 步骤 1创建一个表示食物条目和食物包装的接口。Item.java12345public interface Item &#123; public String name(); public Packing packing(); public float price();&#125; Packing.java123public interface Packing &#123; public String pack();&#125; 步骤 2创建实现 Packing 接口的实体类。Wrapper.java1234567public class Wrapper implements Packing &#123; @Override public String pack() &#123; return "Wrapper"; &#125;&#125; Bottle.java1234567public class Bottle implements Packing &#123; @Override public String pack() &#123; return "Bottle"; &#125;&#125; 步骤 3创建实现 Item 接口的抽象类，该类提供了默认的功能。Burger.java12345678910public abstract class Burger implements Item &#123; @Override public Packing packing() &#123; return new Wrapper(); &#125; @Override public abstract float price();&#125; ColdDrink.java12345678910public abstract class ColdDrink implements Item &#123; @Override public Packing packing() &#123; return new Bottle(); &#125; @Override public abstract float price();&#125; 步骤 4创建扩展了 Burger 和 ColdDrink 的实体类。VegBurger.java123456789101112public class VegBurger extends Burger &#123; @Override public float price() &#123; return 25.0f; &#125; @Override public String name() &#123; return "Veg Burger"; &#125;&#125; ChickenBurger.java123456789101112public class ChickenBurger extends Burger &#123; @Override public float price() &#123; return 50.5f; &#125; @Override public String name() &#123; return "Chicken Burger"; &#125;&#125; Coke.java123456789101112public class Coke extends ColdDrink &#123; @Override public float price() &#123; return 30.0f; &#125; @Override public String name() &#123; return "Coke"; &#125;&#125; Pepsi.java123456789101112public class Pepsi extends ColdDrink &#123; @Override public float price() &#123; return 35.0f; &#125; @Override public String name() &#123; return "Pepsi"; &#125;&#125; 步骤 5创建一个 Meal 类，带有上面定义的 Item 对象。Meal.java1234567891011121314151617181920212223242526import java.util.ArrayList;import java.util.List;public class Meal &#123; private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); public void addItem(Item item)&#123; items.add(item); &#125; public float getCost()&#123; float cost = 0.0f; for (Item item : items) &#123; cost += item.price(); &#125; return cost; &#125; public void showItems()&#123; for (Item item : items) &#123; System.out.print("Item : "+item.name()); System.out.print(", Packing : "+item.packing().pack()); System.out.println(", Price : "+item.price()); &#125; &#125;&#125; 步骤 6创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。MealBuilder.java12345678910111213141516public class MealBuilder &#123; public Meal prepareVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new VegBurger()); meal.addItem(new Coke()); return meal; &#125; public Meal prepareNonVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new ChickenBurger()); meal.addItem(new Pepsi()); return meal; &#125;&#125; 步骤 7BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。BuilderPatternDemo.java123456789101112131415public class BuilderPatternDemo &#123; public static void main(String[] args) &#123; MealBuilder mealBuilder = new MealBuilder(); Meal vegMeal = mealBuilder.prepareVegMeal(); System.out.println("Veg Meal"); vegMeal.showItems(); System.out.println("Total Cost: " +vegMeal.getCost()); Meal nonVegMeal = mealBuilder.prepareNonVegMeal(); System.out.println("\n\nNon-Veg Meal"); nonVegMeal.showItems(); System.out.println("Total Cost: " +nonVegMeal.getCost()); &#125;&#125; 步骤 8验证输出。12345678910Veg MealItem : Veg Burger, Packing : Wrapper, Price : 25.0Item : Coke, Packing : Bottle, Price : 30.0Total Cost: 55.0Non-Veg MealItem : Chicken Burger, Packing : Wrapper, Price : 50.5Item : Pepsi, Packing : Bottle, Price : 35.0Total Cost: 85.5]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emacs Native Profiler]]></title>
    <url>%2Fhexo-blog%2F2018%2F03%2F30%2Femacs-native-profiler%2F</url>
    <content type="text"><![CDATA[If your program is working correctly, but you want to make it run more quickly or efficiently, the first thing to do is profile your code so that you know how it is using resources. If you find that one particular function is responsible for a significant portion of the runtime, you can start looking for ways to optimize that piece. Emacs has built-in support for this. To begin profiling, type M-x profiler-start. You can choose to profile by processor usage, memory usage, or both. After doing some work, type M-x profiler-report to display a summary buffer for each resource that you chose to profile. The names of the report buffers include the times at which the reports were generated, so you can generate another report later on without erasing previous results. When you have finished profiling, type M-x profiler-stop (there is a small overhead associated with profiling). The profiler report buffer shows, on each line, a function that was called, followed by how much resource (processor or memory) it used in absolute and percentage times since profiling started. If a given line has a ‘+’ symbol at the left-hand side, you can expand that line by typing , in order to see the function(s) called by the higher-level function. Use a prefix argument () to see the whole call tree below a function. Pressing again will collapse back to the original state.Press j or mouse-2 to jump to the definition of a function. Press d to view a function’s documentation. You can save a profile to a file using C-x C-w. You can compare two profiles using =.The elp library offers an alternative approach. See the file elp.el for instructions. You can check the speed of individual Emacs Lisp forms using the benchmark library. See the functions benchmark-run and benchmark-run-compiled in benchmark.el.To profile Emacs at the level of its C code, you can build it using the –enable-profiling option of configure. When Emacs exits, it generates a file gmon.out that you can examine using the gprof utility. This feature is mainly useful for debugging Emacs. It actually stops the Lisp-level M-x profiler-… commands described above from working.]]></content>
      <categories>
        <category>Software</category>
        <category>emacs</category>
      </categories>
      <tags>
        <tag>emacs</tag>
        <tag>profiler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emacs: Show Line Numbers]]></title>
    <url>%2Fhexo-blog%2F2018%2F03%2F30%2Femacs-show-line-numbers%2F</url>
    <content type="text"><![CDATA[emacs has 2 line numbers mode: Alt + x linum-mode -&gt; old, hack, slow. Emacs 23. Alt + x global-display-line-numbers-mode -&gt; Emacs 26. global-display-line-numbers-modeEmacs 26 has a new line number mode. global-display-line-numbers-mode -&gt; show line numbers in all buffers. display-line-numbers-mode -&gt; show line numbers in current buffers. Put this in your emacs init file:12(when (version&lt;= &quot;26.0.50&quot; emacs-version ) (global-display-line-numbers-mode)) display-line-numbers-mode is written by Eli Zaretskii. linum-modeEmacs 23 has a line number mode. It shows line numbers in margin. linum-mode -&gt; toggle line number in current. global-linum-mode -&gt; toggle line number in all buffers. To set it permanetnly, put this in your emacs init file:1(global-linum-mode 1) nlinum (Recommended)As linum-mode is slow, you can use nlinum instead of linum-mode. 123456(if (version&lt; emacs-version &quot;26&quot;) (use-package nlinum :ensure t :config (global-nlinum-mode 1)) (global-display-line-numbers-mode))]]></content>
      <categories>
        <category>Software</category>
        <category>emacs</category>
      </categories>
      <tags>
        <tag>emacs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Speed up emacs startup time]]></title>
    <url>%2Fhexo-blog%2F2018%2F03%2F28%2Fspeed-up-emacs-startup-time%2F</url>
    <content type="text"><![CDATA[init.el1234567891011121314151617(setq package-enable-at-startup nil)(defvar file-name-handler-alist-old file-name-handler-alist)(setq file-name-handler-alist nil gc-cons-threshold 402653184 gc-cons-percentage 0.6)(add-hook &apos;after-init-hook (lambda () (setq file-name-handler-alist file-name-handler-alist-old gc-cons-threshold 16777216 gc-cons-percentage 0.1)))...your code here...(provide &apos;init) use-package 延迟加载的只言片语Emacs lisp 有一项 auto-load 的技术，类似延迟加载，合理运用延迟，让笔者的 Emacs 启动加载时间减少一半，因为笔者用 use-package 了这个插件,而 use-package 又集 成了延迟加载的功能，所以笔者就直接拿自己的代码举例了 :after12345;;; Export to twitter bootstrap(use-package ox-twbs :after org :ensure ox-twbs ) :after 关键字的作用基本跟 with-eval-after-load 的作用是相同的，所以笔者所 有类似的org-mode 插件包都会在org-mode 加载以后才会加载 :commands123(use-package avy :commands (avy-goto-char avy-goto-line) :ensure t) 这里就直接贴上 use-package文档的说明了 When you use the :commands keyword, it creates autoloads for those commands and defers loading of the module until they are used 也就是 :commands 关键字就创建了后面所接的命令的 autoloads 机制了 :bind :mode1234567891011(use-package hi-lock :bind ((&quot;M-o l&quot; . highlight-lines-matching-regexp) (&quot;M-o r&quot; . highlight-regexp) (&quot;M-o w&quot; . highlight-phrase)))(use-package vue-mode :ensure t :mode (&quot;\\.vue\\&apos;&quot; . vue-mode) :config (progn (setq mmm-submode-decoration-level 0) )) 附上文档说明 In almost all cases you don’t need to manually specify :defer t. This is implied whenever :bind or :mode or :interpreter is used 也就是说，当你使用了 :bind 或者 :mode 关键字的时候，不用明确指定 :defer 也可以实现延迟加载机制。当然你也可以，直接使用 :defer 关键字来指定延迟加载 不过前提是，你要明确它加载的时机 Typically, you only need to specify :defer if you know for a fact that some other package will do something to cause your package to load at the appropriate time, and thus you would like to defer loading even though use-package isn’t creating any autoloads for you. 贴上笔者自己的代码，可以更加清晰1234567(use-package anaconda-mode :defer t :ensure t :init(progn (add-hook &apos;python-mode-hook &apos;anaconda-mode) (add-hook &apos;python-mode-hook &apos;anaconda-eldoc-mode) ) 这样 anaconda-mode 就会在 python-mode 加载以后被加载]]></content>
      <categories>
        <category>Software</category>
        <category>emacs</category>
      </categories>
      <tags>
        <tag>emacs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F03%2F26%2Fdesign-pattern%2Fsingleton-pattern%2F</url>
    <content type="text"><![CDATA[单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意: 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 介绍意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。主要解决：一个全局使用的类频繁地创建与销毁。何时使用：当您想控制实例数目，节省系统资源的时候。如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。关键代码：构造函数是私有的。应用实例： 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 实现我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。 步骤 1创建一个 Singleton 类。SingleObject.java1234567891011121314151617public class SingleObject &#123; //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject()&#123;&#125; //获取唯一可用的对象 public static SingleObject getInstance()&#123; return instance; &#125; public void showMessage()&#123; System.out.println("Hello World!"); &#125;&#125; 步骤 2从 singleton 类获取唯一的对象。SingletonPatternDemo.java1234567891011121314public class SingletonPatternDemo &#123; public static void main(String[] args) &#123; //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); &#125;&#125; 步骤 3验证输出。1Hello World! 单例模式的几种实现方式单例模式的实现有多种方式，如下所示： 懒汉式，线程不安全是否 Lazy 初始化：是是否多线程安全：否实现难度：易描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 代码实例：1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 懒汉式，线程安全是否 Lazy 初始化：是是否多线程安全：是实现难度：易描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 代码实例：12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 饿汉式是否 Lazy 初始化：否是否多线程安全：是实现难度：易描述：这种方式比较常用，但容易产生垃圾对象。优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 代码实例：1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 双检锁/双重校验锁（DCL，即 double-checked locking）JDK 版本：JDK1.5 起是否 Lazy 初始化：是是否多线程安全：是实现难度：较复杂描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。 代码实例：1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 登记式/静态内部类是否 Lazy 初始化：是是否多线程安全：是实现难度：一般描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。 代码实例：123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 枚举JDK 版本：JDK1.5 起是否 Lazy 初始化：否是否多线程安全：是实现难度：易描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。 代码实例：12345public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125; 经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chuck's Emacs Configuration]]></title>
    <url>%2Fhexo-blog%2F2018%2F03%2F25%2Fchuck-emacs-configuration%2F</url>
    <content type="text"><![CDATA[Chuck’s Emacs Configuration with use-package Documentshttp://xuchengpeng.com/emacs.d/ Install1$ git clone https://github.com/xuchengpeng/emacs.d.git ~/.emacs.d ELPA mirror可以在 ~/.emacs.d/lisp/init-preload-private.el 文件里面定义自己使用的 ELPA 镜像。12345678(setq package-archives &apos;((&quot;melpa&quot; . &quot;E:/GitHub/elpa-mirror/melpa&quot;) (&quot;org&quot; . &quot;E:/GitHub/elpa-mirror/org&quot;) (&quot;gnu&quot; . &quot;E:/GitHub/elpa-mirror/gnu&quot;) ))(provide &apos;init-preload-private) 可以从 d12frosted/elpa-mirror 下载到本地。 或者可以使用其他的镜像： 清华ELPA镜像 Emacs China ELPA镜像 CustomizationTo add your own customization, create a file ~/.emacs.d/lisp/init-afterload-private.el which looks like this:123... your code here ...(provide &apos;init-afterload-private) If you need initialisation code which executes earlier in the startup process, you can also create an ~/.emacs.d/lisp/init-preload-private.el file which looks like this:123... your code here ...(provide &apos;init-preload-private) Install fonts(Optional)Install Source Code Pro. Supported Emacs versionsThe config should run on Emacs 25.1 or greater and is designed to degrade smoothly - see the Travis build.]]></content>
      <categories>
        <category>Software</category>
        <category>emacs</category>
      </categories>
      <tags>
        <tag>emacs</tag>
        <tag>use-package</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F03%2F25%2Fdesign-pattern%2Fabstract-factory-pattern%2F</url>
    <content type="text"><![CDATA[抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 介绍意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。主要解决：主要解决接口选择的问题。何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。如何解决：在一个产品族里面，定义多个产品。关键代码：在一个工厂里聚合多个同类产品。应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。注意事项：产品族难扩展，产品等级易扩展。 实现我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。AbstractFactoryPatternDemo，我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。 步骤 1为形状创建一个接口。Shape.java123public interface Shape &#123; void draw();&#125; 步骤 2创建实现接口的实体类。Rectangle.java1234567public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125; Square.java1234567public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; Circle.java1234567public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; 步骤 3为颜色创建一个接口。 Color.java123public interface Color &#123; void fill();&#125; 步骤4创建实现接口的实体类。Red.java1234567public class Red implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Red::fill() method."); &#125;&#125; Green.java1234567public class Green implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Green::fill() method."); &#125;&#125; Blue.java1234567public class Blue implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Blue::fill() method."); &#125;&#125; 步骤 5为 Color 和 Shape 对象创建抽象类来获取工厂。AbstractFactory.java1234public abstract class AbstractFactory &#123; abstract Color getColor(String color); abstract Shape getShape(String shape) ;&#125; 步骤 6创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。ShapeFactory.java12345678910111213141516171819202122public class ShapeFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase("CIRCLE"))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase("RECTANGLE"))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase("SQUARE"))&#123; return new Square(); &#125; return null; &#125; @Override Color getColor(String color) &#123; return null; &#125;&#125; ColorFactory.java12345678910111213141516171819202122public class ColorFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; return null; &#125; @Override Color getColor(String color) &#123; if(color == null)&#123; return null; &#125; if(color.equalsIgnoreCase("RED"))&#123; return new Red(); &#125; else if(color.equalsIgnoreCase("GREEN"))&#123; return new Green(); &#125; else if(color.equalsIgnoreCase("BLUE"))&#123; return new Blue(); &#125; return null; &#125;&#125; 步骤 7创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。FactoryProducer.java12345678910public class FactoryProducer &#123; public static AbstractFactory getFactory(String choice)&#123; if(choice.equalsIgnoreCase("SHAPE"))&#123; return new ShapeFactory(); &#125; else if(choice.equalsIgnoreCase("COLOR"))&#123; return new ColorFactory(); &#125; return null; &#125;&#125; 步骤 8使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。AbstractFactoryPatternDemo.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class AbstractFactoryPatternDemo &#123; public static void main(String[] args) &#123; //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE"); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape("CIRCLE"); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape("RECTANGLE"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape("SQUARE"); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR"); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor("RED"); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor("Green"); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor("BLUE"); //调用 Blue 的 fill 方法 color3.fill(); &#125;&#125; 步骤 9验证输出。123456Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.Inside Red::fill() method.Inside Green::fill() method.Inside Blue::fill() method.]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2Fhexo-blog%2F2018%2F03%2F22%2Fdesign-pattern%2Ffactory-pattern%2F</url>
    <content type="text"><![CDATA[工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 介绍意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。主要解决：主要解决接口选择的问题。何时使用：我们明确地计划不同条件下创建不同实例时。如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。关键代码：创建过程在其子类执行。应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 实现我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。 步骤 1创建一个接口。Shape.java123public interface Shape &#123; void draw();&#125; 步骤 2创建实现接口的实体类。Rectangle.java1234567public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125; Square.java1234567public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; Circle.java1234567public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; 步骤 3创建一个工厂，生成基于给定信息的实体类的对象。ShapeFactory.java1234567891011121314151617public class ShapeFactory &#123; //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase("CIRCLE"))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase("RECTANGLE"))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase("SQUARE"))&#123; return new Square(); &#125; return null; &#125;&#125; 步骤 4使用该工厂，通过传递类型信息来获取实体类的对象。FactoryPatternDemo.java123456789101112131415161718192021222324public class FactoryPatternDemo &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); //获取 Circle 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape("CIRCLE"); //调用 Circle 的 draw 方法 shape1.draw(); //获取 Rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape("RECTANGLE"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取 Square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape("SQUARE"); //调用 Square 的 draw 方法 shape3.draw(); &#125;&#125; 步骤 5验证输出。123Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式简介]]></title>
    <url>%2Fhexo-blog%2F2018%2F03%2F20%2Fdesign-pattern%2Fintroduction%2F</url>
    <content type="text"><![CDATA[设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 什么是 GOF（四人帮，全拼 Gang of Four）？在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 设计模式的使用设计模式在软件开发中的两个主要用途。 开发人员的共同平台设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。 最佳的实践设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式的类型根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 序号 模式 &amp; 描述 包括 1 创建型模式:这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） 2 结构型模式:这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） 3 行为型模式:这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） 4 J2EE 模式:这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern） 下面用一个图片来整体描述一下设计模式之间的关系： 设计模式的六大原则 开闭原则（Open Close Principle）开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle）里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则（Dependence Inversion Principle）这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 迪米特法则，又称最少知道原则（Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle）合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。]]></content>
      <categories>
        <category>Study</category>
        <category>Design Pattern</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Search with ripgrep]]></title>
    <url>%2Fhexo-blog%2F2018%2F03%2F17%2Fsearch-with-ripgrep%2F</url>
    <content type="text"><![CDATA[ripgrep is a line-oriented search tool that recursively searches your current directory for a regex pattern while respecting your gitignore rules. ripgrep has first class support on Windows, macOS and Linux, with binary downloads available for every release. ripgrep is similar to other popular search tools like The Silver Searcher, ack and grep. Is it really faster than everything else?Generally, yes. A large number of benchmarks with detailed analysis for each is available on my blog. Summarizing, ripgrep is fast because: It is built on top of Rust’s regex engine. Rust’s regex engine uses finite automata, SIMD and aggressive literal optimizations to make searching very fast. Rust’s regex library maintains performance with full Unicode support by building UTF-8 decoding directly into its deterministic finite automaton engine. It supports searching with either memory maps or by searching incrementally with an intermediate buffer. The former is better for single files and the latter is better for large directories. ripgrep chooses the best searching strategy for you automatically. Applies your ignore patterns in .gitignore files using a RegexSet. That means a single file path can be matched against multiple glob patterns simultaneously. It uses a lock-free parallel recursive directory iterator, courtesy of crossbeam and ignore. BenchmarkThis example searches the entire Linux kernel source tree (after running make defconfig &amp;&amp; make -j8) for [A-Z]+_SUSPEND, where all matches must be words. Timings were collected on a system with an Intel i7-6900K 3.2 GHz, and ripgrep was compiled with SIMD enabled. Tool Command Line count Time ripgrep (Unicode) rg -n -w &#39;[A-Z]+_SUSPEND&#39; 450 0.106s git grep LC_ALL=C git grep -E -n -w &#39;[A-Z]+_SUSPEND&#39; 450 0.553s The Silver Searcher ag -w &#39;[A-Z]+_SUSPEND&#39; 450 0.589s git grep (Unicode) LC_ALL=en_US.UTF-8 git grep -E -n -w &#39;[A-Z]+_SUSPEND&#39; 450 2.266s sift sift --git -n -w &#39;[A-Z]+_SUSPEND&#39; 450 3.505s ack ack -w &#39;[A-Z]+_SUSPEND&#39; 1878 6.823s The Platinum Searcher pt -w -e &#39;[A-Z]+_SUSPEND&#39; 450 14.208s Here’s another benchmark that disregards gitignore files and searches with a whitelist instead. The corpus is the same as in the previous benchmark, and the flags passed to each command ensure that they are doing equivalent work: Tool Command Line count Time ripgrep rg -L -u -tc -n -w &#39;[A-Z]+_SUSPEND&#39; 404 0.079s ucg ucg --type=cc -w &#39;[A-Z]+_SUSPEND&#39; 390 0.163s GNU grep egrep -R -n --include=&#39;*.c&#39; --include=&#39;*.h&#39; -w &#39;[A-Z]+_SUSPEND&#39; 404 0.611s And finally, a straight-up comparison between ripgrep and GNU grep on a single large file (~9.3GB, OpenSubtitles2016.raw.en.gz): Tool Command Line count Time ripgrep rg -w &#39;Sherlock [A-Z]\w+&#39; 5268 2.108s GNU grep LC_ALL=C egrep -w &#39;Sherlock [A-Z]\w+&#39; 5268 7.014s helm-ag with rg123456(use-package helm-ag :ensure t :after (helm) :config (setq helm-ag-base-command &quot;rg --color=always --smart-case --no-heading --line-number&quot;) ) helm-do-grep-ag1(setq helm-grep-ag-command &quot;rg --color=always --smart-case --no-heading --line-number %s %s %s&quot;)]]></content>
      <categories>
        <category>Software</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>emacs</tag>
        <tag>ripgrep</tag>
        <tag>helm-ag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base16 - An architecture for building themes]]></title>
    <url>%2Fhexo-blog%2F2018%2F03%2F08%2Fbase16%2F</url>
    <content type="text"><![CDATA[An architecture for building themes based on carefully chosen syntax highlighting using a base of sixteen colours. Base16 provides a set of guidelines detailing how to style syntax and how to code a builder for compiling base16 schemes and templates. Styling GuidelinesBase16 aims to group similar language constructs with a single color, e.g. float, ints and doubles would belong to the same colour group. The colors chosen for the default theme were chosen to be easily separatable but scheme designer should pick whatever colours they desire e.g. base0B (green by default) could be replaced with red. However, there are general guidelines below that stipulate what base0B should be used to highlight when designing templates for editors. Since describing syntax highlighting can be tricky, please see base16-vim and base16-textmate for reference. Though it should be noted that each editor will have some discrepancies due the fact that editors generally have different syntax highlighting engines. Colors base00 to base07 are typically variations of a shade and run from darkest to lighest. These colors are used for foreground and background, status bars, line highlighting and such. Colors base08 to base0F are typically individual colors used for types, operators, names and variables. In order to create a dark theme colors base00 to base07 should span from dark to light. For a light theme these colours should span from light to dark. base00 - Default Background base01 - Lighter Background (Used for status bars) base02 - Selection Background base03 - Comments, Invisibles, Line Highlighting base04 - Dark Foreground (Used for status bars) base05 - Default Foreground, Caret, Delimiters, Operators base06 - Light Foreground (Not often used) base07 - Light Background (Not often used) base08 - Variables, XML Tags, Markup Link Text, Markup Lists, Diff Deleted base09 - Integers, Boolean, Constants, XML Attributes, Markup Link Url base0A - Classes, Markup Bold, Search Text Background base0B - Strings, Inherited Class, Markup Code, Diff Inserted base0C - Support, Regular Expressions, Escape Characters, Markup Quotes base0D - Functions, Methods, Attribute IDs, Headings base0E - Keywords, Storage, Selector, Markup Italic, Diff Changed base0F - Deprecated, Opening/Closing Embedded Language Tags e.g. &lt;?php ?&gt; base16-emacs12345(use-package base16-theme :ensure t :config (load-theme &apos;base16-tomorrow-night t) ) Theme previews can be found here.]]></content>
      <categories>
        <category>Software</category>
        <category>Themes</category>
      </categories>
      <tags>
        <tag>emacs</tag>
        <tag>base16</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomorrow Theme Color Palettes]]></title>
    <url>%2Fhexo-blog%2F2018%2F03%2F07%2Ftomorrow-theme-color-palettes%2F</url>
    <content type="text"><![CDATA[“Tomorrow Theme” - a bright theme with pastel colours and sensible syntax highlighting. A theme should not get in your way but should aid your programming with easily identifiable colours that add meaning and enhance legibility. This was the main focus when developing Tomorrow. Check out base16 the next evolution of Tomorrow Theme! Take a look!Tomorrow theme variations in shown in TextMate with Ruby code and the font “Menlo”. Color PalettesTomorrow Night Hex RGB Color #1d1f21 rgb(29, 31, 33) Background #282a2e rgb(40, 42, 46) Current Line #373b41 rgb(55, 59, 65) Selection #c5c8c6 rgb(197, 200, 198) Foreground #969896 rgb(150, 152, 150) Comment #cc6666 rgb(204, 102, 102) Red #de935f rgb(222, 147, 95) Orange #f0c674 rgb(240, 198, 116) Yellow #b5bd68 rgb(181, 189, 104) Green #8abeb7 rgb(138, 190, 183) Aqua #81a2be rgb(129, 162, 190) Blue #b294bb rgb(178, 148, 187) Purple Tomorrow Hex RGB Color #ffffff rgb(255, 255, 255) Background #efefef rgb(239, 239, 239) Current Line #d6d6d6 rgb(214, 214, 214) Selection #4d4d4c rgb(77, 77, 76) Foreground #8e908c rgb(142, 144, 140) Comment #c82829 rgb(200, 40, 41) Red #f5871f rgb(245, 135, 31) Orange #eab700 rgb(234, 183, 0) Yellow #718c00 rgb(113, 140, 0) Green #3e999f rgb(62, 153, 159) Aqua #4271ae rgb(66, 113, 174) Blue #8959a8 rgb(137, 89, 168) Purple Tomorrow Night Eighties Hex RGB Color #2d2d2d rgb(45, 45, 45) Background #393939 rgb(57, 57, 57) Current Line #515151 rgb(81, 81, 81) Selection #cccccc rgb(204, 204, 204) Foreground #999999 rgb(153, 153, 153) Comment #f2777a rgb(242, 119, 122) Red #f99157 rgb(249, 145, 87) Orange #ffcc66 rgb(255, 204, 102) Yellow #99cc99 rgb(153, 204, 153) Green #66cccc rgb(102, 204, 204) Aqua #6699cc rgb(102, 153, 204) Blue #cc99cc rgb(204, 153, 204) Purple Tomorrow Night Blue Hex RGB Color #002451 rgb(0, 36, 81) Background #00346e rgb(0, 52, 110) Current Line #003f8e rgb(0, 63, 142) Selection #ffffff rgb(255, 255, 255) Foreground #7285b7 rgb(114, 133, 183) Comment #ff9da4 rgb(255, 157, 164) Red #ffc58f rgb(255, 197, 143) Orange #ffeead rgb(255, 238, 173) Yellow #d1f1a9 rgb(209, 241, 169) Green #99ffff rgb(153, 255, 255) Aqua #bbdaff rgb(187, 218, 255) Blue #ebbbff rgb(235, 187, 255) Purple Tomorrow Night Bright Hex RGB Color #000000 rgb(0, 0, 0) Background #2a2a2a rgb(42, 42, 42) Current Line #424242 rgb(66, 66, 66) Selection #eaeaea rgb(234, 234, 234) Foreground #969896 rgb(150, 152, 150) Comment #d54e53 rgb(213, 78, 83) Red #e78c45 rgb(231, 140, 69) Orange #e7c547 rgb(231, 197, 71) Yellow #b9ca4a rgb(185, 202, 74) Green #70c0b1 rgb(112, 192, 177) Aqua #7aa6da rgb(122, 166, 218) Blue #c397d8 rgb(195, 151, 216) Purple]]></content>
      <categories>
        <category>Software</category>
        <category>Themes</category>
      </categories>
      <tags>
        <tag>base16</tag>
        <tag>Tomorrow Theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Add Emacs elpa configuration]]></title>
    <url>%2Fhexo-blog%2F2018%2F03%2F06%2Fadd-emacs-elpa-configuration%2F</url>
    <content type="text"><![CDATA[ELPA mirrorEmacs China镜像 ELPA 镜像地址 GNU ELPA http://elpa.emacs-china.org/gnu/ MELPA http://elpa.emacs-china.org/melpa/ MELPA Stable http://elpa.emacs-china.org/melpa-stable/ Marmalade http://elpa.emacs-china.org/marmalade/ Org http://elpa.emacs-china.org/org/ Sunrise Commander ELPA http://elpa.emacs-china.org/sunrise-commander/ user42 ELPA http://elpa.emacs-china.org/user42/ 如果需要 HTTPS，请将镜像地址中的 http 改成 https 。 清华镜像 ELPA 镜像地址 GNU ELPA http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/ MELPA http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/ MELPA Stable http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa-stable/ Marmalade http://mirrors.tuna.tsinghua.edu.cn/elpa/marmalade/ Org http://mirrors.tuna.tsinghua.edu.cn/elpa/org/ 可以从 d12frosted/elpa-mirror 下载包镜像到本地使用。 包管理定义如下代码，即可使用 use-package 或 require-package 来安装和管理包：123456789101112131415161718192021222324252627282930313233343536373839404142434445(defun require-package (package &amp;optional min-version no-refresh) &quot;Install given PACKAGE, optionally requiring MIN-VERSION.If NO-REFRESH is non-nil, the available package lists will not bere-downloaded in order to locate PACKAGE.&quot; (if (package-installed-p package min-version) t (if (or (assoc package package-archive-contents) no-refresh) (if (boundp &apos;package-selected-packages) ;; Record this as a package the user installed explicitly (package-install package nil) (package-install package)) (progn (package-refresh-contents) (require-package package min-version t)))))(defun maybe-require-package (package &amp;optional min-version no-refresh) &quot;Try to install PACKAGE, and return non-nil if successful.In the event of failure, return nil and print a warning message.Optionally require MIN-VERSION. If NO-REFRESH is non-nil, theavailable package lists will not be re-downloaded in order tolocate PACKAGE.&quot; (condition-case err (require-package package min-version no-refresh) (error (message &quot;Couldn&apos;t install optional package `%s&apos;: %S&quot; package err) nil)))(setq package-archives &apos;((&quot;melpa&quot; . &quot;E:/GitHub/elpa-mirror/melpa&quot;) (&quot;org&quot; . &quot;E:/GitHub/elpa-mirror/org&quot;) (&quot;gnu&quot; . &quot;E:/GitHub/elpa-mirror/gnu&quot;) ));; update the package metadata is the local cache is missing(unless package-archive-contents (package-refresh-contents))(unless (package-installed-p &apos;use-package) (package-refresh-contents) (package-install &apos;use-package))(eval-when-compile (require &apos;use-package)) 请注意修改 package-archives 中的 ELPA 源。 使用示例use-package123(use-package helm :ensure t ) require-package1(require-package &apos;helm)]]></content>
      <categories>
        <category>Software</category>
        <category>emacs</category>
      </categories>
      <tags>
        <tag>emacs</tag>
        <tag>elpa</tag>
        <tag>use-package</tag>
        <tag>require-package</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Travis CI 构建时自动更新 NexT 主题源码]]></title>
    <url>%2Fhexo-blog%2F2018%2F02%2F02%2Ftravisci-update-theme-next%2F</url>
    <content type="text"><![CDATA[在 使用 Travis CI 自动部署 Hexo 博客 后，每次新增文章或者修改文章就会触发自动构建。 加入使用的主题代码更新，还需要手动合并后提交，如我的博客使用的是 NexT 主题，每天都有代码更新，所以还是想办法在构建的时候自动更新主题代码。 初步想法是在下载的博客代码后，生成博客之前，再下载一次博客的最新代码即可，Travis CI 构建过程有很多阶段，选择其中一个阶段即可。 OPTIONAL Install apt addons OPTIONAL Install cache components before_install install before_script script OPTIONAL before_cache (for cleaning up cache) after_success or after_failure OPTIONAL before_deploy OPTIONAL deploy OPTIONAL after_deploy after_script 在 before_install 阶段更新 NexT 主题源码在 before_install 阶段执行脚本 update-theme-next.sh，来完成主题源码更新：1234before_install: - export TZ='Asia/Shanghai' - chmod +x ./update-theme-next.sh # 必须先给权限 - ./update-theme-next.sh # 更新NexT主题 脚本更新 NexT 主题源码123456789101112#!/bin/bashset -evrm -rf ./themes# clone theme NexTgit clone https://github.com/theme-next/hexo-theme-next ./themes/next# clone pluginsgit clone https://github.com/theme-next/theme-next-needmoreshare2 ./themes/next/source/lib/needsharebuttongit clone https://github.com/theme-next/theme-next-fancybox3 ./themes/next/source/lib/fancyboxgit clone https://github.com/theme-next/theme-next-pace ./themes/next/source/lib/pace 提交代码后可以看到 Travis CI 在构建时操作，log 如下：1234567891011121314$ export TZ='Asia/Shanghai'$ chmod +x ./update-theme-next.sh$ ./update-theme-next.shrm -rf ./themes# clone theme NexTgit clone https://github.com/theme-next/hexo-theme-next ./themes/nextCloning into './themes/next'...# clone pluginsgit clone https://github.com/theme-next/theme-next-needmoreshare2 ./themes/next/source/lib/needsharebuttonCloning into './themes/next/source/lib/needsharebutton'...git clone https://github.com/theme-next/theme-next-fancybox3 ./themes/next/source/lib/fancyboxCloning into './themes/next/source/lib/fancybox'...git clone https://github.com/theme-next/theme-next-pace ./themes/next/source/lib/paceCloning into './themes/next/source/lib/pace'...]]></content>
      <categories>
        <category>Technology</category>
        <category>Automation</category>
      </categories>
      <tags>
        <tag>Travis CI</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 gulp 压缩 hexo 博客资源]]></title>
    <url>%2Fhexo-blog%2F2018%2F02%2F01%2Fcompress-hexo-with-gulp%2F</url>
    <content type="text"><![CDATA[使用 hexo generate 命令后在 public 文件夹下面生成 html、css、js 等源文件，里面含有大量的空白，而且博客中还有大量的图片占据了很大的空间。 Automate and enhance your workflow.gulp is a toolkit for automating painful or time-consuming tasks in your development workflow, so you can stop messing around and build something. gulp 用自动化构建工具增强你的工作流程！ 我们可以通过一些 gulp 插件实现对html、css、js、image等静态资源的高效压缩，通过压缩这些静态资源，可以减少请求的数据量从而达到优化博客访问速度的目的。 安装 gulp 及插件 基本：gulp CSS 压缩：gulp-clean-css JS 压缩：gulp-uglify HTML 压缩：gulp-htmlmin，gulp-htmlclean 图片压缩：gulp-imagemin 1$ npm install gulp-clean-css gulp-uglify gulp-htmlmin gulp-imagemin gulp-htmlclean gulp --save-dev 如果使用 Travis CI 自动部署 hexo 博客，package.json文件可如下定义：12345678910111213141516171819202122232425262728293031&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "3.5.0" &#125;, "dependencies": &#123; "hexo": "^3.5.0", "hexo-deployer-git": "^0.3.1", "hexo-generator-archive": "^0.1.5", "hexo-generator-category": "^0.1.3", "hexo-generator-feed": "^1.2.2", "hexo-generator-index": "^0.2.1", "hexo-generator-searchdb": "^1.0.8", "hexo-generator-tag": "^0.2.0", "hexo-renderer-ejs": "^0.3.1", "hexo-renderer-marked": "^0.3.2", "hexo-renderer-stylus": "^0.3.3", "hexo-server": "^0.3.1", "hexo-symbols-count-time": "^0.3.2" &#125;, "devDependencies": &#123; "gulp": "^3.9.1", "gulp-clean-css": "^3.9.2", "gulp-htmlclean": "^2.7.16", "gulp-htmlmin": "^4.0.0", "gulp-imagemin": "^4.1.0", "gulp-uglify": "^3.0.0" &#125;&#125; 编写 gulpfile.js在 hexo 博客根目录创建 gulpfile.js 文件，可根据自身需求修改相关参数，内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var gulp = require('gulp');var minifycss = require('gulp-clean-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');// 压缩htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss(&#123; compatibility: 'ie8', rebase: false, &#125;)) .pipe(gulp.dest('./public'));&#125;);// 压缩jsgulp.task('minify-js', function() &#123; return gulp.src('./public/js/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩图片gulp.task('minify-images', function() &#123; return gulp.src('./public/images/**/*.*') .pipe(imagemin( [imagemin.gifsicle(&#123;'optimizationLevel': 3&#125;), imagemin.jpegtran(&#123;'progressive': true&#125;), imagemin.optipng(&#123;'optimizationLevel': 7&#125;), imagemin.svgo()], &#123;'verbose': true&#125;)) .pipe(gulp.dest('./public/images'))&#125;);// 默认任务gulp.task('default', [ 'minify-html','minify-css','minify-js','minify-images']); 压缩生成的博客文件123$ hexo clean$ hexo generate$ gulp 压缩完成后，执行 hexo deploy 部署即可。 如果使用 Travis CI 自动部署 hexo 博客，.travis.yml文件可如下定义：123456789101112131415161718192021222324252627282930313233343536language: node_js #设置语言node_js: stable #设置相应的版本notifications: email: # 构建完成后邮件通知 recipients: - 330476629@qq.com - xucp@outlook.com on_success: always # default: change on_failure: always # default: alwaysinstall: - npm install #安装hexo及插件script: - hexo clean #清除 - hexo generate #生成 - gulp #压缩after_script: - cd ./public - git init - git config user.name "xuchengpeng" #修改name - git config user.email "330476629@qq.com" #修改email - git add . - git commit -m "Site updated" - git push --force --quiet "https://$&#123;TRAVIS_TOKEN&#125;@$&#123;GH_REF&#125;" master:master #TRAVIS_TOKEN是在Travis中配置token的名称branches: only: - hexo #只监测hexo分支，hexo是我的分支的名称，可根据自己情况设置env: global: - GH_REF: github.com/xuchengpeng/xuchengpeng.github.io.git # GitHub博客仓库的地址]]></content>
      <categories>
        <category>Technology</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[呼兰河传 - 萧红]]></title>
    <url>%2Fhexo-blog%2F2018%2F01%2F31%2Fxiaohong-hulanhezhuan%2F</url>
    <content type="text"><![CDATA[在一九四零年十二月──那正是萧红逝世的前年，那是她的健康还不怎样成问题的时候，她写成了她的最后著作──小说《呼兰河传》。 然而即使在那时，萧红的心境已经是寂寞的了。而且从《呼兰河传》，我们又看到了萧红的幼年也是何等的寂寞！读一下这部书的寥寥数语的“尾声”，就想得见萧红在回忆她那寂寞的幼年时，她的心境是怎样寂寞的： 呼兰河这小城里边，以前住着我的祖父，现在埋着我的祖父。我生的时候，祖父已经六十多岁了，我长到四五岁，祖父就快七十了，我还没有长到二十岁，祖父就七八十岁了。祖父一过了八十，祖父就死了。从前那后花园的主人，而今不见了。老主人死了，小主人逃荒去了。那园里的蝴蝶，蚂蚱，蜻蜓，也许还是年年仍旧，也许现在完全荒凉了。小黄瓜，大矮瓜，也许还是年年的种着，也许现在根本没有了。那早晨的露珠是不是还落在花盆架上。那午间的太阳是不是还照着那大向日葵，那黄昏时候的红霞是不是还会一会工夫会变出来一匹马来，一会工夫变出来一匹狗来，那么变着。这一些不能想象了。听说有二伯死了。老厨子就是活着年纪也不小了。东邻西舍也都不知怎样了。至于那磨坊里的磨官，至今究竟如何，则完全不晓得了。以上我所写的并没有什么幽美的故事，只因他们充满我幼年的记忆，忘却不了，难以忘却，就记在这里了。 《呼兰河传》给我们看萧红的童年是寂寞的。 一位解事颇早的小女孩子每天的生活多么单调呵！年年种着小黄瓜，大矮瓜，年年春秋佳日有些蝴蝶，蚂蚱，蜻蜒的后花园，堆满了破旧东西，黑暗而尘封的后房，是她消遣的地方；慈祥而犹有童心的老祖父是她唯一的伴侣；清早在床上学舌似的念老祖父口授的唐诗，白天嬲着老祖父讲那些实在已经听厌了的故事，或者看看那左邻右舍的千年如一日的刻板生活，──如果这样死水似的生活中有什么突然冒起来的浪花，那也无非是老胡家的小团圆媳妇病了，老胡家又在跳神了，小团圆媳妇终于死了；那也无非是磨官冯歪嘴忽然有了老婆，有了孩子，而后来，老婆又忽然死了，剩下刚出世的第二个孩子。 呼兰河这小城的生活也是刻板单调的。 一年之中，他们很有规律地过活着；一年之中，必定有跳大神，唱秧歌，放河灯，野台子戏，四月十八日娘娘庙大会……这些热闹隆重的节日，而这些节日也和他们的日常生活一样多么单调而呆板。 呼兰河这小城的生活可又不是没有音响和色彩的。 大街小巷，每一茅舍内，每一篱笆后边，充满了唠叨，争吵，哭笑，乃至梦呓。一年四季，依着那些走马灯似的挨次到来的隆重热闹的节日，在灰黯的日常生活的背景前，呈显了粗线条的大红大绿的带有原始性的色彩。 也许有人会觉得《呼兰河传》不是一部小说。他们也许会这样说：没有贯串全书的线索，故事和人物都是零零碎碎，都是片段的，不是整个的有机体。也许又有人觉得《呼兰河传》好像是自传，却又不完全像自传。 但是我却觉得正因其不完全像自传，所以更好，更有意义。而且我们不也可以说：要点不在《呼兰河传》不像是一部严格意义的小说，而在它于这“不像”之外，还有些别的东西──一些比“像”一部小说更为“诱人”些的东西：它是一篇叙事诗，一幅多彩的风土画，一串凄婉的歌谣。 注：上文摘自本书序。]]></content>
      <categories>
        <category>Books</category>
        <category>Novel</category>
      </categories>
      <tags>
        <tag>萧红</tag>
        <tag>待读的书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好了歌 - 曹雪芹]]></title>
    <url>%2Fhexo-blog%2F2018%2F01%2F31%2Fcaoxueqin-haoliaoge%2F</url>
    <content type="text"><![CDATA[世人都晓神仙好，惟有功名忘不了！古今将相在何方？荒冢一堆草没了。世人都晓神仙好，只有金银忘不了！终朝只恨聚无多，及到多时眼闭了。世人都晓神仙好，只有娇妻忘不了！君生日日说恩情，君死又随人去了。世人都晓神仙好，只有儿孙忘不了！痴心父母古来多，孝顺儿孙谁见了？]]></content>
      <categories>
        <category>Books</category>
        <category>Poetry</category>
      </categories>
      <tags>
        <tag>曹雪芹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Travis CI 自动部署 Hexo 博客]]></title>
    <url>%2Fhexo-blog%2F2018%2F01%2F30%2Fautodeploy-hexo-blog-with-travisci%2F</url>
    <content type="text"><![CDATA[CI 是 Continuous Integration 的缩写，持续集成之意。 持续集成是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。 Travis CI 是目前新兴的开源持续集成构建项目，用来构建托管在GitHub上的代码。它提供了多种编程语言的支持，包括Ruby，JavaScript，Java，Scala，PHP，Haskell和Erlang在内的多种语言。许多知名的开源项目使用它来在每次提交的时候进行构建测试，比如Ruby on Rails，Ruby和Node.js。 Travis CI是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码。这个软件的代码同时也是开源的，可以在GitHub上下载到，尽管开发者当前并不推荐在闭源项目中单独使用它。 工作原理当我们每次进行push等动作时，Travis CI 会自动检测我们的提交，然后根据配置文件，搭建虚拟主机来运行测试，构建等指令。在这里，就是运行 hexo deploy --generate 等命令来自动生成、部署静态网页。 Hexo 搭建在 GitHub 上新建 xuchengpeng.github.io 工程，其中 master 分支用来部署博客静态文件，hexo 分支用来存储源码。 hexo 分支只需要提交以下文件即可：12345678.├── scaffolds├── source├── themes├── .gitignore├── .travis.yml├── _config.yml└── package.json 配置 Travis CI使用 GitHub 帐号登陆 Travis CI，会自动关联 GitHub 上面的仓库，开启 xuchengpeng/xuchengpeng.github.io 仓库。 进入设置选项，勾选 Build only if .travis.yml is preset，Build pushed branches 和 Build pushed pull requests。 配置 Access Tokens登陆 GitHub，在 Settings / Developer settings / Person access tokens 下，点击 Generate new token 新建一个 TRAVIS_TOKEN 并且复制生成的值字符串，后面需要使用，权限只需要勾选 repo 即可。 在 Travis CI 博客项目设置下配置 Environment Variables，Name 填写 TRAVIS_TOKEN，Value 填写刚才保存的 GitHub 生成的值字符串，不要勾选 Display value in build log 选项，点击 Add 按钮增加配置。 此时，Travis CI 就已经获取了 GitHub 仓库的操作权限。 配置 .travis.yml1234567891011121314151617181920212223242526272829303132333435language: node_js #设置语言node_js: stable #设置相应的版本notifications: email: # 构建完成后邮件通知 recipients: - 330476629@qq.com - xucp@outlook.com on_success: always # default: change on_failure: always # default: alwaysinstall: - npm install #安装hexo及插件script: - hexo clean #清除 - hexo generate #生成after_script: - cd ./public - git init - git config user.name "xuchengpeng" #修改name - git config user.email "330476629@qq.com" #修改email - git add . - git commit -m "Site updated" - git push --force --quiet "https://$&#123;TRAVIS_TOKEN&#125;@$&#123;GH_REF&#125;" master:master #TRAVIS_TOKEN是在Travis中配置token的名称branches: only: - hexo #只监测hexo分支，hexo是我的分支的名称，可根据自己情况设置env: global: - GH_REF: github.com/xuchengpeng/xuchengpeng.github.io.git # GitHub博客仓库的地址 自动部署当 .travis.yml 配置文件修改完成后，将其提交到 GitHub 仓库的 hexo 分支下，在 Travis CI 博客项目下就可以看到自动构建开始执行，在 Job log 可以看到构建和部署的整个过程。 以后只要有新的修改提交到 hexo 分支，Travis CI 都会按照上述过程自动构建和部署，打开博客主页即可看到部署的效果。 Travis CI 构建状态在 GitHub 博客仓库 README.md 文件下增加以下代码，即可看到 Travis CI 构建状态。1[![Build Status](https://travis-ci.org/xuchengpeng/xuchengpeng.github.io.svg?branch=hexo)](https://travis-ci.org/xuchengpeng/xuchengpeng.github.io)]]></content>
      <categories>
        <category>Technology</category>
        <category>Automation</category>
      </categories>
      <tags>
        <tag>Travis CI</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过 Cloudflare 给绑定个人域名的GitHub Pages博客加持https]]></title>
    <url>%2Fhexo-blog%2F2018%2F01%2F28%2Fgithub-pages-with-cloudflare-https%2F</url>
    <content type="text"><![CDATA[Google宣布了，从2017年1月份正式发布的Chrome 56开始，Google将把某些包含敏感内容的https页面标记为“不安全”。 GitHub Pages 本身是 https 的站点，但是 绑定个人域名 了以后，站点便是 http 的。 https 和 http 的区别 https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 https 的优点尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处： 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 https 的缺点虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的： HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电； HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响； SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。 HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 为什么使用 Cloudflare 提供的免费SSL收费的SSL服务总是比免费的更加周到，一般收费的SSL都会提供端到端的加密。但是价格不菲，对于个人博客来说，使用免费的就可以了。Cloudflare还提供免费的CDN和缓存技术，让浏览者有更好的体验。 使用 Cloudflare 管理站点1、注册 Cloudflare 账号并登陆。2、添加你的站点，填入域名，比如我的是 xuchengpeng.com，点击 Begin Scan。3、Cloudflare 会花大约60秒的时间扫描 DNS 记录，确保有以下几条： 记录类型 主机记录 解析线路 记录值 TTL值 CNAME www 默认 xuchengpeng.github.io 600 A @ 默认 192.30.252.153 600 A @ 默认 192.30.252.154 600 4、继续点击 Continue，到域名注册商网站把 DNS 修改为 Cloudflare 提供的 DNS 服务器地址。 如我的是：aiden.ns.cloudflare.com 和 kate.ns.cloudflare.com。5、选择 Free Website，直至建站完成。6、点击 Crypto 菜单，设置为 Flexible。打开 Always use HTTPS 和 Automatic HTTPS Rewrites 选项。7、点击 Page Rules 菜单，增加两条规则： 地址 规则 http://xuchengpeng.com/* Always Use HTTPS http://xuchengpeng.com/ Forwarding URL:(Status Code: 301 - Permanent Redirect, Url: https://xuchengpeng.com/) 8、等待一段时间，设置生效，访问你的网站即可看到效果。]]></content>
      <categories>
        <category>Technology</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>Cloudflare</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致橡树 - 舒婷]]></title>
    <url>%2Fhexo-blog%2F2018%2F01%2F26%2Fshuting-to-the-oak-tree%2F</url>
    <content type="text"><![CDATA[我如果爱你——绝不像攀援的凌霄花，借你的高枝炫耀自己；我如果爱你——绝不学痴情的鸟儿，为绿荫重复单调的歌曲；也不止像泉源，常年送来清凉的慰藉；也不止像险峰，增加你的高度，衬托你的威仪。甚至日光，甚至春雨。不，这些都还不够！我必须是你近旁的一株木棉，作为树的形象和你站在一起。根，紧握在地下；叶，相触在云里。每一阵风过，我们都互相致意，但没有人，听懂我们的言语。你有你的铜枝铁干，像刀，像剑，也像戟；我有我红硕的花朵，像沉重的叹息，又像英勇的火炬。我们分担寒潮、风雷、霹雳；我们共享雾霭、流岚、虹霓。仿佛永远分离，却又终身相依。这才是伟大的爱情，坚贞就在这里：爱——不仅爱你伟岸的身躯，也爱你坚持的位置，足下的土地。]]></content>
      <categories>
        <category>Books</category>
        <category>Poetry</category>
      </categories>
      <tags>
        <tag>舒婷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo 数据文件进行主题配置]]></title>
    <url>%2Fhexo-blog%2F2018%2F01%2F18%2Ftheme-configuration-with-hexo-data-files%2F</url>
    <content type="text"><![CDATA[目前，通过 pull 或下载新的 release 版本来更新 NexT 主题的体验并不平滑。当用户使用 git pull 更新 NexT 主题时经常需要解决冲突问题，而在手动下载 release 版本时也经常需要手动合并配置。 现在来说，NexT 推荐用户存储部分配置在站点的 _config.yml 中，而另一部分在主题的 _config.yml 中。这一方式固然可用，但也有一些缺点： 配置项被分裂为两部分； 用户难以弄清何处存放配置选项。 为了解决这一问题，NexT 将利用 Hexo 的数据文件特性。因为数据文件是在 Hexo 3 中被引入，所以你需要更新至 Hexo 3.0 以后的版本来使用这一特性。 如果你仍然希望使用 Hexo 2.x，你依旧可以按老的方式进行配置。NexT 仍然兼容 Hexo 2.x（但可能会出现错误）。 Hexo 的方式使用这种方法，所有的配置保存在 hexo 配置文件中（hexo/_config.yml），并且不需要修改 next/_config.yml 配置文件或者创建其他任何文件。但是你必须在 theme_config 选项中保留双重空格缩进。 如果在新版本中有任何新的配置项，你只需要从 next/_config.yml 拷贝这些配置项，粘贴到 hexo/_config.yml 并且设定他们为你想要的值。 使用方法 检查不存在 hexo/source/_data/next.yml 文件（如果存在就删除）。 从 next/_config.yml 拷贝需要的 NexT 主题配置项到 hexo/_config.yml 中，然后：2.1. 把这些选项向右移动两个空格。2.2. 在这些选项的上方加上 theme_config 参数。 相关链接 Hexo Configuration Hexo Pull #757 NexT 的方式使用这种方法，你可以将所有的配置置于同一位置（source/_data/next.yml），并且不需要修改 next/_config.yml。但是这种选项可能无法准确的处理所有的 hexo 外部库及其附加选项（举个例子，hexo-server 模块选项可能只从默认的 hexo 配置中读取）。 如果在新版本中有任何新的配置项，你只需要从 next/_config.yml 拷贝这些配置项，粘贴到 data/next.yml 并且设定他们为你想要的值。 使用方法 请确认你的 Hexo 版本为 3.0 或更高。 在你站点的 hexo/source/_data 目录创建一个 next.yml 文件（如果 _data 目录不存在，请创建之）。在这些步骤之后有两个选择，只需要选择其中一个，然后继续下一步。 选择1：override: false (default)：i. 检查 NexT 默认配置中的 override 选项，必须设定为 false。在 next.yml 中，无需定义它，或者也必须设定为 false。ii. 复制你站点的 _config.yml 和主题的 _config.yml 中的 NexT 配置项 到 hexo/source/_data/next.yml 中。 选择2：override: true：i. 在 next.yml 中，override 选项必须设定为 true。ii. 复制你主题 _config.yml 中的 所有配置项 到 hexo/source/_data/next.yml 中。 站点配置文件 _config.yml 中需要定义 theme: next 选项。 使用标准参数来启动服务器，生成或部署（hexo clean &amp;&amp; hexo g -d &amp;&amp; hexo s）。 相关链接 NexT Issue #328]]></content>
      <categories>
        <category>Technology</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云域名赠送企业邮箱]]></title>
    <url>%2Fhexo-blog%2F2018%2F01%2F17%2Falimail-with-aliyun-domain%2F</url>
    <content type="text"><![CDATA[申请 阿里云域名 后，会赠送阿里云企业邮箱免费版。 50个帐号，5G/帐号； 域名注册成功后，自动开通企业邮箱并添加邮箱解析； 每位会员只能开通一个企业邮箱免费版; 仅 .top 域名注册送免费企业邮箱。 开通企业邮箱免费版后一定要尽快使其生效，否则七天内会被收回。 域名绑定进入 阿里云邮箱控制台 即可看到拥有的企业邮箱免费版。在更换域名选项卡中，选择你申请的域名并提交。 设置解析一般情况下，域名注册后会自动添加邮箱解析，解析状态会显示 解析已生效；如果邮箱解析失败，可以尝试一键添加解析，也可以手动添加如下配置： 记录类型 主机记录 解析线路 记录值 MX优先级 TTL值 TXT @ 默认 v=spf1 include:spf.mxhichina.com -all 600 CNAME mail 默认 mail.mxhichina.com 600 CNAME imap 默认 imap.mxhichina.com 600 CNAME smtp 默认 smtp.mxhichina.com 600 CNAME pop3 默认 pop3.mxhichina.com 600 MX @ 默认 mxw.mxhichina.com 10 600 MX @ 默认 mxn.mxhichina.com 5 600 添加完成后刷新域名解析即可看到解析状态中显示 解析已生效。 设置密码和安全问题在 重置密码 和 重置安全问题 选项卡中设置管理员帐号的密码和安全问题。 分配帐号使用管理员帐号登陆 邮箱访问地址 为用户分配帐号。]]></content>
      <categories>
        <category>Technology</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>E-mail</tag>
        <tag>Aliyun</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重庆旅行]]></title>
    <url>%2Fhexo-blog%2F2018%2F01%2F16%2Ftravel-chongqing%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Travel</category>
      </categories>
      <tags>
        <tag>Chongqing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages 绑定阿里云域名]]></title>
    <url>%2Fhexo-blog%2F2018%2F01%2F16%2Fset-up-aliyun-domain-with-github-pages%2F</url>
    <content type="text"><![CDATA[首先在 阿里云 上注册一个域名，阿里云域名更有 域名一元购专题，价格十分便宜。 设置Custom domain在 GitHub 博客工程中进行设置，Settings - Options 中找到 Custom domain 设定申请的域名，例如我申请的是 xuchengpeng.com。设置 Custom Domain 会自动在根目录创建 CNAME 文件。 创建CNAME文件在 GitHub 博客工程根目录创建 CNAME 文件，内容填上申请的域名 xuchengpeng.com。如果是 Hexo 博客，则在 source 目录下创建 CNAME 文件，填好内容后发布即可。 绑定域名在阿里云域名解析设置中增加如下配置： 记录类型 主机记录 解析线路 记录值 TTL值 CNAME www 默认 xuchengpeng.github.io 600 A @ 默认 192.30.252.153 600 A @ 默认 192.30.252.154 600 xuchengpeng.github.io 是 GitHub Pages 博客的地址； 192.30.252.153 和 192.30.252.154 是 GitHub Pages 服务器指定的IP地址，在 这里 可以找到。 设置完成之后，等待一会儿域名就生效了，可以通过 http://xuchengpeng.com/ 访问博客。]]></content>
      <categories>
        <category>Technology</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Aliyun</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Hexo NexT主题博客]]></title>
    <url>%2Fhexo-blog%2F2018%2F01%2F09%2Fsetup-hexo-next-blog%2F</url>
    <content type="text"><![CDATA[什么是Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 NexT 是一款简洁优雅且易于使用的主题。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 安装安装前提安装 Node.js 和 Git。 安装 Hexo1npm install -g hexo-cli 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 新建完成后，指定文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 配置修改 站点配置文件。 网站 参数 描述 title xuchengpeng subtitle Valar Morghulis. Valar Dohaeris. description Valar Morghulis. Valar Dohaeris. author xuchengpeng language zh-CN timezone Asia/Shanghai 网址 参数 描述 url http://xuchengpeng.com/ permalink :year/:month/:day/:title/ 安装 NexT 主题下载主题1git clone https://github.com/theme-next/hexo-theme-next themes/next 启用主题修改 站点配置文件，搜索 theme 字段。1theme: next 主题设定选择 Scheme修改 主题配置文件，搜索 scheme 字段。12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 设置头像修改 主题配置文件，搜索 avatar 字段。1avatar: /images/bio-photo.jpg favicon 设置1234567# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.favicon: small: /images/favicon-16x16.ico medium: /images/favicon-32x32.ico apple_touch_icon: /images/apple-touch-icon.png safari_pinned_tab: /images/favicon-logo.svg 关键字设置12# Set default keywords (Use a comma to separate)keywords: &quot;xuchengpeng, Hexo, NexT&quot; 页脚设置12345678910111213141516171819202122footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: user # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target=&quot;_blank&quot; rel=&quot;external nofollow&quot; href=&quot;https://pages.coding.me&quot;&gt;&lt;b&gt;Coding Pages&lt;/b&gt;&lt;/a&gt; 主题配置添加标签页面新建标签页面修改页面内容添加标签菜单12cd your-hexo-sitehexo new page tags 修改刚新建的页面，内容如下： 123456—title: “标签”date: 2017-11-23 10:49:56type: “tags”comments: false— 修改 主题配置文件，添加 tags 到 menu 中。 12menu: tags: /tags/ || tags 添加分类页面新建分类页面修改页面内容添加分类菜单12cd your-hexo-sitehexo new page categories 修改刚新建的页面，内容如下： 123456—title: “分类”date: 2017-11-23 10:49:18type: “categories”comments: false— 修改 主题配置文件，添加 categories 到 menu 中。 12menu: categories: /categories/ || th 添加留言页面新建留言页面修改页面内容添加留言菜单12cd your-hexo-sitehexo new page guestbook 修改刚新建的页面，内容如下： 12345678910—title: “留言”date: 2017-11-23 10:50:05type: “guestbook”comments: true—&lt;blockquote class=“blockquote-center”&gt;&lt;p&gt;凡人皆有一死，凡人皆需侍奉。&lt;/p&gt;&lt;/blockquote&gt; 修改 主题配置文件，添加 guestbook 到 menu 中。 12menu: 留言: /guestbook/ || commenting 菜单设置123menu_settings: icons: true badges: false 社交链接12345social: Wuhan, China.: https://www.google.com/maps || location-arrow E-Mail: mailto:xucp@outlook.com || envelope GitHub: https://github.com/xuchengpeng || github Bitbucket: https://bitbucket.org/xuchengpeng/ || bitbucket 友情链接123456789links_icon: linklinks_title: 友情链接links_layout: block#links_layout: inlinelinks: HarmonyHu: http://harmonyhu.com/ FreeSS: https://freess.cx/ LeanCloud: https://leancloud.cn/ NexT: https://github.com/theme-next/hexo-theme-next 站点 License1creative_commons: by-nc-sa 文章 License1234# Declare license on postspost_copyright: enable: true license: &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot; rel=&quot;external nofollow&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; 打赏12345# Reward#reward_comment: Donate comment herewechatpay: /images/wechatpay.jpgalipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png 文章目录设置123456789# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: true 侧边栏设置1234567891011121314151617181920212223242526sidebar: # Sidebar Position, available value: left | right (only for Pisces | Gemini). position: left #position: right # Sidebar Display, available value (only for Muse | Mist): # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. display: post #display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels (only for Pisces | Gemini). offset: 12 # Back to top in sidebar (only for Pisces | Gemini). b2t: false # Scroll percent label in b2t button. scrollpercent: true # Enable sidebar on narrow view (only for Muse | Mist). onmobile: false 设置代码高亮主题1highlight_theme: normal 调整内容区域显示的宽度修改 主题配置文件：12custom_file_path: variables: source/_data/variables.styl 在 variables.styl 文件中填入以下内容：12345// 修改成你期望的宽度$content-desktop = 800px// 当视窗超过 1600px 后的宽度$content-desktop-large = 1000px Pisces 和 Gemini 的修改方法为:12$main-desktop = 85%$content-desktop = calc(100% - 260px) 标签设置123456789101112131415161718192021222324# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: flat icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0# Label tag.label: true# Tabs tag.tabs: enable: true transition: tabs: true labels: true border_radius: 0 第三方功能设置页面文章的篇数123npm install --save hexo-generator-indexnpm install --save hexo-generator-archivenpm install --save hexo-generator-tag 修改 站点配置文件，设定如下选项：12345678910index_generator: per_page: 5archive_generator: per_page: 20 yearly: true monthly: truetag_generator: per_page: 10 设置RSS 安装插件1npm install hexo-generator-feed --save 增加配置修改 站点配置文件：123456789# 参数说明查看 README：https://github.com/hexojs/hexo-generator-feedfeed: type: atom path: atom.xml# 文章数，0 为全部 limit: 0 hub:# 是否包含文章内容 content: true 添加分享功能 下载插件 1git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton 修改 主题配置文件： 123456needmoreshare2: enable: true postbottom: enable: true float: enable: false #### Gitalk评论支持为NexT主题部署Gitalk评论插件 Valine评论系统Valine 是一款基于Leancloud的快速、简洁且高效的无后端评论系统。 获取 App ID 和 App Key。登录 LeadCloud，进入控制台后创建应用，进入应用，在 设置 &gt; 应用Key 中获取 App ID 和 App Key。 在应用中配置自己的安全域名。 修改 主题配置文件：12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true appid: xxxxxxxxx # your leancloud application appid appkey: xxxxxxxxxx # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Leave your comments here... # comment box placeholder avatar: wavatar # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 文章阅读次数统计 获取 App ID 和 App Key。登录 LeadCloud，进入控制台后创建应用，进入应用，在 设置 &gt; 应用Key 中获取 App ID 和 App Key。 进入应用，在 存储 中创建名称为 Counter 的 Class，权限设置为 无限制。 修改 主题配置文件：123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: xxxxxxxx #&lt;app_id&gt; app_key: xxxxxxxxxx #&lt;app_key&gt; Fancybox 下载插件 1git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox 修改 主题配置文件： 1fancybox: true 设置背景动画 下载插件 1git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 修改 主题配置文件： 1canvas_nest: true 字数统计和阅读时长 安装插件 1npm install hexo-symbols-count-time --save 修改 站点配置文件： 12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true 修改 主题配置文件： 123456symbols_count_time: separated_meta: true item_text_post: true item_text_total: true awl: 5 wpm: 200 顶部加载进度条 下载插件 1git clone https://github.com/theme-next/theme-next-pace source/lib/pace 修改 主题配置文件： 12pace: truepace_theme: pace-theme-flash Local Search 安装插件1npm install hexo-generator-searchdb --save 增加配置修改 站点配置文件，添加如下配置：12345search: path: search.xml field: post format: html limit: 10000 启用本地搜索12local_search: enable: true 验证主题启动本地站点，并开启调试模式，命令是 hexo server --debug。此时可以使用浏览器访问 http://localhost:4000 ，检查是否运行正确。 生成器使用 Hexo 生成静态文件快速而且简单。1hexo generate 部署安装 hexo-deployer-git。1npm install hexo-deployer-git --save 修改 站点配置文件。1234deploy: type: git repo: git@github.com:xuchengpeng/xuchengpeng.github.io.git branch: master Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。1hexo deploy 写作修改文章模板编辑 scaffolds/post.md 文件：12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;udpated: &#123;&#123; date &#125;&#125;comments: truecategories:tags:---&lt;!-- more --&gt; 多图展示123456789101112131415161718---title: picture-testcomments: truedate: 2017-12-27 09:08:03udpated: 2017-12-27 09:08:03type: "picture"categories: - Picturetags: - Picture Group---&#123;% gp 4-2 %&#125; &#123;% img /images/bio-photo.jpg %&#125; &#123;% img /images/hust-logo.jpg %&#125; &#123;% img /images/pt-search-demo.jpg %&#125; &#123;% img /images/RJ-45-crystal-head.jpg %&#125;&#123;% endgp %&#125; 多图排版格式见 iissnan/hexo-theme-next#295，参考 theme/next/scripts/tags/group-pictures.js 文件定义。 Label 写作样式123456&#123;% label default@label_default %&#125;&#123;% label primary@label_primary %&#125;&#123;% label success@label_success %&#125;&#123;% label info@label_info %&#125;&#123;% label warning@label_warning %&#125;&#123;% label danger@label_danger %&#125; label_default label_primary label_success label_info label_warning label_danger Tab 写作样式1234567891011&#123;% tabs test %&#125;&lt;!-- tab aaa --&gt;**这是选项卡 1** 呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈……&lt;!-- endtab --&gt;&lt;!-- tab bbb --&gt;**这是选项卡 2**&lt;!-- endtab --&gt;&lt;!-- tab ccc --&gt;**这是选项卡 3** 哇，你找到我了！φ(≧ω≦*)♪～&lt;!-- endtab --&gt;&#123;% endtabs %&#125; aaabbbccc这是选项卡 1 呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈…… 这是选项卡 2 这是选项卡 3 哇，你找到我了！φ(≧ω≦*)♪～ Note 写作样式1234567891011121314151617181920212223&#123;% note default %&#125;note default&#123;% endnote %&#125;&#123;% note primary %&#125;note primary&#123;% endnote %&#125;&#123;% note success %&#125;note success&#123;% endnote %&#125;&#123;% note info %&#125;note info&#123;% endnote %&#125;&#123;% note warning %&#125;note warning&#123;% endnote %&#125;&#123;% note danger %&#125;note danger&#123;% endnote %&#125; note default note primary note success note info note warning note danger Button 写作样式1&#123;% button https://www.baidu.com, 点击下载百度, download fa-lg fa-fw %&#125; 点击下载百度 文字字体和颜色1&lt;font color=red size=6 face=“黑体”&gt;字体颜色&lt;/font&gt; 字体颜色 文字背景色1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=cyan&gt;背景颜色&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 背景颜色]]></content>
      <categories>
        <category>Technology</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[163邮箱已死]]></title>
    <url>%2Fhexo-blog%2F2017%2F12%2F24%2F163-mail-dead%2F</url>
    <content type="text"><![CDATA[国内qq邮箱和163邮箱一直是主力使用邮箱。目前qq邮箱使用授权码仍然可以使用，163邮箱虽然之前推出了授权码功能，但目前已无法使用 Spark 进行第三方登录，而只能使用网易邮箱大师这种体验非常差的官方客户端，国内互联网公司，做产品的态度可见一斑。已弃用了163邮箱了，注册Outlook邮箱好好用，干净可靠。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>E-mail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unsplash随机图片]]></title>
    <url>%2Fhexo-blog%2F2017%2F12%2F13%2Funsplash-random-pic%2F</url>
    <content type="text"><![CDATA[Unsplash 是一个完全免费的、无版权的高清图片资源网站。「无版权」是指这个网站上的图片由创作者自愿分享出来，完全免费提供给任何人作为任何用途使用。Unsplash 的原话是「do whatever you want」，进一步说明是「你可以免费对图片进行复制、修改、分发，包括用作商业目的，无需经过允许即可使用」。 Unsplash图片源Unsplash 提供图片源可以让用户使轻松简单的集成： 随机获取； 从特定用户随机获取； 从收藏随机获取； 按天/周更新； 从搜索结果随机获取； 获取指定的图片； …… 更多细节参见它们的官方介绍 https://source.unsplash.com/ 。 Unsplash随机获取图片获取图片的网址为 https://source.unsplash.com/random ；可根据电脑屏幕分辨率更改图片的大小，在上面的链接后面加上 /1920x1080 这样的限定即可；如果不想图片每次都刷新，可以设置更新频率，在链接后面加上 /daily 或者 /weekly 即可； Speed Dial 2 使用Unsplash随机图片源在 选项 - 主题 - 自定义网址 栏目，背景图片的网址填写 https://source.unsplash.com/random/1920x1080 ，这样每次打开新标签页，都会随机选取一张图片作为背景。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Unsplash</tag>
        <tag>Speed Dial 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户样式管理器Stylus]]></title>
    <url>%2Fhexo-blog%2F2017%2F12%2F12%2Fchrome-ext-stylus%2F</url>
    <content type="text"><![CDATA[去年 9 月底，流行的浏览器扩展 Stylish 及其用户社区 userstyles.org (USo) 更换了所有者。新所有者 Justin Hindman 日前正式宣布 Stylish 及 USo 成为数据分析公司 SimilarWeb 的一部分，最近更新的 Chrome 版已经开始默认收集用户信息。根据 uBlock Origin 作者 gorhill 分析，新的 Chrome 版会记录使用者浏览的每一个链接，包括从哪来和到哪去，加上唯一用户标识符及其他一些信息并进行两次 base64 编码后，发回 https://api.userstyles.org/tic/stats 。目前用户还可以选择排除（opt-out），虽然选择排除后 Stylish 的功能将受到很大限制。根据最后更新时间可以推断，其他浏览器版（Firefox、Safari、Opera）暂未受影响。AMO 审核人员 rctgamer3 表示 Stylish 还没有提交新版。” 为什么要用Stylus替换StylishStylus 是一个调整网页外观的用户样式管理器。它可让您轻松地为许多热门网站网站安装主题和皮肤。 请注意我们的扩展名称是 Styl“us”而不是 Styl“ish”，在知名扩展 Stylish 停止开发后（后续接手者并非原作者），我们在它的分支 1.5.2 版本基础上开发了 Stylus。Stylus 重写并优化了大部分的代码以提高性能。 相较于 Stylish 只是它新团队的私有软件，Stylus 为人民所创，为人民服务。Chrome 版的 Stylish 默认开启了隐私分析记录，它的界面也非常的简陋，对于中高端用户来说，使用 Stylish 创建和编写 CSS 样式，非常的麻烦。 创建 Stylus 的主要目标是删除所有分析功能，并回到更加用户友好的用户界面。它还添加了其他重要的新功能，比如备份功能，以及直观、可定制的样式自动更新功能。 非常好看的用户样式Baidu Lite 百度轻TieBa - Maverick 【百度贴吧样式】Flat_ZhihuDarkSearch for Googleweibo_v6GitHub Dark哔哩哔哩（bilibili.com）样式调整Wikipedia Dark Material Design]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>Extension</tag>
        <tag>CSS</tag>
        <tag>Stylish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网线水晶头接法]]></title>
    <url>%2Fhexo-blog%2F2017%2F12%2F06%2Fnetwork-cable-crystal-head%2F</url>
    <content type="text"><![CDATA[网线水晶头有两种接法，一种是直连互联法，一种是交叉互联法。 交叉线的做法是：一头采用568A标准，一头采用568B标准。平行（直通）线的做法是：两头同为568A标准或568B标准。 如果连接的双方地位不对等的，则使用平行（直通）线，例如电脑连接到路由器或交换机如果连接的两台设备是对等的，则使用交叉线，例如电脑连接到电脑]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>T568A/B</tag>
        <tag>RJ-45</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为NexT主题部署Gitalk评论插件]]></title>
    <url>%2Fhexo-blog%2F2017%2F12%2F04%2Fgitalk-for-next%2F</url>
    <content type="text"><![CDATA[在之前的文章中（Gitalk评论插件），已介绍过Gitalk评论插件，GitHub上为NexT添加Gitalk的pull request一直没有合入，自己手动本地部署吧。 为什么选择Gitalk由于国内网络大环境的原因，Disqus 等优秀的评论系统都需要梯子才能使用，多说已经停运，NexT 已支持的 Gitment 目前存在一些问题，作者好像也已经很久没有维护了，故选择现在还在活跃的 Gitalk。 新增插件代码新建 layout/_third-party/comments/gitalk.swig 文件，添加以下代码：1234567891011121314151617181920&#123;% if theme.gitalk.enable %&#125; &#123;% if page.comments %&#125; &lt;link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"&gt; &lt;script src="https://unpkg.com/gitalk/dist/gitalk.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; const gitalk = new Gitalk(&#123; clientID: '&#123;&#123;theme.gitalk.clientID&#125;&#125;', clientSecret: '&#123;&#123;theme.gitalk.clientSecret&#125;&#125;', repo: '&#123;&#123;theme.gitalk.repo&#125;&#125;', owner: '&#123;&#123;theme.gitalk.owner&#125;&#125;', admin: '&#123;&#123;theme.gitalk.admin&#125;&#125;'.split(','), id: location.pathname, // facebook-like distraction free mode distractionFreeMode: '&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;', createIssueManually: '&#123;&#123; theme.gitalk.createIssueManually &#125;&#125;' &#125;) gitalk.render('gitalk-container') &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 添加插件到NexT主题中修改 layout/_third-party/comments/index.swig 文件，添加以下代码：1&#123;% include 'gitalk.swig' %&#125; 根据添加启用插件修改 layout/_partials/comments.swig 文件，添加以下代码：1234&#123;% elseif theme.gitalk.enable %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="gitalk-container"&gt;&lt;/div&gt; &lt;/div&gt; 在主题中增加Gitalk配置修改 _config.yml 文件，增加以下代码：1234567891011# Gitalk# more info please open https://github.com/gitalk/gitalkgitalk: enable: true clientID: # Github Application Client ID clientSecret: # Github Application Client Secret repo: # Github repo owner: # Github repo owner admin: # support multiple admins split with comma, e.g. foo,bar distractionFreeMode: true # Facebook-like distraction free mode createIssueManually: true 填写相应的字段，通过 hexo 部署你的博客，即可看到评论插件效果。]]></content>
      <categories>
        <category>Technology</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Gitalk</tag>
        <tag>Gitment</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Platinum Seacher for Emacs]]></title>
    <url>%2Fhexo-blog%2F2017%2F11%2F29%2Fpt-emacs%2F</url>
    <content type="text"><![CDATA[pt is a code search tool similar to ack and the_silver_searcher(ag). It supports multi platforms and multi encodings. 特点 它搜索代码的速度是 ack 的3-5倍； 它搜索代码的速度和 ag 一样快； 它忽略 .gitignore 中定义的文件； 它搜索 UTF-8，EUC-JP，Shift_JIS 文件； 提供多个操作系统平台的运行文件（macOS，Windows，Linux）； 速度ack &lt; ag &lt; pt 安装 点击这里 下载所需的二进制执行文件； 将可执行文件的目录加入 PATH 环境变量； emacs 从 MELPA 安装 pt.el； spacemacs 在 dotspacemacs-additional-packages 配置中增加 pt； 使用 命令行 12345$ # Recursively searches for PATTERN in current directory.$ pt PATTERN$ # You can specify PATH and some OPTIONS.$ pt OPTIONS PATTERN PATH spacemacsM-x pt-regexp or M-x projectile-pt]]></content>
      <categories>
        <category>Software</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>emacs</tag>
        <tag>spacemacs</tag>
        <tag>pt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spacemacs - Emacs advanced Kit focused on Evil]]></title>
    <url>%2Fhexo-blog%2F2017%2F11%2F28%2Fspacemacs%2F</url>
    <content type="text"><![CDATA[A community-driven Emacs distribution - The best editor is neither Emacs nor Vim, it is Emacs and Vim! 这是一款定制化程度非常高的emacs配置，同时支持emacs和vim按键模式，无缝切换使用。 设定环境变量如果是在Windows环境下，需要设定HOME环境变量的值，一般为 C:\Users\username。 安装字体（可选）下载安装 Source Code Pro 字体。 下载spacemacs 在~目录下（即HOME）创建文件夹.emacs.d； 从 spacemacs 克隆develop分支的代码到.emacs.d文件夹下； 在.emacs.d文件夹下新建init.el文件，加入以下代码；1234(package-initialize)(setq spacemacs-start-directory "~/.emacs.d/spacemacs/")(load-file (concat spacemacs-start-directory "init.el")) 启动emacs 下载安装 emacs； 根据提示选择适合自己的配置，完成后spacemacs的配置保存在 ~/.spacemacs 中 我的配置文件； 如果启动中遇到以下提示：The directory ~/.emacs.d/server is unsafe 在server文件夹 “属性-安全-高级-所有者” 中修改所属用户。]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>emacs</tag>
        <tag>spacemacs</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚本管理器Tampermonkey]]></title>
    <url>%2Fhexo-blog%2F2017%2F11%2F27%2Fchrome-ext-tampermonkey%2F</url>
    <content type="text"><![CDATA[不装扩展（Extensions）的 Chrome 只能发挥它 40% 的能力。 各类实用的 Chrome 扩展是不少人选择 Chrome 浏览器的重要原因，经过多年发展，Chrome 的扩展种类已经非常丰富，除了那些「即装即用」的小工具之外，也有很多被誉为「神器」的强大扩展程序。 少数派此前介绍过的 Stylish 就算一款「神器」，通过安装各类 CSS 模板，它几乎可以美化一切网页。而另一款不得不提的「神器」就是今天要介绍的 Tampermonkey，也被戏称为「油猴」。 Tampermonkey 是一款免费的浏览器扩展和最为流行的用户脚本管理器，它适用于 Chrome, Microsoft Edge, Safari, Opera Next, 和 Firefox。 虽然有些受支持的浏览器拥有原生的用户脚本支持，但 Tampermonkey 将在您的用户脚本管理方面提供更多的便利。 它提供了诸如便捷脚本安装、自动更新检查、标签中的脚本运行状况速览、内置的编辑器等众多功能， 同时Tampermonkey还有可能正常运行原本并不兼容的脚本。 和 Stylish 类似，「油猴」也可以通过安装各类脚本对网站进行定制。不过它能定制的不仅仅是网站的样式，还能实现更多更强大的功能，例如： 直接下载百度网盘文件 重新定制繁杂的微博页面 去掉视频播放广告 将网站默认的「二维码登录」改回「账号密码登录」 绕过搜索引擎的跳转提示 还原清新的小说阅读模式 豆瓣和 IMDb 互相显示评分 …… 下载地址：https://chrome.google.com/webstore/detail/dhdgffkkebhmkfjojejmpbldmpobfkfo 常用脚本： 百度网盘直接下载助手 破解VIP会员视频集合 网页限制解除 …… 其他Chrome经典拓展：点击这里]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>Extension</tag>
        <tag>Script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存的战争]]></title>
    <url>%2Fhexo-blog%2F2017%2F11%2F25%2Fwar-of-mem%2F</url>
    <content type="text"><![CDATA[2012年2月3日，全球著名内存生产厂商镁光科技的CEO史蒂夫·阿普尔顿（Steve Appleton），在美国爱达荷州的波伊西(Boise)的一个航空展上，驾驶着一架Lancair IV-PT螺旋桨飞机，给观众们做表演。起飞后不久，飞机失去控制，紧急降落失败，直接栽向地面，当场坠毁，CEO享年51岁。 喜欢玩心跳的CEO挂了，镁光股价倒是没怎么跌，大洋彼岸的一个叫坂本幸雄(Yukio Sakamoto)的日本人却急得如热锅上的蚂蚁。在上飞机前，阿普尔顿刚刚跟他谈完一份儿秘密协议，对于坂本幸雄担任社长的日本内存巨头尔必达来说，这份协议就是就保命书。 尔必达是日本芯片行业的“国家队”， 由日立、NEC和三菱的内存制造业务合并而成，一度风光无限。但08年金融危机之后，内存行业过剩，产品价格不断下跌，加上韩国厂商的挤压，尔必达经营不断恶化。尽管日本政府多次救助，仍然无法挽救，到了2011年底，尔必达已经积累了天量的负债和亏损。 全世界的银行都喜欢晴天借伞雨天收伞。尔必达债主一堆，纷纷抽贷，政府背景的日本政策投资银行出面协调，提出了给予续贷和注资的唯一条件，就是在2012年2月底之前，引入一家大型内存厂商做战略股东，否则只能撒手不管。而当时有这个资格接盘的已经剩不到几家，抛开死敌韩国人之外，只剩镁光。 坂本幸雄跟史蒂夫·阿普尔顿谈了几个月，关键条款都已经谈成了，结果天雷滚滚，在离deadline仅剩下二十多天的时候，喜欢赛车、跳伞、飚飞机、水肺潜水的阿普尔顿求锤得锤，入股的事情则无限期推迟，根本没有plan B的坂本幸雄欲哭无泪。2012年2月27号，尔必达宣布破产。 一个产业的运数，跟所谓国运一样，往往都带着些诡异的偶然性。 01尔必达破产的2012年，对日本制造来说，是个倒霉的年份。这一年，日本的电子产业全线崩溃。首先，半导体领域除了尔必达破产之外，另外一家巨头瑞萨也陷入危机；其次是松下、索尼、夏普三大巨头的亏损总额达到了创纪录的1.6万亿日元；最后是整体电子产业的产值，只有12万亿日元左右，还不到2000年时（26万亿）的一半。 日本“失去的十年”，通常是指1991年泡沫破灭之后的十年。但从91年开始，日本的两个产业却仍然逆势而上，是泡沫破灭之后支撑日元汇率和外汇储备的关键。这两个产业，一个是汽车，一个是电子。1991年NHK特意做了一期节目，叫做《电子立国—日本的自传》，将电子和汽车行业并列，把索尼松下等公司摆出来历数家珍，得意之情溢于言表。 2000年是一个分水岭。在这一年，汽车和电子的产值仍然势均力敌，之后两者分道扬镳。汽车行业继续出海征战，丰田本田日产在全球的地位稳步上升。但电子产业则每况愈下，不仅产值在10年之间就减少一半，2013年更是出现了贸易逆差，曾经无比强大的日本电子产业，出口额竟然少于进口额，令人难以想象。 但是，尔必达的破产，除了跟日本制造大环境有关外，主要的原因还是来自于过山车式的内存价格波动。电子产品通常给人的印象是每年都会降价，每年花同样的钱，可以买更好的东西。但内存行业却清新脱俗，价格走势跟化工品类似，强周期性，大起大落，涨起价来数钱数的全身颤抖，杀起价来丧心病狂连自己都往死里砍。 强周期性行业，通常都会有这么几个特点：1. 产品标准化程度高，用户粘性弱，谁的便宜买谁的；2. 行业具备规模效应，大规模生产能够有效摊低成本；3. 重资产，折旧巨大，一旦投产没法停，亏本也要硬着头皮生产，起码还有现金流； 4. 行业格局尚不稳定，没有价格同盟，涨价时厂商都想疯狂扩产搞死对手，低谷时通过破产兼并来实现去产能。内存符合上述全部特点。 内存的正式名字叫做“存储器”，是半导体行业三大支柱之一。2016年全球半导体市场规模为3400亿美金，存储器就占了768亿美元。对于你身边的手机、平板、PC、笔记本等所有电子产品来说，存储器就类似于钢铁之于现代工业，是名副其实的电子行业“原材料”。如果再将存储器细分，又可分为DRAM、NAND Flash和Nor Flash三种，其中DRAM主要用来做PC机内存（如DDR）和手机内存（如LPDDR），两者各占三成，尔必达做的，就是DRAM。 DRAM领域经过几十年的周期循环，玩家从80年代的40~50家，逐渐减少到了08年金融危机之前的五家，分别是：三星（韩）、SK海力士（韩）、奇梦达（德）、镁光（美）和尔必达（日），五家公司基本控制了全球DRAM供给，终端产品厂商如金士顿，几乎没有DRAM生产能力，都要向它们采购原材料。按照常理来说，格局已经趋稳，价格战理应偃旗息鼓，可惜的是，韩国人并不答应，尤其是三星。 三星充分利用了存储器行业的强周期特点，依靠政府的输血，在价格下跌、生产过剩、其他企业削减投资的时候，逆势疯狂扩产，通过大规模生产进一步下杀产品价格，从而逼竞争对手退出市场甚至直接破产，世人称之为“反周期定律”。在存储器这个领域，三星一共祭出过三次“反周期定律”，前两次分别发生在80年代中期和90年代初，让三星从零开始，做到了存储器老大的位置。但三星显然觉得玩的还不够大，于是在2008年金融危机前后，第三次举起了“反周期”屠刀。 2007 年初，微软推出了狂吃内存的Vista操作系统，DRAM厂商判断内存需求会大增，于是纷纷上产能，结果Vista 销量不及预期，DRAM 供过于求价格狂跌，加上08 年金融危机的雪上加霜，DRAM 颗粒价格从2.25 美金雪崩至0.31 美金。就在此时，三星做出令人瞠目结舌的动作：将2007 年三星电子总利润的118%投入DRAM 扩张业务，故意加剧行业亏损，给艰难度日的对手们，加上最后一根稻草。 效果是显著的。DRAM价格一路飞流直下，08年中跌破了现金成本，08年底更是跌破了材料成本。2009年初，第三名德系厂商奇梦达首先撑不住，宣布破产，欧洲大陆的内存玩家就此消失。2012年初，第五名尔必达宣布破产，曾经占据DRAM市场50%以上份额的日本，也输掉了最后一张牌。在尔必达宣布破产当晚，京畿道的三星总部彻夜通明，次日股价大涨，全世界都知道韩国人这次又赢了。 至此，DRAM领域最终只剩三个玩家：三星、海力士和镁光。尔必达破产后的烂摊子，在2013年被换了新CEO的镁光以20多亿美金的价格打包收走。20亿美金实在是个跳楼价，5年之后，镁光市值从不到100亿美元涨到460亿，20亿美元差不多是它市值一天的振幅。 举国之力扶持一个领域，从积弱到反超，中国体育只能算入门级，韩国人才是祖师爷。 022012年初尔必达破产之后，DRAM颗粒价格并没有马上涨起来，而是继续盘整到了下半年，之后价格才开始飙升。到了2013年10月份，DRAM价格已经比尔必达破产时的价格整整高了一倍。三家寡头在2013-14年过了两年好日子，在15年又开始重新一波扩产，造成了短暂的供过于求，DRAM价格又开始了一轮下跌，一直跌倒2016年年中，但这次下跌，对三个寡头来说，远远没到伤筋动骨的地步。 2016年下半年，新投放的产能已经消化的差不多，而市场的需求还在快速增长。DRAM产能之前有三成供给手机，而随着手机厂商在内存上打起了“军备竞赛”，接近60%的DRAM产能被手机吃掉，尤其到了手机备货旺季的三季度，DRAM全面缺货，价格不断跳涨，PC用的内存条也就跟着水涨船高，摇身变成了“理财产品”。 最近，有这么一个段子：“2016年开网吧，买了DDR4 8g内存条400多根，一根180快块钱。今年2017年，网吧赔了10多万，昨天我把网吧电脑全卖了，二手内存条卖500一根，居然赚回了我开网吧的钱。” 段子不知真假，但内存条的涨价，已有疯狂的态势。目前一根DDR4 8G台式机内存，已经 涨到了900元，而在2016年年中，同样的产品才卖200元左右。有微博网友算了一下，目前一根入门级DDR4 16G内存 = 28英寸4K显示器 = I5处理器主板套装 = 512GB 960EVO固态 = 索泰超频GTX1060显卡。如果再这样涨下去，恐怕连《绝地求生》都玩不起了。 除了DRAM之外，存储器另外一个领域NAND Flash，也面临类似的情况。NAND Flash市场的玩家，有三星、东芝/闪迪、美光、SK 海力士，四家总共占市场99%份额。相比DRAM市场，多了一个东芝/闪迪。NAND Flash主要用在两个领域，一个是手机的闪存，另外一个是固态硬盘SSD，这两个领域，都是飞速增长的领域，带动NAND价格也一路飙升。 Nor Flash市场比较特别，虽然价格也在涨，但逻辑却不太一样。在功能机时代，手机对内存的要求不高，Nor Flash凭借着NOR+PSRAM的XiP架构，得到广泛应用。但到了智能机时代，大量吃内存的APP涌现，NOR的容量小成本高的缺点就暴露无疑，逐渐被NAND给取代，市场不断萎缩，三星、镁光、Cypress等公司都逐步退出NOR市场。 但就在各大厂商关停Nor产线的同时，Nor却迎来了第二春。最主要的是AMOLED屏幕需要带一块Nor Flash来做电学补偿，AMOLED显示屏的渗透率正在加速，尤其是苹果采用了之后，所以Nor的需求就一下子被带动起来。然而，镁光等公司已经把一只脚迈出去了，也懒得再重新开产线，导致市场的Nor供应有限，一群小厂商因此受益，如台湾的旺宏、华邦，以及大A股的明星兆易创新。 应该说，Nor市场太小，存储器主要战场还是在DRAM和NAND上，而这两个领域的格局已经很稳固，三星、镁光、海力士，外加一个四处卖身的东芝。三星要想再通过“反周期定律”消灭对手，已经很难了，既然无法消灭对手，自损八百的自杀式冲锋就不会再重现。最大的可能是：存储器价格随着供给/需求的变化而进行短周期波动，但行业将长期维持暴利状态。 问题在于，这么赚钱又好玩的局，怎么能少了我们中国人？ 03在尔必达2012年破产的那个早春，紫光的赵伟国正在福建莆田搞一个叫做萩芦山庄的地产项目，存储器领域的巨变，似乎与他无关。恐怕他自己都不会想到，5年后，他会喊出“10年内成为全球存储器行业前五”的口号。 但情况在第二年就有了变化。2013年，紫光并购展讯，第一次将脚踏进了半导体领域，2014年，在没有发改委“小路条”的情况下，又从浦东科投手中抢来了锐迪科。赵伟国将两家企业塞进一个控股公司中，起名为“紫光展锐”，并顺利拉来了Intel的15亿美金的入股，投后估值75亿美元。相比收购两家公司花的27亿美元，赵伟国赚了他发家后最大的一桶金。 紫光完成收购锐迪科的2014年，行业里的空气突然变得炽热和躁动，但极少人会意识到，2014年会被后人称为中国半导体“元年”。在这之前，十几位院士专家上书中央，要求国家倾力支持半导体发展，并获得来自最高层的积极回复，到了9月份，规模达千亿的国家级基金挂牌成立，在接下来的三年中，它将彻底改变中国乃至全球半导体行业的生态。 每年进口数百亿美金、国产化近乎为零的存储器行业，自然首先进入到了各路资本的视野中来。但即使跋扈如赵伟国者，也不敢直接对站在无数尸体上的三星海力士发起挑战，而是采取迂回方式，对实力偏弱的镁光发起了要约收购，报价230亿美金，溢价19%。假如收购成功，按照镁光昨天的收盘价，镁光市值超过460亿美元，这笔交易浮盈将超过一倍。 这并非是中国资本第一次试图收购海外半导体公司。早在2012年，联想系的弘毅投资曾经联合TPG，竞购破产后的尔必达。如果收购成功，对于缺乏核心技术和零部件的联想来说意义重大，可惜功亏一篑。自此，弘毅再也没有围绕着联想系的主业做产业链并购的尝试，而经常跃入眼球的投资案例，是Pizza Express和西少爷肉夹馍。 紫光对镁光的要约收购，毫无悬念地被美国政府挡了回来，赵伟国也并没有赚到200亿美金的浮盈。当然，镁光还多此一举，向外界保证“三年内不会在大陆建立晶圆厂”，这无疑激怒了掌握巨额资金的赵伟国们，既然走捷径不成，那只能自己从头做。于是，长江存储、合肥长鑫、福建晋华三大存储器项目破土动工，长江南北一片大干快上赶英超美的架势。 三星的“反周期定律”在别的国家可能很难被复制，但在大陆这里，只会被玩儿的更加纯熟。例如，三星和LG通过反周期投资，成功的将日本面板产业打垮，大陆政府有样学样，通过多年的输血和补贴，终于拿钱砸出了一个京东方。因此，在存储器领域，大陆也有了道路自信，但相较于面板行业，存储器项目技术门槛更难，面临的对手也更强大。 针对火热的行情以及大陆资本的进入，三星海力士镁光已经启动了新一轮的扩产，在这一轮暴涨中，这些公司也储备了足够多的粮草和弹药，来欢迎新的玩家的进入。可以预见的是，大陆存储器项目达产之日，就是内存再次杀到现金成本甚至材料成本的日子，这个时间可能会是在2019年左右。届时，现在抱怨内存条太贵没法流畅吃鸡的同学，不妨多买几根屯着。 以前有人揭示过一个规律：很多产业，首先被美国人发明出来，美国人赚了一波钱后，产业基本上就在日本、韩国、大陆、台湾这四个地方转圈。这四个玩家如同在打一桌麻将，互相斗的吐血，但却轮流胡牌，最后反而把麻将圈外全世界人的钱给赚走了。这条规律最适用的，恐怕就是电子行业。 回到本文的开头，尔必达的末代社长坂本幸雄，在尔必达破产后做了两件事情，一是写了一本书，叫做《非情愿的战败》，书名反映内容。二是来到了中国，试图利用中国的资金东山再起。坂本幸雄成立了一家叫Sino King Technology的DRAM设计开发公司，Sino=中国的，King=王，SKT在中国找的第一个合作方，就是斥资72亿美元的合肥长鑫存储器项目。但显然，手握资本的地方政府，已经过了对外国专家言听计从的年代，在本土人才崛起、海外人才流入的大背景下，70岁的坂本幸雄，代表日本最后一代半导体人才，恐怕未必会是他们的首选。 所以，无论是产业的命运，还是国家的命运，是偶然也是必然，是周期也是轮回，中日韩三国的产业恩怨，还没有翻到结束的那章。]]></content>
      <categories>
        <category>News</category>
      </categories>
      <tags>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitalk评论插件]]></title>
    <url>%2Fhexo-blog%2F2017%2F11%2F24%2Fgitalk-comment-extension%2F</url>
    <content type="text"><![CDATA[Gitalk 是一个基于 Github Issue 和 Preact 开发的评论插件。 特性 使用 Github 登录 支持多语言 [en, zh-CN, zh-TW, es-ES, fr] 支持个人或组织 无干扰模式（设置 distractionFreeMode 为 true 开启） 快捷键提交评论 （cmd|ctrl + enter） 安装 直接引入 123&lt;link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"&gt;&lt;script src="https://unpkg.com/gitalk/dist/gitalk.min.js"&gt;&lt;/script&gt; npm 安装 1npm i --save gitalk 12import 'gitalk/dist/gitalk.css'import Gitalk from 'gitalk' 使用需要 Github Application，如果没有 点击这里申请，Authorization callback URL 填写当前使用插件页面的域名。1234567891011const gitalk = new Gitalk(&#123; clientID: 'Github Application Client ID', clientSecret: 'Github Application Client Secret', repo: 'Github repo', owner: 'Github repo owner', admin: ['Github repo owner and collaborators, only these guys can initialize github issues'], // facebook-like distraction free mode distractionFreeMode: false&#125;)gitalk.render('gitalk-container') 类似项目 Gitment评论系统]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Gitalk</tag>
        <tag>Gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT - Elegant Theme for Hexo]]></title>
    <url>%2Fhexo-blog%2F2017%2F11%2F23%2Fhexo-next-blog%2F</url>
    <content type="text"><![CDATA[下一步，学习一下用这个东东搭建一个blog吧。 Hexo NexT 其他教程： http://www.jianshu.com/p/5973c05d7100 http://www.jianshu.com/p/e99ed60390a8]]></content>
      <categories>
        <category>Technology</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Chrome必备插件]]></title>
    <url>%2Fhexo-blog%2F2017%2F11%2F22%2Fgoogle-chrome-extensions%2F</url>
    <content type="text"><![CDATA[收录Chrome最经典的扩展，如Tampermonkey、uBlock Origin、smartUp Gestures等，款款都是神器。 脚本管理器TampermonkeyTampermonkey 是一款免费的浏览器扩展和最为流行的用户脚本管理器，它适用于 Chrome, Microsoft Edge, Safari, Opera Next, 和 Firefox。 虽然有些受支持的浏览器拥有原生的用户脚本支持，但 Tampermonkey 将在您的用户脚本管理方面提供更多的便利。 它提供了诸如便捷脚本安装、自动更新检查、标签中的脚本运行状况速览、内置的编辑器等众多功能， 同时Tampermonkey还有可能正常运行原本并不兼容的脚本。 下载地址：https://chrome.google.com/webstore/detail/dhdgffkkebhmkfjojejmpbldmpobfkfo 广告拦截工具uBlock Origin一款高效的请求过滤工具：占用极低的内存和CPU，和其他常见的过滤工具相比，它能够加载并执行上千条过滤规则。 下载地址：https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm 类似的扩展还有Adblock Plus 鼠标手势smartUp Gestures一个更好的手势类扩展。功能包括：鼠标手势，简易拖曳，超级拖曳，摇杆手势和滚轮手势。 下载地址：https://chrome.google.com/webstore/detail/smartup-gestures/bgjfekefhjemchdeigphccilhncnjldn Markdown文件预览Markdown Viewer支持包括GFM在内的多种主题。 下载地址：https://chrome.google.com/webstore/detail/markdown-viewer/ckkdlimhmcjmikdlpkmbgfkaikojcbjk 墙内的用户如果无法访问谷歌商店，可借助以下网站：https://chrome-extension-downloader.comhttps://crx.2333.me/https://www.chromefor.com/]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>Extension</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitment评论系统]]></title>
    <url>%2Fhexo-blog%2F2017%2F11%2F22%2Fgitment-comment-system%2F</url>
    <content type="text"><![CDATA[Gitment 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 注册 OAuth Application点击此处 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是博客评论页面对应的域名，例如 https://xxxxxx.github.io ）。 你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。 引入 Gitment将下面的代码添加到你的页面： 123456789101112131415&lt;div id="container"&gt;&lt;/div&gt;&lt;link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"&gt;&lt;script src="https://imsun.github.io/gitment/dist/gitment.browser.js"&gt;&lt;/script&gt;&lt;script&gt;var gitment = new Gitment(&#123; id: '页面 ID', // 可选。默认为 location.href owner: '你的 GitHub ID', repo: '存储评论的 repo，可以自己新建一个，也可以直接使用博客的 repo', oauth: &#123; client_id: '你的 client ID', client_secret: '你的 client secret', &#125;,&#125;)gitment.render('container')&lt;/script&gt; 注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。 初始化评论在博客页面最下面，登陆 GitHub 的帐号，点击初始化按钮，之后其他用户即可在该页面发表评论。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Gitment</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Chrome下载地址]]></title>
    <url>%2Fhexo-blog%2F2017%2F11%2F21%2Fgoogle-chrome-download-addr%2F</url>
    <content type="text"><![CDATA[以下都是Chrome浏览器的离线版本，包括Stable, Beta, Dev, Canary版本。 Stable 稳定版 32位最新版本：67.0.3396.62，文件大小：46.900MB，查询时间：2018-05-30 02:43 下载地址： http://redirector.gvt1.com/edgedl/release2/chrome/ANi_vDWvvWku_67.0.3396.62/67.0.3396.62_chrome_installer.exehttps://redirector.gvt1.com/edgedl/release2/chrome/ANi_vDWvvWku_67.0.3396.62/67.0.3396.62_chrome_installer.exehttp://dl.google.com/release2/chrome/ANi_vDWvvWku_67.0.3396.62/67.0.3396.62_chrome_installer.exehttps://dl.google.com/release2/chrome/ANi_vDWvvWku_67.0.3396.62/67.0.3396.62_chrome_installer.exehttp://www.google.com/dl/release2/chrome/ANi_vDWvvWku_67.0.3396.62/67.0.3396.62_chrome_installer.exehttps://www.google.com/dl/release2/chrome/ANi_vDWvvWku_67.0.3396.62/67.0.3396.62_chrome_installer.exeSHA1：86C7B1235E220B929E838A6F3C51E26252F50108，SHA256：0FB10F3ED9439CE05C8DB159CFB6BAB270A6C02846B43A28451FB37EFABC7C36 Stable 稳定版 64位最新版本：67.0.3396.62，文件大小：47.330MB，查询时间：2018-05-30 02:43 下载地址： http://redirector.gvt1.com/edgedl/release2/chrome/LqhWz0XCtic_67.0.3396.62/67.0.3396.62_chrome_installer.exehttps://redirector.gvt1.com/edgedl/release2/chrome/LqhWz0XCtic_67.0.3396.62/67.0.3396.62_chrome_installer.exehttp://dl.google.com/release2/chrome/LqhWz0XCtic_67.0.3396.62/67.0.3396.62_chrome_installer.exehttps://dl.google.com/release2/chrome/LqhWz0XCtic_67.0.3396.62/67.0.3396.62_chrome_installer.exehttp://www.google.com/dl/release2/chrome/LqhWz0XCtic_67.0.3396.62/67.0.3396.62_chrome_installer.exehttps://www.google.com/dl/release2/chrome/LqhWz0XCtic_67.0.3396.62/67.0.3396.62_chrome_installer.exeSHA1：77DCDADD5525E14BE0486ED28039B9CBE7A8AEB7，SHA256：F5D41B34E8F838325FD8E587F9F3474FC284AC03EB41CA0E2DC1DE49FC825225 Beta 测试版 32位最新版本：67.0.3396.62，文件大小：46.900MB，查询时间：2018-05-30 01:48 下载地址： http://redirector.gvt1.com/edgedl/release2/chrome/ANi_vDWvvWku_67.0.3396.62/67.0.3396.62_chrome_installer.exehttps://redirector.gvt1.com/edgedl/release2/chrome/ANi_vDWvvWku_67.0.3396.62/67.0.3396.62_chrome_installer.exehttp://dl.google.com/release2/chrome/ANi_vDWvvWku_67.0.3396.62/67.0.3396.62_chrome_installer.exehttps://dl.google.com/release2/chrome/ANi_vDWvvWku_67.0.3396.62/67.0.3396.62_chrome_installer.exehttp://www.google.com/dl/release2/chrome/ANi_vDWvvWku_67.0.3396.62/67.0.3396.62_chrome_installer.exehttps://www.google.com/dl/release2/chrome/ANi_vDWvvWku_67.0.3396.62/67.0.3396.62_chrome_installer.exeSHA1：86C7B1235E220B929E838A6F3C51E26252F50108，SHA256：0FB10F3ED9439CE05C8DB159CFB6BAB270A6C02846B43A28451FB37EFABC7C36 Beta 测试版 64位最新版本：67.0.3396.62，文件大小：47.330MB，查询时间：2018-05-30 01:48 下载地址： http://redirector.gvt1.com/edgedl/release2/chrome/LqhWz0XCtic_67.0.3396.62/67.0.3396.62_chrome_installer.exehttps://redirector.gvt1.com/edgedl/release2/chrome/LqhWz0XCtic_67.0.3396.62/67.0.3396.62_chrome_installer.exehttp://dl.google.com/release2/chrome/LqhWz0XCtic_67.0.3396.62/67.0.3396.62_chrome_installer.exehttps://dl.google.com/release2/chrome/LqhWz0XCtic_67.0.3396.62/67.0.3396.62_chrome_installer.exehttp://www.google.com/dl/release2/chrome/LqhWz0XCtic_67.0.3396.62/67.0.3396.62_chrome_installer.exehttps://www.google.com/dl/release2/chrome/LqhWz0XCtic_67.0.3396.62/67.0.3396.62_chrome_installer.exeSHA1：77DCDADD5525E14BE0486ED28039B9CBE7A8AEB7，SHA256：F5D41B34E8F838325FD8E587F9F3474FC284AC03EB41CA0E2DC1DE49FC825225 Dev 开发版 32位最新版本：68.0.3440.7，文件大小：47.914MB，查询时间：2018-05-31 03:13 下载地址： http://redirector.gvt1.com/edgedl/release2/chrome/UrKY4GI4fA0_68.0.3440.7/68.0.3440.7_chrome_installer.exehttps://redirector.gvt1.com/edgedl/release2/chrome/UrKY4GI4fA0_68.0.3440.7/68.0.3440.7_chrome_installer.exehttp://dl.google.com/release2/chrome/UrKY4GI4fA0_68.0.3440.7/68.0.3440.7_chrome_installer.exehttps://dl.google.com/release2/chrome/UrKY4GI4fA0_68.0.3440.7/68.0.3440.7_chrome_installer.exehttp://www.google.com/dl/release2/chrome/UrKY4GI4fA0_68.0.3440.7/68.0.3440.7_chrome_installer.exehttps://www.google.com/dl/release2/chrome/UrKY4GI4fA0_68.0.3440.7/68.0.3440.7_chrome_installer.exeSHA1：16B1DDA23943C0D6D1FF2CEB0F9C5554FBC3017D，SHA256：F462F8B2185D04F7C0076D5336F27088724D6EA49D09E2197EB8B686D078C620 Dev 开发版 64位最新版本：68.0.3440.7，文件大小：48.334MB，查询时间：2018-05-31 03:13 下载地址： http://redirector.gvt1.com/edgedl/release2/chrome/AMrg0ocEapmI_68.0.3440.7/68.0.3440.7_chrome_installer.exehttps://redirector.gvt1.com/edgedl/release2/chrome/AMrg0ocEapmI_68.0.3440.7/68.0.3440.7_chrome_installer.exehttp://dl.google.com/release2/chrome/AMrg0ocEapmI_68.0.3440.7/68.0.3440.7_chrome_installer.exehttps://dl.google.com/release2/chrome/AMrg0ocEapmI_68.0.3440.7/68.0.3440.7_chrome_installer.exehttp://www.google.com/dl/release2/chrome/AMrg0ocEapmI_68.0.3440.7/68.0.3440.7_chrome_installer.exehttps://www.google.com/dl/release2/chrome/AMrg0ocEapmI_68.0.3440.7/68.0.3440.7_chrome_installer.exeSHA1：1436B21BCC1D3ED9B1C68DD4F945207DB9D63D8B，SHA256：01CE8EA8594ECE8960D87DD153BB8FAE8E4ED85E2CF3115C745BE12C075328E8 Canary 金丝雀 32位最新版本：69.0.3445.2，文件大小：47.954MB，查询时间：2018-05-31 02:48 下载地址： http://redirector.gvt1.com/edgedl/release2/chrome/AIuOYoeB7lxp_69.0.3445.2/69.0.3445.2_chrome_installer.exehttps://redirector.gvt1.com/edgedl/release2/chrome/AIuOYoeB7lxp_69.0.3445.2/69.0.3445.2_chrome_installer.exehttp://dl.google.com/release2/chrome/AIuOYoeB7lxp_69.0.3445.2/69.0.3445.2_chrome_installer.exehttps://dl.google.com/release2/chrome/AIuOYoeB7lxp_69.0.3445.2/69.0.3445.2_chrome_installer.exehttp://www.google.com/dl/release2/chrome/AIuOYoeB7lxp_69.0.3445.2/69.0.3445.2_chrome_installer.exehttps://www.google.com/dl/release2/chrome/AIuOYoeB7lxp_69.0.3445.2/69.0.3445.2_chrome_installer.exeSHA1：B7914CBDF5AC2BDD08D1E02443E6D85252642237，SHA256：95195F0EDE6B58061EDE0BF6E2F3E83B138DBE90A47A115717C4499248C09ED3 Canary 金丝雀 64位最新版本：69.0.3445.2，文件大小：48.370MB，查询时间：2018-05-31 01:58 下载地址： http://redirector.gvt1.com/edgedl/release2/chrome/Vfnplb_kw08_69.0.3445.2/69.0.3445.2_chrome_installer.exehttps://redirector.gvt1.com/edgedl/release2/chrome/Vfnplb_kw08_69.0.3445.2/69.0.3445.2_chrome_installer.exehttp://dl.google.com/release2/chrome/Vfnplb_kw08_69.0.3445.2/69.0.3445.2_chrome_installer.exehttps://dl.google.com/release2/chrome/Vfnplb_kw08_69.0.3445.2/69.0.3445.2_chrome_installer.exehttp://www.google.com/dl/release2/chrome/Vfnplb_kw08_69.0.3445.2/69.0.3445.2_chrome_installer.exehttps://www.google.com/dl/release2/chrome/Vfnplb_kw08_69.0.3445.2/69.0.3445.2_chrome_installer.exeSHA1：D7AF82C47077536F6DD5A8AAB23B90633C926058，SHA256：E5DFB7AAC181FD76DD301D75C32BA7E41ED730048ADF19D3EA7C568E2D30531F]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SourceInsight代码检视]]></title>
    <url>%2Fhexo-blog%2F2017%2F11%2F20%2Fsourceinsight-codereview%2F</url>
    <content type="text"><![CDATA[这是一个SourceInsight使用的本地代码检视工具，利用Macro实现。 创建CodeReview.em文件将代码保存为CodeReview.em文件。 添加到base工程将CodeReview.em文件复制到base工程目录下。 设置快捷键在SourceInsight中设置“Review_Add_Comment”、“Review_Restore_Link”和“Review_Summary”等相关宏的快捷键即可使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631/** * * Code Review Tool * * Author: FN QD * * Amendment List: * * 2003.1.22 Javey * 1) Changed severity level according to the review form * 2) Excluded the category of &quot;suggestion&quot; when counting * total defects by category to comply with the review form * 2003.5.14 Javey *1) Forced reviewers to fill category and defect type. *2) Removed these categories:SysReq,SDes,Docs and Others * from summary section */macro GetReviewToolVersion()&#123; return &quot;2.0.2&quot;&#125;macro GetReviewDate()&#123; SysTime = GetSysTime(1) szYear=SysTime.Year szMonth=SysTime.month szDay=SysTime.day return &quot;@szYear@-@szMonth@-@szDay@&quot;&#125;macro Review_Restore_Link()&#123; hbuf = GetCurrentBuf() //sProjRoot = GetProjDir(GetCurrentProj()) sProjRoot = Cat(sProjRoot, &quot;\\&quot;) line = 0 while(True) &#123; sel = SearchInBuf(hbuf, &quot;FileName : &quot;, line, 0, 1, 0, 0) if(sel == &quot;&quot;) break line = sel.lnFirst col = sel.ichLim str = GetBufLine(hbuf, line) fileName = strmid(str, col, strlen(str)) //fileName = cat(sProjRoot, fileName) str = GetBufLine(hbuf, line+1) lnNumber = strmid(str, 11, strlen(str)) SetSourceLink(hbuf, line, fileName, lnNumber - 1) line = line+2 &#125; //updateSummary(hbuf)&#125;macro Review_Add_Comment()&#123; hbuf = GetCurrentBuf() curFileName = GetBufName(hbuf) sProjRoot = GetProjDir(GetCurrentProj()) //nPos = strlen(sProjRoot) //sFileName = strmid(curFileName, nPos+1, strlen(curFileName)) //ln从0开始编号 curLineNumber = GetBufLnCur(hbuf) totalline = GetBufLineCount (hbuf) curFunc = nil symbolrecord = nil cTempLine = curLineNumber /*下面处理主要解决空行、注释行symbol为空的问题*/ /*GetSymbolLocationFromLn参数ln是从0编号*/ while ((symbolrecord == nil) &amp;&amp; (cTempLine&lt;totalline)) &#123; symbolrecord = GetSymbolLocationFromLn(hbuf,cTempLine) if (symbolrecord != nil) &#123; curFunc = symbolrecord.Symbol /*对非func类的symbol，一律都显示空*/ if ((curFunc != nil) &amp;&amp; (symbolrecord.Type != Function) &#123; curFunc = nil &#125; break; &#125; cTempLine=cTempLine+1 &#125; sFileName = cat( &quot;FileName : &quot;, curFileName ) sLineNumber = cat( &quot;Line : &quot;, curLineNumber + 1 ) /* get the severity of the current comment */ promote = &quot;Severity : M,m(Major严重); G,g(General一般); S,s(Suggestion提示)&quot; sTemp = ask(promote); sTemp = toupper(sTemp[0]); while( sTemp != &quot;M&quot; &amp;&amp; sTemp != &quot;G&quot; &amp;&amp; sTemp != &quot;S&quot; ) &#123; sTemp = ask(cat(&quot;Please input again! &quot;, promote)); sTemp = toupper(sTemp[0]); &#125; if( sTemp == &quot;M&quot; ) sTemp = &quot;Major&quot;; else if ( sTemp == &quot;G&quot; ) sTemp = &quot;General&quot;; else if ( sTemp == &quot;S&quot; ) sTemp = &quot;Suggestion&quot;; sSeverity = cat( &quot;Severity : &quot;, sTemp ); promote = &quot;Category : 1.编程规范(代码级); 2.非编码规范(代码级); 3.业务功能; 4.软件结构&quot; sTemp = ask(promote); ChoseNumber = AsciiFromChar(sTemp); MinNumber = AsciiFromChar(&quot;1&quot;); MaxNumber = AsciiFromChar(&quot;4&quot;); while ((ChoseNumber &lt; MinNumber) || (ChoseNumber &gt; MaxNumber)) &#123; sTemp = ask(promote); sTemp = toupper(sTemp[0]); ChoseNumber = AsciiFromChar(sTemp); &#125; if( sTemp == &quot;1&quot; ) &#123; sCategory = cat( &quot;Category : &quot;, &quot;编程规范&quot;); &#125; else if ( sTemp == &quot;2&quot; ) &#123; sCategory = cat( &quot;Category : &quot;, &quot;非编码规范&quot;); &#125; else if ( sTemp == &quot;3&quot; ) &#123; sCategory = cat( &quot;Category : &quot;, &quot;业务功能&quot;); &#125; else if ( sTemp == &quot;4&quot; ) &#123; sCategory = cat( &quot;Category : &quot;, &quot;软件结构&quot;); &#125; if (sTemp == &quot;1&quot;) // 编程规范 &#123; promote = &quot;1.排版/命名 2.注释/可读性 3.常量左值/魔鬼数字 4.断言调试/打印&quot; sTemp = ask(promote); sTemp = toupper(sTemp[0]); ChoseNumber = AsciiFromChar(sTemp); MinNumber = AsciiFromChar(&quot;1&quot;); MaxNumber = AsciiFromChar(&quot;4&quot;); while ((ChoseNumber &lt; MinNumber) || (ChoseNumber &gt; MaxNumber)) &#123; sTemp = ask(promote); sTemp = toupper(sTemp[0]); ChoseNumber = AsciiFromChar(sTemp); &#125; EndMsg(); if( sTemp == &quot;1&quot; ) sTemp = &quot;排版/标识符命名&quot;; else if ( sTemp == &quot;2&quot; ) sTemp = &quot;注释/可读性&quot;; else if ( sTemp == &quot;3&quot; ) sTemp = &quot;常量左值/魔鬼数字&quot;; else if ( sTemp == &quot;4&quot; ) sTemp = &quot;断言调试/打印&quot;; sType = cat( &quot;Type : &quot;, sTemp ); &#125; else if (sTemp == &quot;2&quot;) // 非编码规范 &#123; promote = &quot;1.参数/返回值/优先级 2.变量初始化和赋值 3.资源申请释放 4.中断/效率/移植性 5.循环/if/switch 6.结构/宏/枚举 7.函数逻辑 8.其他&quot;; sTemp = ask(promote); sTemp = toupper(sTemp[0]); ChoseNumber = AsciiFromChar(sTemp); MinNumber = AsciiFromChar(&quot;1&quot;); MaxNumber = AsciiFromChar(&quot;8&quot;); while ((ChoseNumber &lt; MinNumber) || (ChoseNumber &gt; MaxNumber)) &#123; sTemp = ask(promote); sTemp = toupper(sTemp[0]); ChoseNumber = AsciiFromChar(sTemp); &#125; EndMsg(); if( sTemp == &quot;1&quot; ) sTemp = &quot;函数参数/返回值检查/操作符优先级&quot;; else if ( sTemp == &quot;2&quot; ) sTemp = &quot;变量/指针/数组/字符串初始化和赋值&quot;; else if ( sTemp == &quot;3&quot; ) sTemp = &quot;资源申请和释放&quot;; else if ( sTemp == &quot;4&quot; ) sTemp = &quot;中断/效率/可移植性&quot;; else if ( sTemp == &quot;5&quot; ) sTemp = &quot;循环/if/switch程序块&quot;; else if ( sTemp == &quot;6&quot; ) sTemp = &quot;结构/宏/枚举定义和使用&quot;; else if ( sTemp == &quot;7&quot; ) sTemp = &quot;函数逻辑控制&quot;; else if ( sTemp == &quot;8&quot; ) sTemp = &quot;其他&quot;; sType = cat( &quot;Type : &quot;, sTemp ); &#125; else if ( sTemp == &quot;3&quot; ) // 业务功能 &#123; promote = &quot;1.功能需求遗漏 2.功能需求没有正确实现&quot; sTemp = ask(promote); sTemp = toupper(sTemp[0]); ChoseNumber = AsciiFromChar(sTemp); MinNumber = AsciiFromChar(&quot;1&quot;); MaxNumber = AsciiFromChar(&quot;2&quot;); while ((ChoseNumber &lt; MinNumber) || (ChoseNumber &gt; MaxNumber)) &#123; sTemp = ask(promote); sTemp = toupper(sTemp[0]); ChoseNumber = AsciiFromChar(sTemp); &#125; EndMsg(); if( sTemp == &quot;1&quot; ) sTemp = &quot;功能需求遗漏&quot;; else if ( sTemp == &quot;2&quot; ) sTemp = &quot;功能需求没有正确实现&quot;; sType = cat( &quot;Type : &quot;, sTemp ); &#125; else if ( sTemp == &quot;4&quot; ) // 软件结构 &#123; promote = &quot;1.函数功能不单一 2.函数复杂度高 3.数据依赖多(全局，局部变量，参数) 4.全局变量访问不合理 5.冗余重复代码 6.其他&quot; sTemp = ask(promote); sTemp = toupper(sTemp[0]); ChoseNumber = AsciiFromChar(sTemp); MinNumber = AsciiFromChar(&quot;1&quot;); MaxNumber = AsciiFromChar(&quot;6&quot;); while ((ChoseNumber &lt; MinNumber) || (ChoseNumber &gt; MaxNumber)) &#123; sTemp = ask(promote); sTemp = toupper(sTemp[0]); ChoseNumber = AsciiFromChar(sTemp); &#125; EndMsg(); if( sTemp == &quot;1&quot; ) sTemp = &quot;函数功能不单一&quot;; else if ( sTemp == &quot;2&quot; ) sTemp = &quot;函数复杂度高&quot;; else if ( sTemp == &quot;3&quot; ) sTemp = &quot;数据依赖多(全局，局部变量，参数)&quot;; else if ( sTemp == &quot;4&quot; ) sTemp = &quot;全局变量访问不合理&quot;; else if ( sTemp == &quot;5&quot; ) sTemp = &quot;冗余重复代码&quot;; else if ( sTemp == &quot;6&quot; ) sTemp = &quot;其他&quot;; sType = cat( &quot;Type : &quot;, sTemp ); &#125; /* get the comment */ promote = &quot;Input your comment:&quot; sTemp = ask(promote); sComments = cat( &quot;Comments : &quot;, sTemp ); /* get the licence user name for the reviewer name */ progRecord = GetProgramEnvironmentInfo() sMyName = progRecord.UserName szReviewDate = GetReviewDate() szReviewFileName = &quot;ReviewComment_@sMyName@_@szReviewDate@.txt&quot; /* get the ReviewComment buffer handle */ bNewCreated = false; // used for the review comment is firstly created hout = GetBufHandle(szReviewFileName) if (hout == hNil) &#123; // No existing Review Comment buffer hout= OpenBuf (szReviewFileName) if( hout == hNil ) &#123; /* No existing ReviewComment.txt, then create a new review comment buffer */ hout = NewBuf(szReviewFileName) NewWnd(hout) bNewCreated = true /*----------------------------------------------------------------*/ /* Get the owner&apos;s name from the environment variable: MYNAME. */ /* If the variable doesn&apos;t exist, then the owner field is skipped.*/ /*----------------------------------------------------------------*/ AppendBufLine(hout, &quot;[Review Info] &quot;) AppendBufLine(hout, cat(&quot;ReviewTool Version : &quot;, GetReviewToolVersion())) AppendBufLine(hout, cat(&quot;Reviewer Name : &quot;, sMyName)) sDate = GetSysTime(1) AppendBufLine(hout, cat(&quot;Review Date : &quot;, sDate.date)) /* Size summary */ AppendBufLine(hout, &quot;Review size(KLOC) : &quot;) /* Effort summary */ AppendBufLine(hout, &quot;Review effort(P*Hours): &quot;) AppendBufLine(hout, &quot;Rework effort(P*Hours): &quot;) AppendBufLine(hout, &quot;-------------------------------------------------------------------------&quot;) AppendBufLine(hout, &quot;&quot;) &#125; &#125; // end of get ReviewComment buffer handle delSummary(hout) AppendBufLine(hout, sFileName) AppendBufLine(hout, sLineNumber) AppendBufLine(hout, cat(&quot;Reviewer : &quot;, sMyName)) AppendBufLine(hout, cat(&quot;Symbol : &quot;, curFunc) ) AppendBufLine(hout, sSeverity) AppendBufLine(hout, &quot;Status : Open&quot;) AppendBufLine(hout, sComments) AppendBufLine(hout, &quot;Resolve : &quot;) AppendBufLine(hout, sCategory) AppendBufLine(hout, sType) AppendBufLine(hout, &quot;Author : &quot;) AppendBufLine(hout, &quot;Phase : &quot;) AppendBufLine(hout, &quot;&quot;) lnSource = GetBufLineCount(hout) - 12 SetSourceLink(hout, lnSource, curFileName, curLineNumber) updateSummary(hout) if( bNewCreated ) SetCurrentBuf(hbuf) jump_to_link;&#125;macro Review_Summary()&#123; hbuf = GetCurrentBuf() updateSummary(hbuf)&#125;macro updateSummary(hbuf)&#123; rvSum0 = getReviewSummary(hbuf) rvSum = &quot;major=\&quot;0\&quot;;general=\&quot;0\&quot;;suggestion=\&quot;0\&quot;;open=\&quot;0\&quot;;closed=\&quot;0\&quot;;rejected=\&quot;0\&quot;;duplicate=\&quot;0\&quot;;discuss=\&quot;0\&quot;;SysReq=\&quot;0\&quot;;SDes=\&quot;0\&quot;;SRS=\&quot;0\&quot;;HLD=\&quot;0\&quot;;LLD=\&quot;0\&quot;;TP=\&quot;0\&quot;;Code=\&quot;0\&quot;;Docs=\&quot;0\&quot;;Others=\&quot;0\&quot;&quot; /* summary the severity */ ln = 0 while (True) &#123; sel = SearchInBuf(hbuf, &quot;^Severity\\s+:\\s+&quot;, ln, 0, 1, 1, 0) if (sel == null) break ln = sel.lnFirst col = sel.ichLim s = GetBufLine(hbuf, ln) sTemp = strmid(s, col, col+1) sTemp = toupper(sTemp); if (sTemp == &quot;M&quot; &amp;&amp; validDefect(hbuf, ln)) rvSum.major = rvSum.major + 1 else if (sTemp == &quot;G&quot; &amp;&amp; validDefect(hbuf, ln)) rvSum.general = rvSum.general + 1 else if (sTemp == &quot;S&quot; &amp;&amp; validDefect(hbuf, ln)) rvSum.suggestion = rvSum.suggestion + 1 ln = ln + 1 &#125; /* summary the satus */ ln = 0 while (True) &#123; sel = SearchInBuf(hbuf, &quot;^Status\\s+:\\s+&quot;, ln, 0, 1, 1, 0) if (sel == null) break ln = sel.lnFirst col = sel.ichLim s = GetBufLine(hbuf, ln) sTemp = strmid(s, col, col+1) sTemp = toupper(sTemp); if (sTemp == &quot;O&quot;) rvSum.open = rvSum.open + 1 else if (sTemp == &quot;C&quot;) rvSum.closed = rvSum.closed + 1 else if (sTemp == &quot;R&quot;) rvSum.rejected = rvSum.rejected + 1 else if (sTemp == &quot;D&quot;) &#123; sTemp = strmid(s, col+1, col+2) sTemp = toupper(sTemp); if (sTemp == &quot;U&quot;) rvSum.duplicate = rvSum.duplicate + 1 else if (sTemp == &quot;I&quot;) rvSum.discuss = rvSum.discuss + 1 &#125; ln = ln + 1 &#125; /* summary the categories */ /*ln = 0 while (True) &#123; norej = norejected(hbuf, ln); notsug = notsuggestion(hbuf, ln) sel = SearchInBuf(hbuf, &quot;^Category\\s+:\\s+&quot;, ln, 0, 1, 1, 0) if (sel == null) break ln = sel.lnFirst col = sel.ichLim s = GetBufLine(hbuf, ln) if ( col+2 &gt; strlen(s)) &#123; msg(&quot;Please write categories!&quot;) return &#125; sTemp = strmid(s, col, col+2) sTemp = toupper(sTEmp); if (sTemp == &quot;SY&quot; &amp;&amp; norej &amp;&amp; notsug) rvSum.SysReq = rvSum.SysReq + 1 else if (sTemp == &quot;SD&quot; &amp;&amp; norej &amp;&amp; notsug) rvSum.SDes = rvSum.SDes + 1 else if (sTemp == &quot;SR&quot; &amp;&amp; norej &amp;&amp; notsug) rvSum.SRS = rvSum.SRS + 1 else if (sTemp == &quot;HL&quot; &amp;&amp; norej &amp;&amp; notsug) rvSum.HLD = rvSum.HLD + 1 else if (sTemp == &quot;LL&quot; &amp;&amp; norej &amp;&amp; notsug) rvSum.LLD = rvSum.LLD + 1 else if (sTemp == &quot;TP&quot; &amp;&amp; norej &amp;&amp; notsug) rvSum.TP = rvSum.TP + 1 else if (sTemp == &quot;CO&quot; &amp;&amp; norej &amp;&amp; notsug) rvSum.Code = rvSum.Code + 1 else if (sTemp == &quot;DO&quot; &amp;&amp; norej &amp;&amp; notsug) rvSum.Docs = rvSum.Docs + 1 else if (sTemp == &quot;OT&quot; &amp;&amp; norej &amp;&amp; notsug) rvSum.Others = rvSum.Others + 1 ln = ln + 1 &#125;*/ if ( rvSum.major == rvSum0.major &amp;&amp; rvSum.general == rvSum0.general &amp;&amp; rvSum.suggestion == rvSum0.suggestion &amp;&amp;rvSum.open == rvSum0.open &amp;&amp; rvSum.closed == rvSum0.closed &amp;&amp; rvSum.rejected == rvSum0.rejected &amp;&amp;rvSum.duplicate == rvSum0.duplicate &amp;&amp; rvSum.discuss == rvSum0.discuss /*&amp;&amp; rvSum.SysReq == rvSum0.SysReq &amp;&amp; rvSum.SDes == rvSum0.SDes &amp;&amp; rvSum.SRS == rvSum0.SRS &amp;&amp; rvSum.HLD == rvSum0.HLD &amp;&amp; rvSum.LLD == rvSum0.LLD &amp;&amp; rvSum.TP == rvSum0.TP &amp;&amp; rvSum.Code == rvSum0.Code &amp;&amp; rvSum.Docs == rvSum0.Docs &amp;&amp; rvSum.Others == rvSum0.Others*/ ) return else &#123; delSummary(hbuf) setReviewSummary(hbuf, rvSum) &#125;&#125;macro getReviewSummary(hbuf)&#123; sel = SearchInBuf(hbuf, &quot;^Summary$&quot;, 0, 0, 1, 1, 0) rvSum = &quot;major=\&quot;0\&quot;;general=\&quot;0\&quot;;suggestion=\&quot;0\&quot;;open=\&quot;0\&quot;;closed=\&quot;0\&quot;;rejected=\&quot;0\&quot;;duplicate=\&quot;0\&quot;;discuss=\&quot;0\&quot;;revieweffort=\&quot;0\&quot;;reworkeffort=\&quot;0\&quot;;reviewsize=\&quot;0\&quot;&quot; if (sel == null) return rvSum /* get severity summary */ ln = sel.lnFirst + 2 sel = SearchInBuf(hbuf, &quot;^Major\\s+:\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.major = strmid(sLine, col, strlen(sLine)) sel = SearchInBuf(hbuf, &quot;^General\\s+:\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.general = strmid(sLine, col, strlen(sLine)) sel = SearchInBuf(hbuf, &quot;^Suggestion\\s+:\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.suggestion = strmid(sLine, col, strlen(sLine)) /* get status summary */ sel = SearchInBuf(hbuf, &quot;^Open\\s+:\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.open = strmid(sLine, col, strlen(sLine)) sel = SearchInBuf(hbuf, &quot;^Closed\\s+:\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.closed = strmid(sLine, col, strlen(sLine)) sel = SearchInBuf(hbuf, &quot;^Duplicated\\s+:\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.duplicate = strmid(sLine, col, strlen(sLine)) sel = SearchInBuf(hbuf, &quot;^Discuss\\s+:\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.discuss = strmid(sLine, col, strlen(sLine)) /* get categories summary */ /*sel = SearchInBuf(hbuf, &quot;^SysReq\\s+=\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.SysReq = strmid(sLine, col, strlen(sLine)) sel = SearchInBuf(hbuf, &quot;^SDes\\s+=\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.SDes = strmid(sLine, col, strlen(sLine)) sel = SearchInBuf(hbuf, &quot;^SRS\\s+=\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.SRS = strmid(sLine, col, strlen(sLine)) sel = SearchInBuf(hbuf, &quot;^HLD\\s+=\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.HLD = strmid(sLine, col, strlen(sLine)) sel = SearchInBuf(hbuf, &quot;^LLD\\s+=\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.LLD = strmid(sLine, col, strlen(sLine)) sel = SearchInBuf(hbuf, &quot;^TP\\s+=\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.TP = strmid(sLine, col, strlen(sLine)) sel = SearchInBuf(hbuf, &quot;^Code\\s+=\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.Code = strmid(sLine, col, strlen(sLine)) sel = SearchInBuf(hbuf, &quot;^Docs\\s+=\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.Docs = strmid(sLine, col, strlen(sLine)) sel = SearchInBuf(hbuf, &quot;^Others\\s+=\\s+&quot;, ln, 0, 1, 1, 0) col = sel.ichLim sLine = GetBufLine(hbuf, sel.lnFirst) rvSum.Others = strmid(sLine, col, strlen(sLine))*/ return rvSum&#125;macro setReviewSummary(hbuf, rvSum)&#123; AppendBufLine(hbuf, &quot;Summary&quot;) AppendBufLine(hbuf, &quot;-------------------------------------------------------------------------&quot;) /* Defects sumary */ AppendBufLine(hbuf, &quot;[Defects Summary]&quot;) s = Cat(&quot;Total defects : &quot;, rvSum.major + rvSum.general + rvSum.suggestion) AppendBufLine(hbuf, s) s = Cat(&quot;Major : &quot;, rvSum.major) AppendBufLine(hbuf, s) s = Cat(&quot;General : &quot;, rvSum.general) AppendBufLine(hbuf, s) s = Cat(&quot;Suggestion : &quot;, rvSum.suggestion) AppendBufLine(hbuf, s) /* Status sumary */ AppendBufLine(hbuf, &quot;&quot;) AppendBufLine(hbuf, &quot;[Status Summary]&quot;) s = Cat(&quot;Open : &quot;, rvSum.open) AppendBufLine(hbuf, s) s = Cat(&quot;Closed : &quot;, rvSum.closed) AppendBufLine(hbuf, s) s = Cat(&quot;Rejected : &quot;, rvSum.rejected) AppendBufLine(hbuf, s) s = Cat(&quot;Duplicated : &quot;, rvSum.duplicate) AppendBufLine(hbuf, s) s = Cat(&quot;Discuss : &quot;, rvSum.discuss) AppendBufLine(hbuf, s) &#125;macro delSummary(hbuf)&#123; sel = SearchInBuf(hbuf, &quot;^Summary$&quot;, 0, 0, 1, 1, 0) if (sel == null) return else &#123; ln = sel.lnFirst LineCount = GetBufLineCount(hbuf) - 1 while(LineCount &gt;= ln) &#123; DelBufLine(hbuf, LineCount) LineCount = LineCount -1; &#125; &#125;&#125;macro validDefect(hbuf, ln)&#123; sel = SearchInBuf(hbuf, &quot;^Status\\s+:\\s+&quot;, ln, 0, 1, 1, 0) if (sel == null) return True; ln = sel.lnFirst col = sel.ichLim s = GetBufLine(hbuf, ln) sTemp = strmid(s, col, col+1) sTemp = toupper(sTemp); if (sTemp == &quot;R&quot;) return False; else if (sTemp == &quot;D&quot;) &#123; sTemp = strmid(s, col+1, col+2) sTemp = toupper(sTemp); if (sTemp == &quot;U&quot;) return False; &#125; return True;&#125;macro notsuggestion(hbuf, ln)&#123; sel = SearchInBuf(hbuf, &quot;^Severity\\s+:\\s+&quot;, ln, 0, 1, 1, 0) if (sel == null) return True; ln = sel.lnFirst col = sel.ichLim s = GetBufLine(hbuf, ln) sTemp = strmid(s, col, col+1) sTemp = toupper(sTEmp); if (sTemp == &quot;S&quot;) return False; return True;&#125;]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>SourceInsight</tag>
        <tag>CodeReview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhexo-blog%2F2015%2F12%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
